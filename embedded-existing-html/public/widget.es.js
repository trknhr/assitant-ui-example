function GP(e, t) {
  for (var n = 0; n < t.length; n++) {
    const i = t[n];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const r in i)
        if (r !== "default" && !(r in e)) {
          const s = Object.getOwnPropertyDescriptor(i, r);
          s && Object.defineProperty(e, r, s.get ? s : {
            enumerable: !0,
            get: () => i[r]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
function la(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var zm = { exports: {} }, Me = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QS;
function YP() {
  if (QS) return Me;
  QS = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), s = Symbol.for("react.consumer"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), f = Symbol.for("react.suspense"), h = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), m = Symbol.iterator;
  function y(S) {
    return S === null || typeof S != "object" ? null : (S = m && S[m] || S["@@iterator"], typeof S == "function" ? S : null);
  }
  var b = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, x = Object.assign, w = {};
  function k(S, X, fe) {
    this.props = S, this.context = X, this.refs = w, this.updater = fe || b;
  }
  k.prototype.isReactComponent = {}, k.prototype.setState = function(S, X) {
    if (typeof S != "object" && typeof S != "function" && S != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, S, X, "setState");
  }, k.prototype.forceUpdate = function(S) {
    this.updater.enqueueForceUpdate(this, S, "forceUpdate");
  };
  function T() {
  }
  T.prototype = k.prototype;
  function A(S, X, fe) {
    this.props = S, this.context = X, this.refs = w, this.updater = fe || b;
  }
  var z = A.prototype = new T();
  z.constructor = A, x(z, k.prototype), z.isPureReactComponent = !0;
  var O = Array.isArray, M = { H: null, A: null, T: null, S: null, V: null }, N = Object.prototype.hasOwnProperty;
  function U(S, X, fe, I, he, Ie) {
    return fe = Ie.ref, {
      $$typeof: e,
      type: S,
      key: X,
      ref: fe !== void 0 ? fe : null,
      props: Ie
    };
  }
  function Z(S, X) {
    return U(
      S.type,
      X,
      void 0,
      void 0,
      void 0,
      S.props
    );
  }
  function re(S) {
    return typeof S == "object" && S !== null && S.$$typeof === e;
  }
  function D(S) {
    var X = { "=": "=0", ":": "=2" };
    return "$" + S.replace(/[=:]/g, function(fe) {
      return X[fe];
    });
  }
  var ae = /\/+/g;
  function ie(S, X) {
    return typeof S == "object" && S !== null && S.key != null ? D("" + S.key) : X.toString(36);
  }
  function le() {
  }
  function se(S) {
    switch (S.status) {
      case "fulfilled":
        return S.value;
      case "rejected":
        throw S.reason;
      default:
        switch (typeof S.status == "string" ? S.then(le, le) : (S.status = "pending", S.then(
          function(X) {
            S.status === "pending" && (S.status = "fulfilled", S.value = X);
          },
          function(X) {
            S.status === "pending" && (S.status = "rejected", S.reason = X);
          }
        )), S.status) {
          case "fulfilled":
            return S.value;
          case "rejected":
            throw S.reason;
        }
    }
    throw S;
  }
  function ce(S, X, fe, I, he) {
    var Ie = typeof S;
    (Ie === "undefined" || Ie === "boolean") && (S = null);
    var pe = !1;
    if (S === null) pe = !0;
    else
      switch (Ie) {
        case "bigint":
        case "string":
        case "number":
          pe = !0;
          break;
        case "object":
          switch (S.$$typeof) {
            case e:
            case t:
              pe = !0;
              break;
            case p:
              return pe = S._init, ce(
                pe(S._payload),
                X,
                fe,
                I,
                he
              );
          }
      }
    if (pe)
      return he = he(S), pe = I === "" ? "." + ie(S, 0) : I, O(he) ? (fe = "", pe != null && (fe = pe.replace(ae, "$&/") + "/"), ce(he, X, fe, "", function(kt) {
        return kt;
      })) : he != null && (re(he) && (he = Z(
        he,
        fe + (he.key == null || S && S.key === he.key ? "" : ("" + he.key).replace(
          ae,
          "$&/"
        ) + "/") + pe
      )), X.push(he)), 1;
    pe = 0;
    var Ce = I === "" ? "." : I + ":";
    if (O(S))
      for (var Pe = 0; Pe < S.length; Pe++)
        I = S[Pe], Ie = Ce + ie(I, Pe), pe += ce(
          I,
          X,
          fe,
          Ie,
          he
        );
    else if (Pe = y(S), typeof Pe == "function")
      for (S = Pe.call(S), Pe = 0; !(I = S.next()).done; )
        I = I.value, Ie = Ce + ie(I, Pe++), pe += ce(
          I,
          X,
          fe,
          Ie,
          he
        );
    else if (Ie === "object") {
      if (typeof S.then == "function")
        return ce(
          se(S),
          X,
          fe,
          I,
          he
        );
      throw X = String(S), Error(
        "Objects are not valid as a React child (found: " + (X === "[object Object]" ? "object with keys {" + Object.keys(S).join(", ") + "}" : X) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return pe;
  }
  function L(S, X, fe) {
    if (S == null) return S;
    var I = [], he = 0;
    return ce(S, I, "", "", function(Ie) {
      return X.call(fe, Ie, he++);
    }), I;
  }
  function Y(S) {
    if (S._status === -1) {
      var X = S._result;
      X = X(), X.then(
        function(fe) {
          (S._status === 0 || S._status === -1) && (S._status = 1, S._result = fe);
        },
        function(fe) {
          (S._status === 0 || S._status === -1) && (S._status = 2, S._result = fe);
        }
      ), S._status === -1 && (S._status = 0, S._result = X);
    }
    if (S._status === 1) return S._result.default;
    throw S._result;
  }
  var H = typeof reportError == "function" ? reportError : function(S) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var X = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof S == "object" && S !== null && typeof S.message == "string" ? String(S.message) : String(S),
        error: S
      });
      if (!window.dispatchEvent(X)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", S);
      return;
    }
    console.error(S);
  };
  function ge() {
  }
  return Me.Children = {
    map: L,
    forEach: function(S, X, fe) {
      L(
        S,
        function() {
          X.apply(this, arguments);
        },
        fe
      );
    },
    count: function(S) {
      var X = 0;
      return L(S, function() {
        X++;
      }), X;
    },
    toArray: function(S) {
      return L(S, function(X) {
        return X;
      }) || [];
    },
    only: function(S) {
      if (!re(S))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return S;
    }
  }, Me.Component = k, Me.Fragment = n, Me.Profiler = r, Me.PureComponent = A, Me.StrictMode = i, Me.Suspense = f, Me.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = M, Me.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(S) {
      return M.H.useMemoCache(S);
    }
  }, Me.cache = function(S) {
    return function() {
      return S.apply(null, arguments);
    };
  }, Me.cloneElement = function(S, X, fe) {
    if (S == null)
      throw Error(
        "The argument must be a React element, but you passed " + S + "."
      );
    var I = x({}, S.props), he = S.key, Ie = void 0;
    if (X != null)
      for (pe in X.ref !== void 0 && (Ie = void 0), X.key !== void 0 && (he = "" + X.key), X)
        !N.call(X, pe) || pe === "key" || pe === "__self" || pe === "__source" || pe === "ref" && X.ref === void 0 || (I[pe] = X[pe]);
    var pe = arguments.length - 2;
    if (pe === 1) I.children = fe;
    else if (1 < pe) {
      for (var Ce = Array(pe), Pe = 0; Pe < pe; Pe++)
        Ce[Pe] = arguments[Pe + 2];
      I.children = Ce;
    }
    return U(S.type, he, void 0, void 0, Ie, I);
  }, Me.createContext = function(S) {
    return S = {
      $$typeof: l,
      _currentValue: S,
      _currentValue2: S,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, S.Provider = S, S.Consumer = {
      $$typeof: s,
      _context: S
    }, S;
  }, Me.createElement = function(S, X, fe) {
    var I, he = {}, Ie = null;
    if (X != null)
      for (I in X.key !== void 0 && (Ie = "" + X.key), X)
        N.call(X, I) && I !== "key" && I !== "__self" && I !== "__source" && (he[I] = X[I]);
    var pe = arguments.length - 2;
    if (pe === 1) he.children = fe;
    else if (1 < pe) {
      for (var Ce = Array(pe), Pe = 0; Pe < pe; Pe++)
        Ce[Pe] = arguments[Pe + 2];
      he.children = Ce;
    }
    if (S && S.defaultProps)
      for (I in pe = S.defaultProps, pe)
        he[I] === void 0 && (he[I] = pe[I]);
    return U(S, Ie, void 0, void 0, null, he);
  }, Me.createRef = function() {
    return { current: null };
  }, Me.forwardRef = function(S) {
    return { $$typeof: c, render: S };
  }, Me.isValidElement = re, Me.lazy = function(S) {
    return {
      $$typeof: p,
      _payload: { _status: -1, _result: S },
      _init: Y
    };
  }, Me.memo = function(S, X) {
    return {
      $$typeof: h,
      type: S,
      compare: X === void 0 ? null : X
    };
  }, Me.startTransition = function(S) {
    var X = M.T, fe = {};
    M.T = fe;
    try {
      var I = S(), he = M.S;
      he !== null && he(fe, I), typeof I == "object" && I !== null && typeof I.then == "function" && I.then(ge, H);
    } catch (Ie) {
      H(Ie);
    } finally {
      M.T = X;
    }
  }, Me.unstable_useCacheRefresh = function() {
    return M.H.useCacheRefresh();
  }, Me.use = function(S) {
    return M.H.use(S);
  }, Me.useActionState = function(S, X, fe) {
    return M.H.useActionState(S, X, fe);
  }, Me.useCallback = function(S, X) {
    return M.H.useCallback(S, X);
  }, Me.useContext = function(S) {
    return M.H.useContext(S);
  }, Me.useDebugValue = function() {
  }, Me.useDeferredValue = function(S, X) {
    return M.H.useDeferredValue(S, X);
  }, Me.useEffect = function(S, X, fe) {
    var I = M.H;
    if (typeof fe == "function")
      throw Error(
        "useEffect CRUD overload is not enabled in this build of React."
      );
    return I.useEffect(S, X);
  }, Me.useId = function() {
    return M.H.useId();
  }, Me.useImperativeHandle = function(S, X, fe) {
    return M.H.useImperativeHandle(S, X, fe);
  }, Me.useInsertionEffect = function(S, X) {
    return M.H.useInsertionEffect(S, X);
  }, Me.useLayoutEffect = function(S, X) {
    return M.H.useLayoutEffect(S, X);
  }, Me.useMemo = function(S, X) {
    return M.H.useMemo(S, X);
  }, Me.useOptimistic = function(S, X) {
    return M.H.useOptimistic(S, X);
  }, Me.useReducer = function(S, X, fe) {
    return M.H.useReducer(S, X, fe);
  }, Me.useRef = function(S) {
    return M.H.useRef(S);
  }, Me.useState = function(S) {
    return M.H.useState(S);
  }, Me.useSyncExternalStore = function(S, X, fe) {
    return M.H.useSyncExternalStore(
      S,
      X,
      fe
    );
  }, Me.useTransition = function() {
    return M.H.useTransition();
  }, Me.version = "19.1.0", Me;
}
var e1;
function Lv() {
  return e1 || (e1 = 1, zm.exports = YP()), zm.exports;
}
var $ = Lv();
const Lr = /* @__PURE__ */ la($), QE = /* @__PURE__ */ GP({
  __proto__: null,
  default: Lr
}, [$]);
var Im = { exports: {} }, Il = {}, Cm = { exports: {} }, Om = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var t1;
function JP() {
  return t1 || (t1 = 1, (function(e) {
    function t(L, Y) {
      var H = L.length;
      L.push(Y);
      e: for (; 0 < H; ) {
        var ge = H - 1 >>> 1, S = L[ge];
        if (0 < r(S, Y))
          L[ge] = Y, L[H] = S, H = ge;
        else break e;
      }
    }
    function n(L) {
      return L.length === 0 ? null : L[0];
    }
    function i(L) {
      if (L.length === 0) return null;
      var Y = L[0], H = L.pop();
      if (H !== Y) {
        L[0] = H;
        e: for (var ge = 0, S = L.length, X = S >>> 1; ge < X; ) {
          var fe = 2 * (ge + 1) - 1, I = L[fe], he = fe + 1, Ie = L[he];
          if (0 > r(I, H))
            he < S && 0 > r(Ie, I) ? (L[ge] = Ie, L[he] = H, ge = he) : (L[ge] = I, L[fe] = H, ge = fe);
          else if (he < S && 0 > r(Ie, H))
            L[ge] = Ie, L[he] = H, ge = he;
          else break e;
        }
      }
      return Y;
    }
    function r(L, Y) {
      var H = L.sortIndex - Y.sortIndex;
      return H !== 0 ? H : L.id - Y.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      e.unstable_now = function() {
        return s.now();
      };
    } else {
      var l = Date, c = l.now();
      e.unstable_now = function() {
        return l.now() - c;
      };
    }
    var f = [], h = [], p = 1, m = null, y = 3, b = !1, x = !1, w = !1, k = !1, T = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, z = typeof setImmediate < "u" ? setImmediate : null;
    function O(L) {
      for (var Y = n(h); Y !== null; ) {
        if (Y.callback === null) i(h);
        else if (Y.startTime <= L)
          i(h), Y.sortIndex = Y.expirationTime, t(f, Y);
        else break;
        Y = n(h);
      }
    }
    function M(L) {
      if (w = !1, O(L), !x)
        if (n(f) !== null)
          x = !0, N || (N = !0, ie());
        else {
          var Y = n(h);
          Y !== null && ce(M, Y.startTime - L);
        }
    }
    var N = !1, U = -1, Z = 5, re = -1;
    function D() {
      return k ? !0 : !(e.unstable_now() - re < Z);
    }
    function ae() {
      if (k = !1, N) {
        var L = e.unstable_now();
        re = L;
        var Y = !0;
        try {
          e: {
            x = !1, w && (w = !1, A(U), U = -1), b = !0;
            var H = y;
            try {
              t: {
                for (O(L), m = n(f); m !== null && !(m.expirationTime > L && D()); ) {
                  var ge = m.callback;
                  if (typeof ge == "function") {
                    m.callback = null, y = m.priorityLevel;
                    var S = ge(
                      m.expirationTime <= L
                    );
                    if (L = e.unstable_now(), typeof S == "function") {
                      m.callback = S, O(L), Y = !0;
                      break t;
                    }
                    m === n(f) && i(f), O(L);
                  } else i(f);
                  m = n(f);
                }
                if (m !== null) Y = !0;
                else {
                  var X = n(h);
                  X !== null && ce(
                    M,
                    X.startTime - L
                  ), Y = !1;
                }
              }
              break e;
            } finally {
              m = null, y = H, b = !1;
            }
            Y = void 0;
          }
        } finally {
          Y ? ie() : N = !1;
        }
      }
    }
    var ie;
    if (typeof z == "function")
      ie = function() {
        z(ae);
      };
    else if (typeof MessageChannel < "u") {
      var le = new MessageChannel(), se = le.port2;
      le.port1.onmessage = ae, ie = function() {
        se.postMessage(null);
      };
    } else
      ie = function() {
        T(ae, 0);
      };
    function ce(L, Y) {
      U = T(function() {
        L(e.unstable_now());
      }, Y);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(L) {
      L.callback = null;
    }, e.unstable_forceFrameRate = function(L) {
      0 > L || 125 < L ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : Z = 0 < L ? Math.floor(1e3 / L) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return y;
    }, e.unstable_next = function(L) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var Y = 3;
          break;
        default:
          Y = y;
      }
      var H = y;
      y = Y;
      try {
        return L();
      } finally {
        y = H;
      }
    }, e.unstable_requestPaint = function() {
      k = !0;
    }, e.unstable_runWithPriority = function(L, Y) {
      switch (L) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          L = 3;
      }
      var H = y;
      y = L;
      try {
        return Y();
      } finally {
        y = H;
      }
    }, e.unstable_scheduleCallback = function(L, Y, H) {
      var ge = e.unstable_now();
      switch (typeof H == "object" && H !== null ? (H = H.delay, H = typeof H == "number" && 0 < H ? ge + H : ge) : H = ge, L) {
        case 1:
          var S = -1;
          break;
        case 2:
          S = 250;
          break;
        case 5:
          S = 1073741823;
          break;
        case 4:
          S = 1e4;
          break;
        default:
          S = 5e3;
      }
      return S = H + S, L = {
        id: p++,
        callback: Y,
        priorityLevel: L,
        startTime: H,
        expirationTime: S,
        sortIndex: -1
      }, H > ge ? (L.sortIndex = H, t(h, L), n(f) === null && L === n(h) && (w ? (A(U), U = -1) : w = !0, ce(M, H - ge))) : (L.sortIndex = S, t(f, L), x || b || (x = !0, N || (N = !0, ie()))), L;
    }, e.unstable_shouldYield = D, e.unstable_wrapCallback = function(L) {
      var Y = y;
      return function() {
        var H = y;
        y = Y;
        try {
          return L.apply(this, arguments);
        } finally {
          y = H;
        }
      };
    };
  })(Om)), Om;
}
var n1;
function XP() {
  return n1 || (n1 = 1, Cm.exports = JP()), Cm.exports;
}
var Rm = { exports: {} }, an = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var r1;
function KP() {
  if (r1) return an;
  r1 = 1;
  var e = Lv();
  function t(f) {
    var h = "https://react.dev/errors/" + f;
    if (1 < arguments.length) {
      h += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var p = 2; p < arguments.length; p++)
        h += "&args[]=" + encodeURIComponent(arguments[p]);
    }
    return "Minified React error #" + f + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var i = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, r = Symbol.for("react.portal");
  function s(f, h, p) {
    var m = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: r,
      key: m == null ? null : "" + m,
      children: f,
      containerInfo: h,
      implementation: p
    };
  }
  var l = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function c(f, h) {
    if (f === "font") return "";
    if (typeof h == "string")
      return h === "use-credentials" ? h : "";
  }
  return an.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = i, an.createPortal = function(f, h) {
    var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11)
      throw Error(t(299));
    return s(f, h, null, p);
  }, an.flushSync = function(f) {
    var h = l.T, p = i.p;
    try {
      if (l.T = null, i.p = 2, f) return f();
    } finally {
      l.T = h, i.p = p, i.d.f();
    }
  }, an.preconnect = function(f, h) {
    typeof f == "string" && (h ? (h = h.crossOrigin, h = typeof h == "string" ? h === "use-credentials" ? h : "" : void 0) : h = null, i.d.C(f, h));
  }, an.prefetchDNS = function(f) {
    typeof f == "string" && i.d.D(f);
  }, an.preinit = function(f, h) {
    if (typeof f == "string" && h && typeof h.as == "string") {
      var p = h.as, m = c(p, h.crossOrigin), y = typeof h.integrity == "string" ? h.integrity : void 0, b = typeof h.fetchPriority == "string" ? h.fetchPriority : void 0;
      p === "style" ? i.d.S(
        f,
        typeof h.precedence == "string" ? h.precedence : void 0,
        {
          crossOrigin: m,
          integrity: y,
          fetchPriority: b
        }
      ) : p === "script" && i.d.X(f, {
        crossOrigin: m,
        integrity: y,
        fetchPriority: b,
        nonce: typeof h.nonce == "string" ? h.nonce : void 0
      });
    }
  }, an.preinitModule = function(f, h) {
    if (typeof f == "string")
      if (typeof h == "object" && h !== null) {
        if (h.as == null || h.as === "script") {
          var p = c(
            h.as,
            h.crossOrigin
          );
          i.d.M(f, {
            crossOrigin: p,
            integrity: typeof h.integrity == "string" ? h.integrity : void 0,
            nonce: typeof h.nonce == "string" ? h.nonce : void 0
          });
        }
      } else h == null && i.d.M(f);
  }, an.preload = function(f, h) {
    if (typeof f == "string" && typeof h == "object" && h !== null && typeof h.as == "string") {
      var p = h.as, m = c(p, h.crossOrigin);
      i.d.L(f, p, {
        crossOrigin: m,
        integrity: typeof h.integrity == "string" ? h.integrity : void 0,
        nonce: typeof h.nonce == "string" ? h.nonce : void 0,
        type: typeof h.type == "string" ? h.type : void 0,
        fetchPriority: typeof h.fetchPriority == "string" ? h.fetchPriority : void 0,
        referrerPolicy: typeof h.referrerPolicy == "string" ? h.referrerPolicy : void 0,
        imageSrcSet: typeof h.imageSrcSet == "string" ? h.imageSrcSet : void 0,
        imageSizes: typeof h.imageSizes == "string" ? h.imageSizes : void 0,
        media: typeof h.media == "string" ? h.media : void 0
      });
    }
  }, an.preloadModule = function(f, h) {
    if (typeof f == "string")
      if (h) {
        var p = c(h.as, h.crossOrigin);
        i.d.m(f, {
          as: typeof h.as == "string" && h.as !== "script" ? h.as : void 0,
          crossOrigin: p,
          integrity: typeof h.integrity == "string" ? h.integrity : void 0
        });
      } else i.d.m(f);
  }, an.requestFormReset = function(f) {
    i.d.r(f);
  }, an.unstable_batchedUpdates = function(f, h) {
    return f(h);
  }, an.useFormState = function(f, h, p) {
    return l.H.useFormState(f, h, p);
  }, an.useFormStatus = function() {
    return l.H.useHostTransitionStatus();
  }, an.version = "19.1.0", an;
}
var i1;
function e$() {
  if (i1) return Rm.exports;
  i1 = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Rm.exports = KP(), Rm.exports;
}
var a1;
function WP() {
  if (a1) return Il;
  a1 = 1;
  /**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var e = XP(), t = Lv(), n = e$();
  function i(a) {
    var o = "https://react.dev/errors/" + a;
    if (1 < arguments.length) {
      o += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var u = 2; u < arguments.length; u++)
        o += "&args[]=" + encodeURIComponent(arguments[u]);
    }
    return "Minified React error #" + a + "; visit " + o + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function r(a) {
    return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11);
  }
  function s(a) {
    var o = a, u = a;
    if (a.alternate) for (; o.return; ) o = o.return;
    else {
      a = o;
      do
        o = a, (o.flags & 4098) !== 0 && (u = o.return), a = o.return;
      while (a);
    }
    return o.tag === 3 ? u : null;
  }
  function l(a) {
    if (a.tag === 13) {
      var o = a.memoizedState;
      if (o === null && (a = a.alternate, a !== null && (o = a.memoizedState)), o !== null) return o.dehydrated;
    }
    return null;
  }
  function c(a) {
    if (s(a) !== a)
      throw Error(i(188));
  }
  function f(a) {
    var o = a.alternate;
    if (!o) {
      if (o = s(a), o === null) throw Error(i(188));
      return o !== a ? null : a;
    }
    for (var u = a, d = o; ; ) {
      var g = u.return;
      if (g === null) break;
      var v = g.alternate;
      if (v === null) {
        if (d = g.return, d !== null) {
          u = d;
          continue;
        }
        break;
      }
      if (g.child === v.child) {
        for (v = g.child; v; ) {
          if (v === u) return c(g), a;
          if (v === d) return c(g), o;
          v = v.sibling;
        }
        throw Error(i(188));
      }
      if (u.return !== d.return) u = g, d = v;
      else {
        for (var _ = !1, E = g.child; E; ) {
          if (E === u) {
            _ = !0, u = g, d = v;
            break;
          }
          if (E === d) {
            _ = !0, d = g, u = v;
            break;
          }
          E = E.sibling;
        }
        if (!_) {
          for (E = v.child; E; ) {
            if (E === u) {
              _ = !0, u = v, d = g;
              break;
            }
            if (E === d) {
              _ = !0, d = v, u = g;
              break;
            }
            E = E.sibling;
          }
          if (!_) throw Error(i(189));
        }
      }
      if (u.alternate !== d) throw Error(i(190));
    }
    if (u.tag !== 3) throw Error(i(188));
    return u.stateNode.current === u ? a : o;
  }
  function h(a) {
    var o = a.tag;
    if (o === 5 || o === 26 || o === 27 || o === 6) return a;
    for (a = a.child; a !== null; ) {
      if (o = h(a), o !== null) return o;
      a = a.sibling;
    }
    return null;
  }
  var p = Object.assign, m = Symbol.for("react.element"), y = Symbol.for("react.transitional.element"), b = Symbol.for("react.portal"), x = Symbol.for("react.fragment"), w = Symbol.for("react.strict_mode"), k = Symbol.for("react.profiler"), T = Symbol.for("react.provider"), A = Symbol.for("react.consumer"), z = Symbol.for("react.context"), O = Symbol.for("react.forward_ref"), M = Symbol.for("react.suspense"), N = Symbol.for("react.suspense_list"), U = Symbol.for("react.memo"), Z = Symbol.for("react.lazy"), re = Symbol.for("react.activity"), D = Symbol.for("react.memo_cache_sentinel"), ae = Symbol.iterator;
  function ie(a) {
    return a === null || typeof a != "object" ? null : (a = ae && a[ae] || a["@@iterator"], typeof a == "function" ? a : null);
  }
  var le = Symbol.for("react.client.reference");
  function se(a) {
    if (a == null) return null;
    if (typeof a == "function")
      return a.$$typeof === le ? null : a.displayName || a.name || null;
    if (typeof a == "string") return a;
    switch (a) {
      case x:
        return "Fragment";
      case k:
        return "Profiler";
      case w:
        return "StrictMode";
      case M:
        return "Suspense";
      case N:
        return "SuspenseList";
      case re:
        return "Activity";
    }
    if (typeof a == "object")
      switch (a.$$typeof) {
        case b:
          return "Portal";
        case z:
          return (a.displayName || "Context") + ".Provider";
        case A:
          return (a._context.displayName || "Context") + ".Consumer";
        case O:
          var o = a.render;
          return a = a.displayName, a || (a = o.displayName || o.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
        case U:
          return o = a.displayName || null, o !== null ? o : se(a.type) || "Memo";
        case Z:
          o = a._payload, a = a._init;
          try {
            return se(a(o));
          } catch {
          }
      }
    return null;
  }
  var ce = Array.isArray, L = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Y = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, H = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, ge = [], S = -1;
  function X(a) {
    return { current: a };
  }
  function fe(a) {
    0 > S || (a.current = ge[S], ge[S] = null, S--);
  }
  function I(a, o) {
    S++, ge[S] = a.current, a.current = o;
  }
  var he = X(null), Ie = X(null), pe = X(null), Ce = X(null);
  function Pe(a, o) {
    switch (I(pe, o), I(Ie, a), I(he, null), o.nodeType) {
      case 9:
      case 11:
        a = (a = o.documentElement) && (a = a.namespaceURI) ? $S(a) : 0;
        break;
      default:
        if (a = o.tagName, o = o.namespaceURI)
          o = $S(o), a = AS(o, a);
        else
          switch (a) {
            case "svg":
              a = 1;
              break;
            case "math":
              a = 2;
              break;
            default:
              a = 0;
          }
    }
    fe(he), I(he, a);
  }
  function kt() {
    fe(he), fe(Ie), fe(pe);
  }
  function Kt(a) {
    a.memoizedState !== null && I(Ce, a);
    var o = he.current, u = AS(o, a.type);
    o !== u && (I(Ie, a), I(he, u));
  }
  function un(a) {
    Ie.current === a && (fe(he), fe(Ie)), Ce.current === a && (fe(Ce), Tl._currentValue = H);
  }
  var Jn = Object.prototype.hasOwnProperty, Cr = e.unstable_scheduleCallback, Oo = e.unstable_cancelCallback, Ju = e.unstable_shouldYield, Xu = e.unstable_requestPaint, In = e.unstable_now, ph = e.unstable_getCurrentPriorityLevel, Ro = e.unstable_ImmediatePriority, No = e.unstable_UserBlockingPriority, rs = e.unstable_NormalPriority, mh = e.unstable_LowPriority, Ku = e.unstable_IdlePriority, gh = e.log, vh = e.unstable_setDisableYieldValue, J = null, oe = null;
  function _e(a) {
    if (typeof gh == "function" && vh(a), oe && typeof oe.setStrictMode == "function")
      try {
        oe.setStrictMode(J, a);
      } catch {
      }
  }
  var $e = Math.clz32 ? Math.clz32 : Kr, Qe = Math.log, Cn = Math.LN2;
  function Kr(a) {
    return a >>>= 0, a === 0 ? 32 : 31 - (Qe(a) / Cn | 0) | 0;
  }
  var yn = 256, Or = 4194304;
  function On(a) {
    var o = a & 42;
    if (o !== 0) return o;
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return a & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return a;
    }
  }
  function Ht(a, o, u) {
    var d = a.pendingLanes;
    if (d === 0) return 0;
    var g = 0, v = a.suspendedLanes, _ = a.pingedLanes;
    a = a.warmLanes;
    var E = d & 134217727;
    return E !== 0 ? (d = E & ~v, d !== 0 ? g = On(d) : (_ &= E, _ !== 0 ? g = On(_) : u || (u = E & ~a, u !== 0 && (g = On(u))))) : (E = d & ~v, E !== 0 ? g = On(E) : _ !== 0 ? g = On(_) : u || (u = d & ~a, u !== 0 && (g = On(u)))), g === 0 ? 0 : o !== 0 && o !== g && (o & v) === 0 && (v = g & -g, u = o & -o, v >= u || v === 32 && (u & 4194048) !== 0) ? o : g;
  }
  function Xn(a, o) {
    return (a.pendingLanes & ~(a.suspendedLanes & ~a.pingedLanes) & o) === 0;
  }
  function hr(a, o) {
    switch (a) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return o + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function cw() {
    var a = yn;
    return yn <<= 1, (yn & 4194048) === 0 && (yn = 256), a;
  }
  function dw() {
    var a = Or;
    return Or <<= 1, (Or & 62914560) === 0 && (Or = 4194304), a;
  }
  function yh(a) {
    for (var o = [], u = 0; 31 > u; u++) o.push(a);
    return o;
  }
  function Mo(a, o) {
    a.pendingLanes |= o, o !== 268435456 && (a.suspendedLanes = 0, a.pingedLanes = 0, a.warmLanes = 0);
  }
  function Mj(a, o, u, d, g, v) {
    var _ = a.pendingLanes;
    a.pendingLanes = u, a.suspendedLanes = 0, a.pingedLanes = 0, a.warmLanes = 0, a.expiredLanes &= u, a.entangledLanes &= u, a.errorRecoveryDisabledLanes &= u, a.shellSuspendCounter = 0;
    var E = a.entanglements, R = a.expirationTimes, F = a.hiddenUpdates;
    for (u = _ & ~u; 0 < u; ) {
      var K = 31 - $e(u), ee = 1 << K;
      E[K] = 0, R[K] = -1;
      var q = F[K];
      if (q !== null)
        for (F[K] = null, K = 0; K < q.length; K++) {
          var G = q[K];
          G !== null && (G.lane &= -536870913);
        }
      u &= ~ee;
    }
    d !== 0 && fw(a, d, 0), v !== 0 && g === 0 && a.tag !== 0 && (a.suspendedLanes |= v & ~(_ & ~o));
  }
  function fw(a, o, u) {
    a.pendingLanes |= o, a.suspendedLanes &= ~o;
    var d = 31 - $e(o);
    a.entangledLanes |= o, a.entanglements[d] = a.entanglements[d] | 1073741824 | u & 4194090;
  }
  function hw(a, o) {
    var u = a.entangledLanes |= o;
    for (a = a.entanglements; u; ) {
      var d = 31 - $e(u), g = 1 << d;
      g & o | a[d] & o && (a[d] |= o), u &= ~g;
    }
  }
  function bh(a) {
    switch (a) {
      case 2:
        a = 1;
        break;
      case 8:
        a = 4;
        break;
      case 32:
        a = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        a = 128;
        break;
      case 268435456:
        a = 134217728;
        break;
      default:
        a = 0;
    }
    return a;
  }
  function xh(a) {
    return a &= -a, 2 < a ? 8 < a ? (a & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function pw() {
    var a = Y.p;
    return a !== 0 ? a : (a = window.event, a === void 0 ? 32 : GS(a.type));
  }
  function Dj(a, o) {
    var u = Y.p;
    try {
      return Y.p = a, o();
    } finally {
      Y.p = u;
    }
  }
  var Ti = Math.random().toString(36).slice(2), nn = "__reactFiber$" + Ti, bn = "__reactProps$" + Ti, is = "__reactContainer$" + Ti, wh = "__reactEvents$" + Ti, jj = "__reactListeners$" + Ti, Pj = "__reactHandles$" + Ti, mw = "__reactResources$" + Ti, Do = "__reactMarker$" + Ti;
  function _h(a) {
    delete a[nn], delete a[bn], delete a[wh], delete a[jj], delete a[Pj];
  }
  function as(a) {
    var o = a[nn];
    if (o) return o;
    for (var u = a.parentNode; u; ) {
      if (o = u[is] || u[nn]) {
        if (u = o.alternate, o.child !== null || u !== null && u.child !== null)
          for (a = OS(a); a !== null; ) {
            if (u = a[nn]) return u;
            a = OS(a);
          }
        return o;
      }
      a = u, u = a.parentNode;
    }
    return null;
  }
  function ss(a) {
    if (a = a[nn] || a[is]) {
      var o = a.tag;
      if (o === 5 || o === 6 || o === 13 || o === 26 || o === 27 || o === 3)
        return a;
    }
    return null;
  }
  function jo(a) {
    var o = a.tag;
    if (o === 5 || o === 26 || o === 27 || o === 6) return a.stateNode;
    throw Error(i(33));
  }
  function os(a) {
    var o = a[mw];
    return o || (o = a[mw] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), o;
  }
  function qt(a) {
    a[Do] = !0;
  }
  var gw = /* @__PURE__ */ new Set(), vw = {};
  function ha(a, o) {
    ls(a, o), ls(a + "Capture", o);
  }
  function ls(a, o) {
    for (vw[a] = o, a = 0; a < o.length; a++)
      gw.add(o[a]);
  }
  var Uj = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), yw = {}, bw = {};
  function Lj(a) {
    return Jn.call(bw, a) ? !0 : Jn.call(yw, a) ? !1 : Uj.test(a) ? bw[a] = !0 : (yw[a] = !0, !1);
  }
  function Wu(a, o, u) {
    if (Lj(o))
      if (u === null) a.removeAttribute(o);
      else {
        switch (typeof u) {
          case "undefined":
          case "function":
          case "symbol":
            a.removeAttribute(o);
            return;
          case "boolean":
            var d = o.toLowerCase().slice(0, 5);
            if (d !== "data-" && d !== "aria-") {
              a.removeAttribute(o);
              return;
            }
        }
        a.setAttribute(o, "" + u);
      }
  }
  function Qu(a, o, u) {
    if (u === null) a.removeAttribute(o);
    else {
      switch (typeof u) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          a.removeAttribute(o);
          return;
      }
      a.setAttribute(o, "" + u);
    }
  }
  function Wr(a, o, u, d) {
    if (d === null) a.removeAttribute(u);
    else {
      switch (typeof d) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          a.removeAttribute(u);
          return;
      }
      a.setAttributeNS(o, u, "" + d);
    }
  }
  var Sh, xw;
  function us(a) {
    if (Sh === void 0)
      try {
        throw Error();
      } catch (u) {
        var o = u.stack.trim().match(/\n( *(at )?)/);
        Sh = o && o[1] || "", xw = -1 < u.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < u.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + Sh + a + xw;
  }
  var kh = !1;
  function Th(a, o) {
    if (!a || kh) return "";
    kh = !0;
    var u = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var d = {
        DetermineComponentFrameRoot: function() {
          try {
            if (o) {
              var ee = function() {
                throw Error();
              };
              if (Object.defineProperty(ee.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(ee, []);
                } catch (G) {
                  var q = G;
                }
                Reflect.construct(a, [], ee);
              } else {
                try {
                  ee.call();
                } catch (G) {
                  q = G;
                }
                a.call(ee.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (G) {
                q = G;
              }
              (ee = a()) && typeof ee.catch == "function" && ee.catch(function() {
              });
            }
          } catch (G) {
            if (G && q && typeof G.stack == "string")
              return [G.stack, q.stack];
          }
          return [null, null];
        }
      };
      d.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var g = Object.getOwnPropertyDescriptor(
        d.DetermineComponentFrameRoot,
        "name"
      );
      g && g.configurable && Object.defineProperty(
        d.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var v = d.DetermineComponentFrameRoot(), _ = v[0], E = v[1];
      if (_ && E) {
        var R = _.split(`
`), F = E.split(`
`);
        for (g = d = 0; d < R.length && !R[d].includes("DetermineComponentFrameRoot"); )
          d++;
        for (; g < F.length && !F[g].includes(
          "DetermineComponentFrameRoot"
        ); )
          g++;
        if (d === R.length || g === F.length)
          for (d = R.length - 1, g = F.length - 1; 1 <= d && 0 <= g && R[d] !== F[g]; )
            g--;
        for (; 1 <= d && 0 <= g; d--, g--)
          if (R[d] !== F[g]) {
            if (d !== 1 || g !== 1)
              do
                if (d--, g--, 0 > g || R[d] !== F[g]) {
                  var K = `
` + R[d].replace(" at new ", " at ");
                  return a.displayName && K.includes("<anonymous>") && (K = K.replace("<anonymous>", a.displayName)), K;
                }
              while (1 <= d && 0 <= g);
            break;
          }
      }
    } finally {
      kh = !1, Error.prepareStackTrace = u;
    }
    return (u = a ? a.displayName || a.name : "") ? us(u) : "";
  }
  function Bj(a) {
    switch (a.tag) {
      case 26:
      case 27:
      case 5:
        return us(a.type);
      case 16:
        return us("Lazy");
      case 13:
        return us("Suspense");
      case 19:
        return us("SuspenseList");
      case 0:
      case 15:
        return Th(a.type, !1);
      case 11:
        return Th(a.type.render, !1);
      case 1:
        return Th(a.type, !0);
      case 31:
        return us("Activity");
      default:
        return "";
    }
  }
  function ww(a) {
    try {
      var o = "";
      do
        o += Bj(a), a = a.return;
      while (a);
      return o;
    } catch (u) {
      return `
Error generating stack: ` + u.message + `
` + u.stack;
    }
  }
  function Kn(a) {
    switch (typeof a) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function _w(a) {
    var o = a.type;
    return (a = a.nodeName) && a.toLowerCase() === "input" && (o === "checkbox" || o === "radio");
  }
  function Zj(a) {
    var o = _w(a) ? "checked" : "value", u = Object.getOwnPropertyDescriptor(
      a.constructor.prototype,
      o
    ), d = "" + a[o];
    if (!a.hasOwnProperty(o) && typeof u < "u" && typeof u.get == "function" && typeof u.set == "function") {
      var g = u.get, v = u.set;
      return Object.defineProperty(a, o, {
        configurable: !0,
        get: function() {
          return g.call(this);
        },
        set: function(_) {
          d = "" + _, v.call(this, _);
        }
      }), Object.defineProperty(a, o, {
        enumerable: u.enumerable
      }), {
        getValue: function() {
          return d;
        },
        setValue: function(_) {
          d = "" + _;
        },
        stopTracking: function() {
          a._valueTracker = null, delete a[o];
        }
      };
    }
  }
  function ec(a) {
    a._valueTracker || (a._valueTracker = Zj(a));
  }
  function Sw(a) {
    if (!a) return !1;
    var o = a._valueTracker;
    if (!o) return !0;
    var u = o.getValue(), d = "";
    return a && (d = _w(a) ? a.checked ? "true" : "false" : a.value), a = d, a !== u ? (o.setValue(a), !0) : !1;
  }
  function tc(a) {
    if (a = a || (typeof document < "u" ? document : void 0), typeof a > "u") return null;
    try {
      return a.activeElement || a.body;
    } catch {
      return a.body;
    }
  }
  var Vj = /[\n"\\]/g;
  function Wn(a) {
    return a.replace(
      Vj,
      function(o) {
        return "\\" + o.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Eh(a, o, u, d, g, v, _, E) {
    a.name = "", _ != null && typeof _ != "function" && typeof _ != "symbol" && typeof _ != "boolean" ? a.type = _ : a.removeAttribute("type"), o != null ? _ === "number" ? (o === 0 && a.value === "" || a.value != o) && (a.value = "" + Kn(o)) : a.value !== "" + Kn(o) && (a.value = "" + Kn(o)) : _ !== "submit" && _ !== "reset" || a.removeAttribute("value"), o != null ? $h(a, _, Kn(o)) : u != null ? $h(a, _, Kn(u)) : d != null && a.removeAttribute("value"), g == null && v != null && (a.defaultChecked = !!v), g != null && (a.checked = g && typeof g != "function" && typeof g != "symbol"), E != null && typeof E != "function" && typeof E != "symbol" && typeof E != "boolean" ? a.name = "" + Kn(E) : a.removeAttribute("name");
  }
  function kw(a, o, u, d, g, v, _, E) {
    if (v != null && typeof v != "function" && typeof v != "symbol" && typeof v != "boolean" && (a.type = v), o != null || u != null) {
      if (!(v !== "submit" && v !== "reset" || o != null))
        return;
      u = u != null ? "" + Kn(u) : "", o = o != null ? "" + Kn(o) : u, E || o === a.value || (a.value = o), a.defaultValue = o;
    }
    d = d ?? g, d = typeof d != "function" && typeof d != "symbol" && !!d, a.checked = E ? a.checked : !!d, a.defaultChecked = !!d, _ != null && typeof _ != "function" && typeof _ != "symbol" && typeof _ != "boolean" && (a.name = _);
  }
  function $h(a, o, u) {
    o === "number" && tc(a.ownerDocument) === a || a.defaultValue === "" + u || (a.defaultValue = "" + u);
  }
  function cs(a, o, u, d) {
    if (a = a.options, o) {
      o = {};
      for (var g = 0; g < u.length; g++)
        o["$" + u[g]] = !0;
      for (u = 0; u < a.length; u++)
        g = o.hasOwnProperty("$" + a[u].value), a[u].selected !== g && (a[u].selected = g), g && d && (a[u].defaultSelected = !0);
    } else {
      for (u = "" + Kn(u), o = null, g = 0; g < a.length; g++) {
        if (a[g].value === u) {
          a[g].selected = !0, d && (a[g].defaultSelected = !0);
          return;
        }
        o !== null || a[g].disabled || (o = a[g]);
      }
      o !== null && (o.selected = !0);
    }
  }
  function Tw(a, o, u) {
    if (o != null && (o = "" + Kn(o), o !== a.value && (a.value = o), u == null)) {
      a.defaultValue !== o && (a.defaultValue = o);
      return;
    }
    a.defaultValue = u != null ? "" + Kn(u) : "";
  }
  function Ew(a, o, u, d) {
    if (o == null) {
      if (d != null) {
        if (u != null) throw Error(i(92));
        if (ce(d)) {
          if (1 < d.length) throw Error(i(93));
          d = d[0];
        }
        u = d;
      }
      u == null && (u = ""), o = u;
    }
    u = Kn(o), a.defaultValue = u, d = a.textContent, d === u && d !== "" && d !== null && (a.value = d);
  }
  function ds(a, o) {
    if (o) {
      var u = a.firstChild;
      if (u && u === a.lastChild && u.nodeType === 3) {
        u.nodeValue = o;
        return;
      }
    }
    a.textContent = o;
  }
  var Fj = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function $w(a, o, u) {
    var d = o.indexOf("--") === 0;
    u == null || typeof u == "boolean" || u === "" ? d ? a.setProperty(o, "") : o === "float" ? a.cssFloat = "" : a[o] = "" : d ? a.setProperty(o, u) : typeof u != "number" || u === 0 || Fj.has(o) ? o === "float" ? a.cssFloat = u : a[o] = ("" + u).trim() : a[o] = u + "px";
  }
  function Aw(a, o, u) {
    if (o != null && typeof o != "object")
      throw Error(i(62));
    if (a = a.style, u != null) {
      for (var d in u)
        !u.hasOwnProperty(d) || o != null && o.hasOwnProperty(d) || (d.indexOf("--") === 0 ? a.setProperty(d, "") : d === "float" ? a.cssFloat = "" : a[d] = "");
      for (var g in o)
        d = o[g], o.hasOwnProperty(g) && u[g] !== d && $w(a, g, d);
    } else
      for (var v in o)
        o.hasOwnProperty(v) && $w(a, v, o[v]);
  }
  function Ah(a) {
    if (a.indexOf("-") === -1) return !1;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Hj = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), qj = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function nc(a) {
    return qj.test("" + a) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : a;
  }
  var zh = null;
  function Ih(a) {
    return a = a.target || a.srcElement || window, a.correspondingUseElement && (a = a.correspondingUseElement), a.nodeType === 3 ? a.parentNode : a;
  }
  var fs = null, hs = null;
  function zw(a) {
    var o = ss(a);
    if (o && (a = o.stateNode)) {
      var u = a[bn] || null;
      e: switch (a = o.stateNode, o.type) {
        case "input":
          if (Eh(
            a,
            u.value,
            u.defaultValue,
            u.defaultValue,
            u.checked,
            u.defaultChecked,
            u.type,
            u.name
          ), o = u.name, u.type === "radio" && o != null) {
            for (u = a; u.parentNode; ) u = u.parentNode;
            for (u = u.querySelectorAll(
              'input[name="' + Wn(
                "" + o
              ) + '"][type="radio"]'
            ), o = 0; o < u.length; o++) {
              var d = u[o];
              if (d !== a && d.form === a.form) {
                var g = d[bn] || null;
                if (!g) throw Error(i(90));
                Eh(
                  d,
                  g.value,
                  g.defaultValue,
                  g.defaultValue,
                  g.checked,
                  g.defaultChecked,
                  g.type,
                  g.name
                );
              }
            }
            for (o = 0; o < u.length; o++)
              d = u[o], d.form === a.form && Sw(d);
          }
          break e;
        case "textarea":
          Tw(a, u.value, u.defaultValue);
          break e;
        case "select":
          o = u.value, o != null && cs(a, !!u.multiple, o, !1);
      }
    }
  }
  var Ch = !1;
  function Iw(a, o, u) {
    if (Ch) return a(o, u);
    Ch = !0;
    try {
      var d = a(o);
      return d;
    } finally {
      if (Ch = !1, (fs !== null || hs !== null) && (Bc(), fs && (o = fs, a = hs, hs = fs = null, zw(o), a)))
        for (o = 0; o < a.length; o++) zw(a[o]);
    }
  }
  function Po(a, o) {
    var u = a.stateNode;
    if (u === null) return null;
    var d = u[bn] || null;
    if (d === null) return null;
    u = d[o];
    e: switch (o) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !(a === "button" || a === "input" || a === "select" || a === "textarea")), a = !d;
        break e;
      default:
        a = !1;
    }
    if (a) return null;
    if (u && typeof u != "function")
      throw Error(
        i(231, o, typeof u)
      );
    return u;
  }
  var Qr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Oh = !1;
  if (Qr)
    try {
      var Uo = {};
      Object.defineProperty(Uo, "passive", {
        get: function() {
          Oh = !0;
        }
      }), window.addEventListener("test", Uo, Uo), window.removeEventListener("test", Uo, Uo);
    } catch {
      Oh = !1;
    }
  var Ei = null, Rh = null, rc = null;
  function Cw() {
    if (rc) return rc;
    var a, o = Rh, u = o.length, d, g = "value" in Ei ? Ei.value : Ei.textContent, v = g.length;
    for (a = 0; a < u && o[a] === g[a]; a++) ;
    var _ = u - a;
    for (d = 1; d <= _ && o[u - d] === g[v - d]; d++) ;
    return rc = g.slice(a, 1 < d ? 1 - d : void 0);
  }
  function ic(a) {
    var o = a.keyCode;
    return "charCode" in a ? (a = a.charCode, a === 0 && o === 13 && (a = 13)) : a = o, a === 10 && (a = 13), 32 <= a || a === 13 ? a : 0;
  }
  function ac() {
    return !0;
  }
  function Ow() {
    return !1;
  }
  function xn(a) {
    function o(u, d, g, v, _) {
      this._reactName = u, this._targetInst = g, this.type = d, this.nativeEvent = v, this.target = _, this.currentTarget = null;
      for (var E in a)
        a.hasOwnProperty(E) && (u = a[E], this[E] = u ? u(v) : v[E]);
      return this.isDefaultPrevented = (v.defaultPrevented != null ? v.defaultPrevented : v.returnValue === !1) ? ac : Ow, this.isPropagationStopped = Ow, this;
    }
    return p(o.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var u = this.nativeEvent;
        u && (u.preventDefault ? u.preventDefault() : typeof u.returnValue != "unknown" && (u.returnValue = !1), this.isDefaultPrevented = ac);
      },
      stopPropagation: function() {
        var u = this.nativeEvent;
        u && (u.stopPropagation ? u.stopPropagation() : typeof u.cancelBubble != "unknown" && (u.cancelBubble = !0), this.isPropagationStopped = ac);
      },
      persist: function() {
      },
      isPersistent: ac
    }), o;
  }
  var pa = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(a) {
      return a.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, sc = xn(pa), Lo = p({}, pa, { view: 0, detail: 0 }), Gj = xn(Lo), Nh, Mh, Bo, oc = p({}, Lo, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: jh,
    button: 0,
    buttons: 0,
    relatedTarget: function(a) {
      return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    },
    movementX: function(a) {
      return "movementX" in a ? a.movementX : (a !== Bo && (Bo && a.type === "mousemove" ? (Nh = a.screenX - Bo.screenX, Mh = a.screenY - Bo.screenY) : Mh = Nh = 0, Bo = a), Nh);
    },
    movementY: function(a) {
      return "movementY" in a ? a.movementY : Mh;
    }
  }), Rw = xn(oc), Yj = p({}, oc, { dataTransfer: 0 }), Jj = xn(Yj), Xj = p({}, Lo, { relatedTarget: 0 }), Dh = xn(Xj), Kj = p({}, pa, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Wj = xn(Kj), Qj = p({}, pa, {
    clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    }
  }), e4 = xn(Qj), t4 = p({}, pa, { data: 0 }), Nw = xn(t4), n4 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, r4 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, i4 = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function a4(a) {
    var o = this.nativeEvent;
    return o.getModifierState ? o.getModifierState(a) : (a = i4[a]) ? !!o[a] : !1;
  }
  function jh() {
    return a4;
  }
  var s4 = p({}, Lo, {
    key: function(a) {
      if (a.key) {
        var o = n4[a.key] || a.key;
        if (o !== "Unidentified") return o;
      }
      return a.type === "keypress" ? (a = ic(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? r4[a.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: jh,
    charCode: function(a) {
      return a.type === "keypress" ? ic(a) : 0;
    },
    keyCode: function(a) {
      return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
    },
    which: function(a) {
      return a.type === "keypress" ? ic(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
    }
  }), o4 = xn(s4), l4 = p({}, oc, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), Mw = xn(l4), u4 = p({}, Lo, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: jh
  }), c4 = xn(u4), d4 = p({}, pa, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), f4 = xn(d4), h4 = p({}, oc, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), p4 = xn(h4), m4 = p({}, pa, {
    newState: 0,
    oldState: 0
  }), g4 = xn(m4), v4 = [9, 13, 27, 32], Ph = Qr && "CompositionEvent" in window, Zo = null;
  Qr && "documentMode" in document && (Zo = document.documentMode);
  var y4 = Qr && "TextEvent" in window && !Zo, Dw = Qr && (!Ph || Zo && 8 < Zo && 11 >= Zo), jw = " ", Pw = !1;
  function Uw(a, o) {
    switch (a) {
      case "keyup":
        return v4.indexOf(o.keyCode) !== -1;
      case "keydown":
        return o.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Lw(a) {
    return a = a.detail, typeof a == "object" && "data" in a ? a.data : null;
  }
  var ps = !1;
  function b4(a, o) {
    switch (a) {
      case "compositionend":
        return Lw(o);
      case "keypress":
        return o.which !== 32 ? null : (Pw = !0, jw);
      case "textInput":
        return a = o.data, a === jw && Pw ? null : a;
      default:
        return null;
    }
  }
  function x4(a, o) {
    if (ps)
      return a === "compositionend" || !Ph && Uw(a, o) ? (a = Cw(), rc = Rh = Ei = null, ps = !1, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(o.ctrlKey || o.altKey || o.metaKey) || o.ctrlKey && o.altKey) {
          if (o.char && 1 < o.char.length)
            return o.char;
          if (o.which) return String.fromCharCode(o.which);
        }
        return null;
      case "compositionend":
        return Dw && o.locale !== "ko" ? null : o.data;
      default:
        return null;
    }
  }
  var w4 = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Bw(a) {
    var o = a && a.nodeName && a.nodeName.toLowerCase();
    return o === "input" ? !!w4[a.type] : o === "textarea";
  }
  function Zw(a, o, u, d) {
    fs ? hs ? hs.push(d) : hs = [d] : fs = d, o = Gc(o, "onChange"), 0 < o.length && (u = new sc(
      "onChange",
      "change",
      null,
      u,
      d
    ), a.push({ event: u, listeners: o }));
  }
  var Vo = null, Fo = null;
  function _4(a) {
    _S(a, 0);
  }
  function lc(a) {
    var o = jo(a);
    if (Sw(o)) return a;
  }
  function Vw(a, o) {
    if (a === "change") return o;
  }
  var Fw = !1;
  if (Qr) {
    var Uh;
    if (Qr) {
      var Lh = "oninput" in document;
      if (!Lh) {
        var Hw = document.createElement("div");
        Hw.setAttribute("oninput", "return;"), Lh = typeof Hw.oninput == "function";
      }
      Uh = Lh;
    } else Uh = !1;
    Fw = Uh && (!document.documentMode || 9 < document.documentMode);
  }
  function qw() {
    Vo && (Vo.detachEvent("onpropertychange", Gw), Fo = Vo = null);
  }
  function Gw(a) {
    if (a.propertyName === "value" && lc(Fo)) {
      var o = [];
      Zw(
        o,
        Fo,
        a,
        Ih(a)
      ), Iw(_4, o);
    }
  }
  function S4(a, o, u) {
    a === "focusin" ? (qw(), Vo = o, Fo = u, Vo.attachEvent("onpropertychange", Gw)) : a === "focusout" && qw();
  }
  function k4(a) {
    if (a === "selectionchange" || a === "keyup" || a === "keydown")
      return lc(Fo);
  }
  function T4(a, o) {
    if (a === "click") return lc(o);
  }
  function E4(a, o) {
    if (a === "input" || a === "change")
      return lc(o);
  }
  function $4(a, o) {
    return a === o && (a !== 0 || 1 / a === 1 / o) || a !== a && o !== o;
  }
  var Rn = typeof Object.is == "function" ? Object.is : $4;
  function Ho(a, o) {
    if (Rn(a, o)) return !0;
    if (typeof a != "object" || a === null || typeof o != "object" || o === null)
      return !1;
    var u = Object.keys(a), d = Object.keys(o);
    if (u.length !== d.length) return !1;
    for (d = 0; d < u.length; d++) {
      var g = u[d];
      if (!Jn.call(o, g) || !Rn(a[g], o[g]))
        return !1;
    }
    return !0;
  }
  function Yw(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function Jw(a, o) {
    var u = Yw(a);
    a = 0;
    for (var d; u; ) {
      if (u.nodeType === 3) {
        if (d = a + u.textContent.length, a <= o && d >= o)
          return { node: u, offset: o - a };
        a = d;
      }
      e: {
        for (; u; ) {
          if (u.nextSibling) {
            u = u.nextSibling;
            break e;
          }
          u = u.parentNode;
        }
        u = void 0;
      }
      u = Yw(u);
    }
  }
  function Xw(a, o) {
    return a && o ? a === o ? !0 : a && a.nodeType === 3 ? !1 : o && o.nodeType === 3 ? Xw(a, o.parentNode) : "contains" in a ? a.contains(o) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(o) & 16) : !1 : !1;
  }
  function Kw(a) {
    a = a != null && a.ownerDocument != null && a.ownerDocument.defaultView != null ? a.ownerDocument.defaultView : window;
    for (var o = tc(a.document); o instanceof a.HTMLIFrameElement; ) {
      try {
        var u = typeof o.contentWindow.location.href == "string";
      } catch {
        u = !1;
      }
      if (u) a = o.contentWindow;
      else break;
      o = tc(a.document);
    }
    return o;
  }
  function Bh(a) {
    var o = a && a.nodeName && a.nodeName.toLowerCase();
    return o && (o === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || o === "textarea" || a.contentEditable === "true");
  }
  var A4 = Qr && "documentMode" in document && 11 >= document.documentMode, ms = null, Zh = null, qo = null, Vh = !1;
  function Ww(a, o, u) {
    var d = u.window === u ? u.document : u.nodeType === 9 ? u : u.ownerDocument;
    Vh || ms == null || ms !== tc(d) || (d = ms, "selectionStart" in d && Bh(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {
      anchorNode: d.anchorNode,
      anchorOffset: d.anchorOffset,
      focusNode: d.focusNode,
      focusOffset: d.focusOffset
    }), qo && Ho(qo, d) || (qo = d, d = Gc(Zh, "onSelect"), 0 < d.length && (o = new sc(
      "onSelect",
      "select",
      null,
      o,
      u
    ), a.push({ event: o, listeners: d }), o.target = ms)));
  }
  function ma(a, o) {
    var u = {};
    return u[a.toLowerCase()] = o.toLowerCase(), u["Webkit" + a] = "webkit" + o, u["Moz" + a] = "moz" + o, u;
  }
  var gs = {
    animationend: ma("Animation", "AnimationEnd"),
    animationiteration: ma("Animation", "AnimationIteration"),
    animationstart: ma("Animation", "AnimationStart"),
    transitionrun: ma("Transition", "TransitionRun"),
    transitionstart: ma("Transition", "TransitionStart"),
    transitioncancel: ma("Transition", "TransitionCancel"),
    transitionend: ma("Transition", "TransitionEnd")
  }, Fh = {}, Qw = {};
  Qr && (Qw = document.createElement("div").style, "AnimationEvent" in window || (delete gs.animationend.animation, delete gs.animationiteration.animation, delete gs.animationstart.animation), "TransitionEvent" in window || delete gs.transitionend.transition);
  function ga(a) {
    if (Fh[a]) return Fh[a];
    if (!gs[a]) return a;
    var o = gs[a], u;
    for (u in o)
      if (o.hasOwnProperty(u) && u in Qw)
        return Fh[a] = o[u];
    return a;
  }
  var e_ = ga("animationend"), t_ = ga("animationiteration"), n_ = ga("animationstart"), z4 = ga("transitionrun"), I4 = ga("transitionstart"), C4 = ga("transitioncancel"), r_ = ga("transitionend"), i_ = /* @__PURE__ */ new Map(), Hh = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Hh.push("scrollEnd");
  function pr(a, o) {
    i_.set(a, o), ha(o, [a]);
  }
  var a_ = /* @__PURE__ */ new WeakMap();
  function Qn(a, o) {
    if (typeof a == "object" && a !== null) {
      var u = a_.get(a);
      return u !== void 0 ? u : (o = {
        value: a,
        source: o,
        stack: ww(o)
      }, a_.set(a, o), o);
    }
    return {
      value: a,
      source: o,
      stack: ww(o)
    };
  }
  var er = [], vs = 0, qh = 0;
  function uc() {
    for (var a = vs, o = qh = vs = 0; o < a; ) {
      var u = er[o];
      er[o++] = null;
      var d = er[o];
      er[o++] = null;
      var g = er[o];
      er[o++] = null;
      var v = er[o];
      if (er[o++] = null, d !== null && g !== null) {
        var _ = d.pending;
        _ === null ? g.next = g : (g.next = _.next, _.next = g), d.pending = g;
      }
      v !== 0 && s_(u, g, v);
    }
  }
  function cc(a, o, u, d) {
    er[vs++] = a, er[vs++] = o, er[vs++] = u, er[vs++] = d, qh |= d, a.lanes |= d, a = a.alternate, a !== null && (a.lanes |= d);
  }
  function Gh(a, o, u, d) {
    return cc(a, o, u, d), dc(a);
  }
  function ys(a, o) {
    return cc(a, null, null, o), dc(a);
  }
  function s_(a, o, u) {
    a.lanes |= u;
    var d = a.alternate;
    d !== null && (d.lanes |= u);
    for (var g = !1, v = a.return; v !== null; )
      v.childLanes |= u, d = v.alternate, d !== null && (d.childLanes |= u), v.tag === 22 && (a = v.stateNode, a === null || a._visibility & 1 || (g = !0)), a = v, v = v.return;
    return a.tag === 3 ? (v = a.stateNode, g && o !== null && (g = 31 - $e(u), a = v.hiddenUpdates, d = a[g], d === null ? a[g] = [o] : d.push(o), o.lane = u | 536870912), v) : null;
  }
  function dc(a) {
    if (50 < vl)
      throw vl = 0, Qp = null, Error(i(185));
    for (var o = a.return; o !== null; )
      a = o, o = a.return;
    return a.tag === 3 ? a.stateNode : null;
  }
  var bs = {};
  function O4(a, o, u, d) {
    this.tag = a, this.key = u, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = o, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = d, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Nn(a, o, u, d) {
    return new O4(a, o, u, d);
  }
  function Yh(a) {
    return a = a.prototype, !(!a || !a.isReactComponent);
  }
  function ei(a, o) {
    var u = a.alternate;
    return u === null ? (u = Nn(
      a.tag,
      o,
      a.key,
      a.mode
    ), u.elementType = a.elementType, u.type = a.type, u.stateNode = a.stateNode, u.alternate = a, a.alternate = u) : (u.pendingProps = o, u.type = a.type, u.flags = 0, u.subtreeFlags = 0, u.deletions = null), u.flags = a.flags & 65011712, u.childLanes = a.childLanes, u.lanes = a.lanes, u.child = a.child, u.memoizedProps = a.memoizedProps, u.memoizedState = a.memoizedState, u.updateQueue = a.updateQueue, o = a.dependencies, u.dependencies = o === null ? null : { lanes: o.lanes, firstContext: o.firstContext }, u.sibling = a.sibling, u.index = a.index, u.ref = a.ref, u.refCleanup = a.refCleanup, u;
  }
  function o_(a, o) {
    a.flags &= 65011714;
    var u = a.alternate;
    return u === null ? (a.childLanes = 0, a.lanes = o, a.child = null, a.subtreeFlags = 0, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null) : (a.childLanes = u.childLanes, a.lanes = u.lanes, a.child = u.child, a.subtreeFlags = 0, a.deletions = null, a.memoizedProps = u.memoizedProps, a.memoizedState = u.memoizedState, a.updateQueue = u.updateQueue, a.type = u.type, o = u.dependencies, a.dependencies = o === null ? null : {
      lanes: o.lanes,
      firstContext: o.firstContext
    }), a;
  }
  function fc(a, o, u, d, g, v) {
    var _ = 0;
    if (d = a, typeof a == "function") Yh(a) && (_ = 1);
    else if (typeof a == "string")
      _ = NP(
        a,
        u,
        he.current
      ) ? 26 : a === "html" || a === "head" || a === "body" ? 27 : 5;
    else
      e: switch (a) {
        case re:
          return a = Nn(31, u, o, g), a.elementType = re, a.lanes = v, a;
        case x:
          return va(u.children, g, v, o);
        case w:
          _ = 8, g |= 24;
          break;
        case k:
          return a = Nn(12, u, o, g | 2), a.elementType = k, a.lanes = v, a;
        case M:
          return a = Nn(13, u, o, g), a.elementType = M, a.lanes = v, a;
        case N:
          return a = Nn(19, u, o, g), a.elementType = N, a.lanes = v, a;
        default:
          if (typeof a == "object" && a !== null)
            switch (a.$$typeof) {
              case T:
              case z:
                _ = 10;
                break e;
              case A:
                _ = 9;
                break e;
              case O:
                _ = 11;
                break e;
              case U:
                _ = 14;
                break e;
              case Z:
                _ = 16, d = null;
                break e;
            }
          _ = 29, u = Error(
            i(130, a === null ? "null" : typeof a, "")
          ), d = null;
      }
    return o = Nn(_, u, o, g), o.elementType = a, o.type = d, o.lanes = v, o;
  }
  function va(a, o, u, d) {
    return a = Nn(7, a, d, o), a.lanes = u, a;
  }
  function Jh(a, o, u) {
    return a = Nn(6, a, null, o), a.lanes = u, a;
  }
  function Xh(a, o, u) {
    return o = Nn(
      4,
      a.children !== null ? a.children : [],
      a.key,
      o
    ), o.lanes = u, o.stateNode = {
      containerInfo: a.containerInfo,
      pendingChildren: null,
      implementation: a.implementation
    }, o;
  }
  var xs = [], ws = 0, hc = null, pc = 0, tr = [], nr = 0, ya = null, ti = 1, ni = "";
  function ba(a, o) {
    xs[ws++] = pc, xs[ws++] = hc, hc = a, pc = o;
  }
  function l_(a, o, u) {
    tr[nr++] = ti, tr[nr++] = ni, tr[nr++] = ya, ya = a;
    var d = ti;
    a = ni;
    var g = 32 - $e(d) - 1;
    d &= ~(1 << g), u += 1;
    var v = 32 - $e(o) + g;
    if (30 < v) {
      var _ = g - g % 5;
      v = (d & (1 << _) - 1).toString(32), d >>= _, g -= _, ti = 1 << 32 - $e(o) + g | u << g | d, ni = v + a;
    } else
      ti = 1 << v | u << g | d, ni = a;
  }
  function Kh(a) {
    a.return !== null && (ba(a, 1), l_(a, 1, 0));
  }
  function Wh(a) {
    for (; a === hc; )
      hc = xs[--ws], xs[ws] = null, pc = xs[--ws], xs[ws] = null;
    for (; a === ya; )
      ya = tr[--nr], tr[nr] = null, ni = tr[--nr], tr[nr] = null, ti = tr[--nr], tr[nr] = null;
  }
  var cn = null, Tt = null, Xe = !1, xa = null, Rr = !1, Qh = Error(i(519));
  function wa(a) {
    var o = Error(i(418, ""));
    throw Jo(Qn(o, a)), Qh;
  }
  function u_(a) {
    var o = a.stateNode, u = a.type, d = a.memoizedProps;
    switch (o[nn] = a, o[bn] = d, u) {
      case "dialog":
        Ve("cancel", o), Ve("close", o);
        break;
      case "iframe":
      case "object":
      case "embed":
        Ve("load", o);
        break;
      case "video":
      case "audio":
        for (u = 0; u < bl.length; u++)
          Ve(bl[u], o);
        break;
      case "source":
        Ve("error", o);
        break;
      case "img":
      case "image":
      case "link":
        Ve("error", o), Ve("load", o);
        break;
      case "details":
        Ve("toggle", o);
        break;
      case "input":
        Ve("invalid", o), kw(
          o,
          d.value,
          d.defaultValue,
          d.checked,
          d.defaultChecked,
          d.type,
          d.name,
          !0
        ), ec(o);
        break;
      case "select":
        Ve("invalid", o);
        break;
      case "textarea":
        Ve("invalid", o), Ew(o, d.value, d.defaultValue, d.children), ec(o);
    }
    u = d.children, typeof u != "string" && typeof u != "number" && typeof u != "bigint" || o.textContent === "" + u || d.suppressHydrationWarning === !0 || ES(o.textContent, u) ? (d.popover != null && (Ve("beforetoggle", o), Ve("toggle", o)), d.onScroll != null && Ve("scroll", o), d.onScrollEnd != null && Ve("scrollend", o), d.onClick != null && (o.onclick = Yc), o = !0) : o = !1, o || wa(a);
  }
  function c_(a) {
    for (cn = a.return; cn; )
      switch (cn.tag) {
        case 5:
        case 13:
          Rr = !1;
          return;
        case 27:
        case 3:
          Rr = !0;
          return;
        default:
          cn = cn.return;
      }
  }
  function Go(a) {
    if (a !== cn) return !1;
    if (!Xe) return c_(a), Xe = !0, !1;
    var o = a.tag, u;
    if ((u = o !== 3 && o !== 27) && ((u = o === 5) && (u = a.type, u = !(u !== "form" && u !== "button") || mm(a.type, a.memoizedProps)), u = !u), u && Tt && wa(a), c_(a), o === 13) {
      if (a = a.memoizedState, a = a !== null ? a.dehydrated : null, !a) throw Error(i(317));
      e: {
        for (a = a.nextSibling, o = 0; a; ) {
          if (a.nodeType === 8)
            if (u = a.data, u === "/$") {
              if (o === 0) {
                Tt = gr(a.nextSibling);
                break e;
              }
              o--;
            } else
              u !== "$" && u !== "$!" && u !== "$?" || o++;
          a = a.nextSibling;
        }
        Tt = null;
      }
    } else
      o === 27 ? (o = Tt, Zi(a.type) ? (a = bm, bm = null, Tt = a) : Tt = o) : Tt = cn ? gr(a.stateNode.nextSibling) : null;
    return !0;
  }
  function Yo() {
    Tt = cn = null, Xe = !1;
  }
  function d_() {
    var a = xa;
    return a !== null && (Sn === null ? Sn = a : Sn.push.apply(
      Sn,
      a
    ), xa = null), a;
  }
  function Jo(a) {
    xa === null ? xa = [a] : xa.push(a);
  }
  var ep = X(null), _a = null, ri = null;
  function $i(a, o, u) {
    I(ep, o._currentValue), o._currentValue = u;
  }
  function ii(a) {
    a._currentValue = ep.current, fe(ep);
  }
  function tp(a, o, u) {
    for (; a !== null; ) {
      var d = a.alternate;
      if ((a.childLanes & o) !== o ? (a.childLanes |= o, d !== null && (d.childLanes |= o)) : d !== null && (d.childLanes & o) !== o && (d.childLanes |= o), a === u) break;
      a = a.return;
    }
  }
  function np(a, o, u, d) {
    var g = a.child;
    for (g !== null && (g.return = a); g !== null; ) {
      var v = g.dependencies;
      if (v !== null) {
        var _ = g.child;
        v = v.firstContext;
        e: for (; v !== null; ) {
          var E = v;
          v = g;
          for (var R = 0; R < o.length; R++)
            if (E.context === o[R]) {
              v.lanes |= u, E = v.alternate, E !== null && (E.lanes |= u), tp(
                v.return,
                u,
                a
              ), d || (_ = null);
              break e;
            }
          v = E.next;
        }
      } else if (g.tag === 18) {
        if (_ = g.return, _ === null) throw Error(i(341));
        _.lanes |= u, v = _.alternate, v !== null && (v.lanes |= u), tp(_, u, a), _ = null;
      } else _ = g.child;
      if (_ !== null) _.return = g;
      else
        for (_ = g; _ !== null; ) {
          if (_ === a) {
            _ = null;
            break;
          }
          if (g = _.sibling, g !== null) {
            g.return = _.return, _ = g;
            break;
          }
          _ = _.return;
        }
      g = _;
    }
  }
  function Xo(a, o, u, d) {
    a = null;
    for (var g = o, v = !1; g !== null; ) {
      if (!v) {
        if ((g.flags & 524288) !== 0) v = !0;
        else if ((g.flags & 262144) !== 0) break;
      }
      if (g.tag === 10) {
        var _ = g.alternate;
        if (_ === null) throw Error(i(387));
        if (_ = _.memoizedProps, _ !== null) {
          var E = g.type;
          Rn(g.pendingProps.value, _.value) || (a !== null ? a.push(E) : a = [E]);
        }
      } else if (g === Ce.current) {
        if (_ = g.alternate, _ === null) throw Error(i(387));
        _.memoizedState.memoizedState !== g.memoizedState.memoizedState && (a !== null ? a.push(Tl) : a = [Tl]);
      }
      g = g.return;
    }
    a !== null && np(
      o,
      a,
      u,
      d
    ), o.flags |= 262144;
  }
  function mc(a) {
    for (a = a.firstContext; a !== null; ) {
      if (!Rn(
        a.context._currentValue,
        a.memoizedValue
      ))
        return !0;
      a = a.next;
    }
    return !1;
  }
  function Sa(a) {
    _a = a, ri = null, a = a.dependencies, a !== null && (a.firstContext = null);
  }
  function rn(a) {
    return f_(_a, a);
  }
  function gc(a, o) {
    return _a === null && Sa(a), f_(a, o);
  }
  function f_(a, o) {
    var u = o._currentValue;
    if (o = { context: o, memoizedValue: u, next: null }, ri === null) {
      if (a === null) throw Error(i(308));
      ri = o, a.dependencies = { lanes: 0, firstContext: o }, a.flags |= 524288;
    } else ri = ri.next = o;
    return u;
  }
  var R4 = typeof AbortController < "u" ? AbortController : function() {
    var a = [], o = this.signal = {
      aborted: !1,
      addEventListener: function(u, d) {
        a.push(d);
      }
    };
    this.abort = function() {
      o.aborted = !0, a.forEach(function(u) {
        return u();
      });
    };
  }, N4 = e.unstable_scheduleCallback, M4 = e.unstable_NormalPriority, Pt = {
    $$typeof: z,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function rp() {
    return {
      controller: new R4(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function Ko(a) {
    a.refCount--, a.refCount === 0 && N4(M4, function() {
      a.controller.abort();
    });
  }
  var Wo = null, ip = 0, _s = 0, Ss = null;
  function D4(a, o) {
    if (Wo === null) {
      var u = Wo = [];
      ip = 0, _s = sm(), Ss = {
        status: "pending",
        value: void 0,
        then: function(d) {
          u.push(d);
        }
      };
    }
    return ip++, o.then(h_, h_), o;
  }
  function h_() {
    if (--ip === 0 && Wo !== null) {
      Ss !== null && (Ss.status = "fulfilled");
      var a = Wo;
      Wo = null, _s = 0, Ss = null;
      for (var o = 0; o < a.length; o++) (0, a[o])();
    }
  }
  function j4(a, o) {
    var u = [], d = {
      status: "pending",
      value: null,
      reason: null,
      then: function(g) {
        u.push(g);
      }
    };
    return a.then(
      function() {
        d.status = "fulfilled", d.value = o;
        for (var g = 0; g < u.length; g++) (0, u[g])(o);
      },
      function(g) {
        for (d.status = "rejected", d.reason = g, g = 0; g < u.length; g++)
          (0, u[g])(void 0);
      }
    ), d;
  }
  var p_ = L.S;
  L.S = function(a, o) {
    typeof o == "object" && o !== null && typeof o.then == "function" && D4(a, o), p_ !== null && p_(a, o);
  };
  var ka = X(null);
  function ap() {
    var a = ka.current;
    return a !== null ? a : lt.pooledCache;
  }
  function vc(a, o) {
    o === null ? I(ka, ka.current) : I(ka, o.pool);
  }
  function m_() {
    var a = ap();
    return a === null ? null : { parent: Pt._currentValue, pool: a };
  }
  var Qo = Error(i(460)), g_ = Error(i(474)), yc = Error(i(542)), sp = { then: function() {
  } };
  function v_(a) {
    return a = a.status, a === "fulfilled" || a === "rejected";
  }
  function bc() {
  }
  function y_(a, o, u) {
    switch (u = a[u], u === void 0 ? a.push(o) : u !== o && (o.then(bc, bc), o = u), o.status) {
      case "fulfilled":
        return o.value;
      case "rejected":
        throw a = o.reason, x_(a), a;
      default:
        if (typeof o.status == "string") o.then(bc, bc);
        else {
          if (a = lt, a !== null && 100 < a.shellSuspendCounter)
            throw Error(i(482));
          a = o, a.status = "pending", a.then(
            function(d) {
              if (o.status === "pending") {
                var g = o;
                g.status = "fulfilled", g.value = d;
              }
            },
            function(d) {
              if (o.status === "pending") {
                var g = o;
                g.status = "rejected", g.reason = d;
              }
            }
          );
        }
        switch (o.status) {
          case "fulfilled":
            return o.value;
          case "rejected":
            throw a = o.reason, x_(a), a;
        }
        throw el = o, Qo;
    }
  }
  var el = null;
  function b_() {
    if (el === null) throw Error(i(459));
    var a = el;
    return el = null, a;
  }
  function x_(a) {
    if (a === Qo || a === yc)
      throw Error(i(483));
  }
  var Ai = !1;
  function op(a) {
    a.updateQueue = {
      baseState: a.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function lp(a, o) {
    a = a.updateQueue, o.updateQueue === a && (o.updateQueue = {
      baseState: a.baseState,
      firstBaseUpdate: a.firstBaseUpdate,
      lastBaseUpdate: a.lastBaseUpdate,
      shared: a.shared,
      callbacks: null
    });
  }
  function zi(a) {
    return { lane: a, tag: 0, payload: null, callback: null, next: null };
  }
  function Ii(a, o, u) {
    var d = a.updateQueue;
    if (d === null) return null;
    if (d = d.shared, (et & 2) !== 0) {
      var g = d.pending;
      return g === null ? o.next = o : (o.next = g.next, g.next = o), d.pending = o, o = dc(a), s_(a, null, u), o;
    }
    return cc(a, d, o, u), dc(a);
  }
  function tl(a, o, u) {
    if (o = o.updateQueue, o !== null && (o = o.shared, (u & 4194048) !== 0)) {
      var d = o.lanes;
      d &= a.pendingLanes, u |= d, o.lanes = u, hw(a, u);
    }
  }
  function up(a, o) {
    var u = a.updateQueue, d = a.alternate;
    if (d !== null && (d = d.updateQueue, u === d)) {
      var g = null, v = null;
      if (u = u.firstBaseUpdate, u !== null) {
        do {
          var _ = {
            lane: u.lane,
            tag: u.tag,
            payload: u.payload,
            callback: null,
            next: null
          };
          v === null ? g = v = _ : v = v.next = _, u = u.next;
        } while (u !== null);
        v === null ? g = v = o : v = v.next = o;
      } else g = v = o;
      u = {
        baseState: d.baseState,
        firstBaseUpdate: g,
        lastBaseUpdate: v,
        shared: d.shared,
        callbacks: d.callbacks
      }, a.updateQueue = u;
      return;
    }
    a = u.lastBaseUpdate, a === null ? u.firstBaseUpdate = o : a.next = o, u.lastBaseUpdate = o;
  }
  var cp = !1;
  function nl() {
    if (cp) {
      var a = Ss;
      if (a !== null) throw a;
    }
  }
  function rl(a, o, u, d) {
    cp = !1;
    var g = a.updateQueue;
    Ai = !1;
    var v = g.firstBaseUpdate, _ = g.lastBaseUpdate, E = g.shared.pending;
    if (E !== null) {
      g.shared.pending = null;
      var R = E, F = R.next;
      R.next = null, _ === null ? v = F : _.next = F, _ = R;
      var K = a.alternate;
      K !== null && (K = K.updateQueue, E = K.lastBaseUpdate, E !== _ && (E === null ? K.firstBaseUpdate = F : E.next = F, K.lastBaseUpdate = R));
    }
    if (v !== null) {
      var ee = g.baseState;
      _ = 0, K = F = R = null, E = v;
      do {
        var q = E.lane & -536870913, G = q !== E.lane;
        if (G ? (qe & q) === q : (d & q) === q) {
          q !== 0 && q === _s && (cp = !0), K !== null && (K = K.next = {
            lane: 0,
            tag: E.tag,
            payload: E.payload,
            callback: null,
            next: null
          });
          e: {
            var Ae = a, ke = E;
            q = o;
            var at = u;
            switch (ke.tag) {
              case 1:
                if (Ae = ke.payload, typeof Ae == "function") {
                  ee = Ae.call(at, ee, q);
                  break e;
                }
                ee = Ae;
                break e;
              case 3:
                Ae.flags = Ae.flags & -65537 | 128;
              case 0:
                if (Ae = ke.payload, q = typeof Ae == "function" ? Ae.call(at, ee, q) : Ae, q == null) break e;
                ee = p({}, ee, q);
                break e;
              case 2:
                Ai = !0;
            }
          }
          q = E.callback, q !== null && (a.flags |= 64, G && (a.flags |= 8192), G = g.callbacks, G === null ? g.callbacks = [q] : G.push(q));
        } else
          G = {
            lane: q,
            tag: E.tag,
            payload: E.payload,
            callback: E.callback,
            next: null
          }, K === null ? (F = K = G, R = ee) : K = K.next = G, _ |= q;
        if (E = E.next, E === null) {
          if (E = g.shared.pending, E === null)
            break;
          G = E, E = G.next, G.next = null, g.lastBaseUpdate = G, g.shared.pending = null;
        }
      } while (!0);
      K === null && (R = ee), g.baseState = R, g.firstBaseUpdate = F, g.lastBaseUpdate = K, v === null && (g.shared.lanes = 0), Pi |= _, a.lanes = _, a.memoizedState = ee;
    }
  }
  function w_(a, o) {
    if (typeof a != "function")
      throw Error(i(191, a));
    a.call(o);
  }
  function __(a, o) {
    var u = a.callbacks;
    if (u !== null)
      for (a.callbacks = null, a = 0; a < u.length; a++)
        w_(u[a], o);
  }
  var ks = X(null), xc = X(0);
  function S_(a, o) {
    a = di, I(xc, a), I(ks, o), di = a | o.baseLanes;
  }
  function dp() {
    I(xc, di), I(ks, ks.current);
  }
  function fp() {
    di = xc.current, fe(ks), fe(xc);
  }
  var Ci = 0, Ue = null, rt = null, Rt = null, wc = !1, Ts = !1, Ta = !1, _c = 0, il = 0, Es = null, P4 = 0;
  function zt() {
    throw Error(i(321));
  }
  function hp(a, o) {
    if (o === null) return !1;
    for (var u = 0; u < o.length && u < a.length; u++)
      if (!Rn(a[u], o[u])) return !1;
    return !0;
  }
  function pp(a, o, u, d, g, v) {
    return Ci = v, Ue = o, o.memoizedState = null, o.updateQueue = null, o.lanes = 0, L.H = a === null || a.memoizedState === null ? s0 : o0, Ta = !1, v = u(d, g), Ta = !1, Ts && (v = T_(
      o,
      u,
      d,
      g
    )), k_(a), v;
  }
  function k_(a) {
    L.H = Ac;
    var o = rt !== null && rt.next !== null;
    if (Ci = 0, Rt = rt = Ue = null, wc = !1, il = 0, Es = null, o) throw Error(i(300));
    a === null || Gt || (a = a.dependencies, a !== null && mc(a) && (Gt = !0));
  }
  function T_(a, o, u, d) {
    Ue = a;
    var g = 0;
    do {
      if (Ts && (Es = null), il = 0, Ts = !1, 25 <= g) throw Error(i(301));
      if (g += 1, Rt = rt = null, a.updateQueue != null) {
        var v = a.updateQueue;
        v.lastEffect = null, v.events = null, v.stores = null, v.memoCache != null && (v.memoCache.index = 0);
      }
      L.H = H4, v = o(u, d);
    } while (Ts);
    return v;
  }
  function U4() {
    var a = L.H, o = a.useState()[0];
    return o = typeof o.then == "function" ? al(o) : o, a = a.useState()[0], (rt !== null ? rt.memoizedState : null) !== a && (Ue.flags |= 1024), o;
  }
  function mp() {
    var a = _c !== 0;
    return _c = 0, a;
  }
  function gp(a, o, u) {
    o.updateQueue = a.updateQueue, o.flags &= -2053, a.lanes &= ~u;
  }
  function vp(a) {
    if (wc) {
      for (a = a.memoizedState; a !== null; ) {
        var o = a.queue;
        o !== null && (o.pending = null), a = a.next;
      }
      wc = !1;
    }
    Ci = 0, Rt = rt = Ue = null, Ts = !1, il = _c = 0, Es = null;
  }
  function wn() {
    var a = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return Rt === null ? Ue.memoizedState = Rt = a : Rt = Rt.next = a, Rt;
  }
  function Nt() {
    if (rt === null) {
      var a = Ue.alternate;
      a = a !== null ? a.memoizedState : null;
    } else a = rt.next;
    var o = Rt === null ? Ue.memoizedState : Rt.next;
    if (o !== null)
      Rt = o, rt = a;
    else {
      if (a === null)
        throw Ue.alternate === null ? Error(i(467)) : Error(i(310));
      rt = a, a = {
        memoizedState: rt.memoizedState,
        baseState: rt.baseState,
        baseQueue: rt.baseQueue,
        queue: rt.queue,
        next: null
      }, Rt === null ? Ue.memoizedState = Rt = a : Rt = Rt.next = a;
    }
    return Rt;
  }
  function yp() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function al(a) {
    var o = il;
    return il += 1, Es === null && (Es = []), a = y_(Es, a, o), o = Ue, (Rt === null ? o.memoizedState : Rt.next) === null && (o = o.alternate, L.H = o === null || o.memoizedState === null ? s0 : o0), a;
  }
  function Sc(a) {
    if (a !== null && typeof a == "object") {
      if (typeof a.then == "function") return al(a);
      if (a.$$typeof === z) return rn(a);
    }
    throw Error(i(438, String(a)));
  }
  function bp(a) {
    var o = null, u = Ue.updateQueue;
    if (u !== null && (o = u.memoCache), o == null) {
      var d = Ue.alternate;
      d !== null && (d = d.updateQueue, d !== null && (d = d.memoCache, d != null && (o = {
        data: d.data.map(function(g) {
          return g.slice();
        }),
        index: 0
      })));
    }
    if (o == null && (o = { data: [], index: 0 }), u === null && (u = yp(), Ue.updateQueue = u), u.memoCache = o, u = o.data[o.index], u === void 0)
      for (u = o.data[o.index] = Array(a), d = 0; d < a; d++)
        u[d] = D;
    return o.index++, u;
  }
  function ai(a, o) {
    return typeof o == "function" ? o(a) : o;
  }
  function kc(a) {
    var o = Nt();
    return xp(o, rt, a);
  }
  function xp(a, o, u) {
    var d = a.queue;
    if (d === null) throw Error(i(311));
    d.lastRenderedReducer = u;
    var g = a.baseQueue, v = d.pending;
    if (v !== null) {
      if (g !== null) {
        var _ = g.next;
        g.next = v.next, v.next = _;
      }
      o.baseQueue = g = v, d.pending = null;
    }
    if (v = a.baseState, g === null) a.memoizedState = v;
    else {
      o = g.next;
      var E = _ = null, R = null, F = o, K = !1;
      do {
        var ee = F.lane & -536870913;
        if (ee !== F.lane ? (qe & ee) === ee : (Ci & ee) === ee) {
          var q = F.revertLane;
          if (q === 0)
            R !== null && (R = R.next = {
              lane: 0,
              revertLane: 0,
              action: F.action,
              hasEagerState: F.hasEagerState,
              eagerState: F.eagerState,
              next: null
            }), ee === _s && (K = !0);
          else if ((Ci & q) === q) {
            F = F.next, q === _s && (K = !0);
            continue;
          } else
            ee = {
              lane: 0,
              revertLane: F.revertLane,
              action: F.action,
              hasEagerState: F.hasEagerState,
              eagerState: F.eagerState,
              next: null
            }, R === null ? (E = R = ee, _ = v) : R = R.next = ee, Ue.lanes |= q, Pi |= q;
          ee = F.action, Ta && u(v, ee), v = F.hasEagerState ? F.eagerState : u(v, ee);
        } else
          q = {
            lane: ee,
            revertLane: F.revertLane,
            action: F.action,
            hasEagerState: F.hasEagerState,
            eagerState: F.eagerState,
            next: null
          }, R === null ? (E = R = q, _ = v) : R = R.next = q, Ue.lanes |= ee, Pi |= ee;
        F = F.next;
      } while (F !== null && F !== o);
      if (R === null ? _ = v : R.next = E, !Rn(v, a.memoizedState) && (Gt = !0, K && (u = Ss, u !== null)))
        throw u;
      a.memoizedState = v, a.baseState = _, a.baseQueue = R, d.lastRenderedState = v;
    }
    return g === null && (d.lanes = 0), [a.memoizedState, d.dispatch];
  }
  function wp(a) {
    var o = Nt(), u = o.queue;
    if (u === null) throw Error(i(311));
    u.lastRenderedReducer = a;
    var d = u.dispatch, g = u.pending, v = o.memoizedState;
    if (g !== null) {
      u.pending = null;
      var _ = g = g.next;
      do
        v = a(v, _.action), _ = _.next;
      while (_ !== g);
      Rn(v, o.memoizedState) || (Gt = !0), o.memoizedState = v, o.baseQueue === null && (o.baseState = v), u.lastRenderedState = v;
    }
    return [v, d];
  }
  function E_(a, o, u) {
    var d = Ue, g = Nt(), v = Xe;
    if (v) {
      if (u === void 0) throw Error(i(407));
      u = u();
    } else u = o();
    var _ = !Rn(
      (rt || g).memoizedState,
      u
    );
    _ && (g.memoizedState = u, Gt = !0), g = g.queue;
    var E = z_.bind(null, d, g, a);
    if (sl(2048, 8, E, [a]), g.getSnapshot !== o || _ || Rt !== null && Rt.memoizedState.tag & 1) {
      if (d.flags |= 2048, $s(
        9,
        Tc(),
        A_.bind(
          null,
          d,
          g,
          u,
          o
        ),
        null
      ), lt === null) throw Error(i(349));
      v || (Ci & 124) !== 0 || $_(d, o, u);
    }
    return u;
  }
  function $_(a, o, u) {
    a.flags |= 16384, a = { getSnapshot: o, value: u }, o = Ue.updateQueue, o === null ? (o = yp(), Ue.updateQueue = o, o.stores = [a]) : (u = o.stores, u === null ? o.stores = [a] : u.push(a));
  }
  function A_(a, o, u, d) {
    o.value = u, o.getSnapshot = d, I_(o) && C_(a);
  }
  function z_(a, o, u) {
    return u(function() {
      I_(o) && C_(a);
    });
  }
  function I_(a) {
    var o = a.getSnapshot;
    a = a.value;
    try {
      var u = o();
      return !Rn(a, u);
    } catch {
      return !0;
    }
  }
  function C_(a) {
    var o = ys(a, 2);
    o !== null && Un(o, a, 2);
  }
  function _p(a) {
    var o = wn();
    if (typeof a == "function") {
      var u = a;
      if (a = u(), Ta) {
        _e(!0);
        try {
          u();
        } finally {
          _e(!1);
        }
      }
    }
    return o.memoizedState = o.baseState = a, o.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: ai,
      lastRenderedState: a
    }, o;
  }
  function O_(a, o, u, d) {
    return a.baseState = u, xp(
      a,
      rt,
      typeof d == "function" ? d : ai
    );
  }
  function L4(a, o, u, d, g) {
    if ($c(a)) throw Error(i(485));
    if (a = o.action, a !== null) {
      var v = {
        payload: g,
        action: a,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(_) {
          v.listeners.push(_);
        }
      };
      L.T !== null ? u(!0) : v.isTransition = !1, d(v), u = o.pending, u === null ? (v.next = o.pending = v, R_(o, v)) : (v.next = u.next, o.pending = u.next = v);
    }
  }
  function R_(a, o) {
    var u = o.action, d = o.payload, g = a.state;
    if (o.isTransition) {
      var v = L.T, _ = {};
      L.T = _;
      try {
        var E = u(g, d), R = L.S;
        R !== null && R(_, E), N_(a, o, E);
      } catch (F) {
        Sp(a, o, F);
      } finally {
        L.T = v;
      }
    } else
      try {
        v = u(g, d), N_(a, o, v);
      } catch (F) {
        Sp(a, o, F);
      }
  }
  function N_(a, o, u) {
    u !== null && typeof u == "object" && typeof u.then == "function" ? u.then(
      function(d) {
        M_(a, o, d);
      },
      function(d) {
        return Sp(a, o, d);
      }
    ) : M_(a, o, u);
  }
  function M_(a, o, u) {
    o.status = "fulfilled", o.value = u, D_(o), a.state = u, o = a.pending, o !== null && (u = o.next, u === o ? a.pending = null : (u = u.next, o.next = u, R_(a, u)));
  }
  function Sp(a, o, u) {
    var d = a.pending;
    if (a.pending = null, d !== null) {
      d = d.next;
      do
        o.status = "rejected", o.reason = u, D_(o), o = o.next;
      while (o !== d);
    }
    a.action = null;
  }
  function D_(a) {
    a = a.listeners;
    for (var o = 0; o < a.length; o++) (0, a[o])();
  }
  function j_(a, o) {
    return o;
  }
  function P_(a, o) {
    if (Xe) {
      var u = lt.formState;
      if (u !== null) {
        e: {
          var d = Ue;
          if (Xe) {
            if (Tt) {
              t: {
                for (var g = Tt, v = Rr; g.nodeType !== 8; ) {
                  if (!v) {
                    g = null;
                    break t;
                  }
                  if (g = gr(
                    g.nextSibling
                  ), g === null) {
                    g = null;
                    break t;
                  }
                }
                v = g.data, g = v === "F!" || v === "F" ? g : null;
              }
              if (g) {
                Tt = gr(
                  g.nextSibling
                ), d = g.data === "F!";
                break e;
              }
            }
            wa(d);
          }
          d = !1;
        }
        d && (o = u[0]);
      }
    }
    return u = wn(), u.memoizedState = u.baseState = o, d = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: j_,
      lastRenderedState: o
    }, u.queue = d, u = r0.bind(
      null,
      Ue,
      d
    ), d.dispatch = u, d = _p(!1), v = Ap.bind(
      null,
      Ue,
      !1,
      d.queue
    ), d = wn(), g = {
      state: o,
      dispatch: null,
      action: a,
      pending: null
    }, d.queue = g, u = L4.bind(
      null,
      Ue,
      g,
      v,
      u
    ), g.dispatch = u, d.memoizedState = a, [o, u, !1];
  }
  function U_(a) {
    var o = Nt();
    return L_(o, rt, a);
  }
  function L_(a, o, u) {
    if (o = xp(
      a,
      o,
      j_
    )[0], a = kc(ai)[0], typeof o == "object" && o !== null && typeof o.then == "function")
      try {
        var d = al(o);
      } catch (_) {
        throw _ === Qo ? yc : _;
      }
    else d = o;
    o = Nt();
    var g = o.queue, v = g.dispatch;
    return u !== o.memoizedState && (Ue.flags |= 2048, $s(
      9,
      Tc(),
      B4.bind(null, g, u),
      null
    )), [d, v, a];
  }
  function B4(a, o) {
    a.action = o;
  }
  function B_(a) {
    var o = Nt(), u = rt;
    if (u !== null)
      return L_(o, u, a);
    Nt(), o = o.memoizedState, u = Nt();
    var d = u.queue.dispatch;
    return u.memoizedState = a, [o, d, !1];
  }
  function $s(a, o, u, d) {
    return a = { tag: a, create: u, deps: d, inst: o, next: null }, o = Ue.updateQueue, o === null && (o = yp(), Ue.updateQueue = o), u = o.lastEffect, u === null ? o.lastEffect = a.next = a : (d = u.next, u.next = a, a.next = d, o.lastEffect = a), a;
  }
  function Tc() {
    return { destroy: void 0, resource: void 0 };
  }
  function Z_() {
    return Nt().memoizedState;
  }
  function Ec(a, o, u, d) {
    var g = wn();
    d = d === void 0 ? null : d, Ue.flags |= a, g.memoizedState = $s(
      1 | o,
      Tc(),
      u,
      d
    );
  }
  function sl(a, o, u, d) {
    var g = Nt();
    d = d === void 0 ? null : d;
    var v = g.memoizedState.inst;
    rt !== null && d !== null && hp(d, rt.memoizedState.deps) ? g.memoizedState = $s(o, v, u, d) : (Ue.flags |= a, g.memoizedState = $s(
      1 | o,
      v,
      u,
      d
    ));
  }
  function V_(a, o) {
    Ec(8390656, 8, a, o);
  }
  function F_(a, o) {
    sl(2048, 8, a, o);
  }
  function H_(a, o) {
    return sl(4, 2, a, o);
  }
  function q_(a, o) {
    return sl(4, 4, a, o);
  }
  function G_(a, o) {
    if (typeof o == "function") {
      a = a();
      var u = o(a);
      return function() {
        typeof u == "function" ? u() : o(null);
      };
    }
    if (o != null)
      return a = a(), o.current = a, function() {
        o.current = null;
      };
  }
  function Y_(a, o, u) {
    u = u != null ? u.concat([a]) : null, sl(4, 4, G_.bind(null, o, a), u);
  }
  function kp() {
  }
  function J_(a, o) {
    var u = Nt();
    o = o === void 0 ? null : o;
    var d = u.memoizedState;
    return o !== null && hp(o, d[1]) ? d[0] : (u.memoizedState = [a, o], a);
  }
  function X_(a, o) {
    var u = Nt();
    o = o === void 0 ? null : o;
    var d = u.memoizedState;
    if (o !== null && hp(o, d[1]))
      return d[0];
    if (d = a(), Ta) {
      _e(!0);
      try {
        a();
      } finally {
        _e(!1);
      }
    }
    return u.memoizedState = [d, o], d;
  }
  function Tp(a, o, u) {
    return u === void 0 || (Ci & 1073741824) !== 0 ? a.memoizedState = o : (a.memoizedState = u, a = Q0(), Ue.lanes |= a, Pi |= a, u);
  }
  function K_(a, o, u, d) {
    return Rn(u, o) ? u : ks.current !== null ? (a = Tp(a, u, d), Rn(a, o) || (Gt = !0), a) : (Ci & 42) === 0 ? (Gt = !0, a.memoizedState = u) : (a = Q0(), Ue.lanes |= a, Pi |= a, o);
  }
  function W_(a, o, u, d, g) {
    var v = Y.p;
    Y.p = v !== 0 && 8 > v ? v : 8;
    var _ = L.T, E = {};
    L.T = E, Ap(a, !1, o, u);
    try {
      var R = g(), F = L.S;
      if (F !== null && F(E, R), R !== null && typeof R == "object" && typeof R.then == "function") {
        var K = j4(
          R,
          d
        );
        ol(
          a,
          o,
          K,
          Pn(a)
        );
      } else
        ol(
          a,
          o,
          d,
          Pn(a)
        );
    } catch (ee) {
      ol(
        a,
        o,
        { then: function() {
        }, status: "rejected", reason: ee },
        Pn()
      );
    } finally {
      Y.p = v, L.T = _;
    }
  }
  function Z4() {
  }
  function Ep(a, o, u, d) {
    if (a.tag !== 5) throw Error(i(476));
    var g = Q_(a).queue;
    W_(
      a,
      g,
      o,
      H,
      u === null ? Z4 : function() {
        return e0(a), u(d);
      }
    );
  }
  function Q_(a) {
    var o = a.memoizedState;
    if (o !== null) return o;
    o = {
      memoizedState: H,
      baseState: H,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ai,
        lastRenderedState: H
      },
      next: null
    };
    var u = {};
    return o.next = {
      memoizedState: u,
      baseState: u,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ai,
        lastRenderedState: u
      },
      next: null
    }, a.memoizedState = o, a = a.alternate, a !== null && (a.memoizedState = o), o;
  }
  function e0(a) {
    var o = Q_(a).next.queue;
    ol(a, o, {}, Pn());
  }
  function $p() {
    return rn(Tl);
  }
  function t0() {
    return Nt().memoizedState;
  }
  function n0() {
    return Nt().memoizedState;
  }
  function V4(a) {
    for (var o = a.return; o !== null; ) {
      switch (o.tag) {
        case 24:
        case 3:
          var u = Pn();
          a = zi(u);
          var d = Ii(o, a, u);
          d !== null && (Un(d, o, u), tl(d, o, u)), o = { cache: rp() }, a.payload = o;
          return;
      }
      o = o.return;
    }
  }
  function F4(a, o, u) {
    var d = Pn();
    u = {
      lane: d,
      revertLane: 0,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, $c(a) ? i0(o, u) : (u = Gh(a, o, u, d), u !== null && (Un(u, a, d), a0(u, o, d)));
  }
  function r0(a, o, u) {
    var d = Pn();
    ol(a, o, u, d);
  }
  function ol(a, o, u, d) {
    var g = {
      lane: d,
      revertLane: 0,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if ($c(a)) i0(o, g);
    else {
      var v = a.alternate;
      if (a.lanes === 0 && (v === null || v.lanes === 0) && (v = o.lastRenderedReducer, v !== null))
        try {
          var _ = o.lastRenderedState, E = v(_, u);
          if (g.hasEagerState = !0, g.eagerState = E, Rn(E, _))
            return cc(a, o, g, 0), lt === null && uc(), !1;
        } catch {
        } finally {
        }
      if (u = Gh(a, o, g, d), u !== null)
        return Un(u, a, d), a0(u, o, d), !0;
    }
    return !1;
  }
  function Ap(a, o, u, d) {
    if (d = {
      lane: 2,
      revertLane: sm(),
      action: d,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, $c(a)) {
      if (o) throw Error(i(479));
    } else
      o = Gh(
        a,
        u,
        d,
        2
      ), o !== null && Un(o, a, 2);
  }
  function $c(a) {
    var o = a.alternate;
    return a === Ue || o !== null && o === Ue;
  }
  function i0(a, o) {
    Ts = wc = !0;
    var u = a.pending;
    u === null ? o.next = o : (o.next = u.next, u.next = o), a.pending = o;
  }
  function a0(a, o, u) {
    if ((u & 4194048) !== 0) {
      var d = o.lanes;
      d &= a.pendingLanes, u |= d, o.lanes = u, hw(a, u);
    }
  }
  var Ac = {
    readContext: rn,
    use: Sc,
    useCallback: zt,
    useContext: zt,
    useEffect: zt,
    useImperativeHandle: zt,
    useLayoutEffect: zt,
    useInsertionEffect: zt,
    useMemo: zt,
    useReducer: zt,
    useRef: zt,
    useState: zt,
    useDebugValue: zt,
    useDeferredValue: zt,
    useTransition: zt,
    useSyncExternalStore: zt,
    useId: zt,
    useHostTransitionStatus: zt,
    useFormState: zt,
    useActionState: zt,
    useOptimistic: zt,
    useMemoCache: zt,
    useCacheRefresh: zt
  }, s0 = {
    readContext: rn,
    use: Sc,
    useCallback: function(a, o) {
      return wn().memoizedState = [
        a,
        o === void 0 ? null : o
      ], a;
    },
    useContext: rn,
    useEffect: V_,
    useImperativeHandle: function(a, o, u) {
      u = u != null ? u.concat([a]) : null, Ec(
        4194308,
        4,
        G_.bind(null, o, a),
        u
      );
    },
    useLayoutEffect: function(a, o) {
      return Ec(4194308, 4, a, o);
    },
    useInsertionEffect: function(a, o) {
      Ec(4, 2, a, o);
    },
    useMemo: function(a, o) {
      var u = wn();
      o = o === void 0 ? null : o;
      var d = a();
      if (Ta) {
        _e(!0);
        try {
          a();
        } finally {
          _e(!1);
        }
      }
      return u.memoizedState = [d, o], d;
    },
    useReducer: function(a, o, u) {
      var d = wn();
      if (u !== void 0) {
        var g = u(o);
        if (Ta) {
          _e(!0);
          try {
            u(o);
          } finally {
            _e(!1);
          }
        }
      } else g = o;
      return d.memoizedState = d.baseState = g, a = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: g
      }, d.queue = a, a = a.dispatch = F4.bind(
        null,
        Ue,
        a
      ), [d.memoizedState, a];
    },
    useRef: function(a) {
      var o = wn();
      return a = { current: a }, o.memoizedState = a;
    },
    useState: function(a) {
      a = _p(a);
      var o = a.queue, u = r0.bind(null, Ue, o);
      return o.dispatch = u, [a.memoizedState, u];
    },
    useDebugValue: kp,
    useDeferredValue: function(a, o) {
      var u = wn();
      return Tp(u, a, o);
    },
    useTransition: function() {
      var a = _p(!1);
      return a = W_.bind(
        null,
        Ue,
        a.queue,
        !0,
        !1
      ), wn().memoizedState = a, [!1, a];
    },
    useSyncExternalStore: function(a, o, u) {
      var d = Ue, g = wn();
      if (Xe) {
        if (u === void 0)
          throw Error(i(407));
        u = u();
      } else {
        if (u = o(), lt === null)
          throw Error(i(349));
        (qe & 124) !== 0 || $_(d, o, u);
      }
      g.memoizedState = u;
      var v = { value: u, getSnapshot: o };
      return g.queue = v, V_(z_.bind(null, d, v, a), [
        a
      ]), d.flags |= 2048, $s(
        9,
        Tc(),
        A_.bind(
          null,
          d,
          v,
          u,
          o
        ),
        null
      ), u;
    },
    useId: function() {
      var a = wn(), o = lt.identifierPrefix;
      if (Xe) {
        var u = ni, d = ti;
        u = (d & ~(1 << 32 - $e(d) - 1)).toString(32) + u, o = "" + o + "R" + u, u = _c++, 0 < u && (o += "H" + u.toString(32)), o += "";
      } else
        u = P4++, o = "" + o + "r" + u.toString(32) + "";
      return a.memoizedState = o;
    },
    useHostTransitionStatus: $p,
    useFormState: P_,
    useActionState: P_,
    useOptimistic: function(a) {
      var o = wn();
      o.memoizedState = o.baseState = a;
      var u = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return o.queue = u, o = Ap.bind(
        null,
        Ue,
        !0,
        u
      ), u.dispatch = o, [a, o];
    },
    useMemoCache: bp,
    useCacheRefresh: function() {
      return wn().memoizedState = V4.bind(
        null,
        Ue
      );
    }
  }, o0 = {
    readContext: rn,
    use: Sc,
    useCallback: J_,
    useContext: rn,
    useEffect: F_,
    useImperativeHandle: Y_,
    useInsertionEffect: H_,
    useLayoutEffect: q_,
    useMemo: X_,
    useReducer: kc,
    useRef: Z_,
    useState: function() {
      return kc(ai);
    },
    useDebugValue: kp,
    useDeferredValue: function(a, o) {
      var u = Nt();
      return K_(
        u,
        rt.memoizedState,
        a,
        o
      );
    },
    useTransition: function() {
      var a = kc(ai)[0], o = Nt().memoizedState;
      return [
        typeof a == "boolean" ? a : al(a),
        o
      ];
    },
    useSyncExternalStore: E_,
    useId: t0,
    useHostTransitionStatus: $p,
    useFormState: U_,
    useActionState: U_,
    useOptimistic: function(a, o) {
      var u = Nt();
      return O_(u, rt, a, o);
    },
    useMemoCache: bp,
    useCacheRefresh: n0
  }, H4 = {
    readContext: rn,
    use: Sc,
    useCallback: J_,
    useContext: rn,
    useEffect: F_,
    useImperativeHandle: Y_,
    useInsertionEffect: H_,
    useLayoutEffect: q_,
    useMemo: X_,
    useReducer: wp,
    useRef: Z_,
    useState: function() {
      return wp(ai);
    },
    useDebugValue: kp,
    useDeferredValue: function(a, o) {
      var u = Nt();
      return rt === null ? Tp(u, a, o) : K_(
        u,
        rt.memoizedState,
        a,
        o
      );
    },
    useTransition: function() {
      var a = wp(ai)[0], o = Nt().memoizedState;
      return [
        typeof a == "boolean" ? a : al(a),
        o
      ];
    },
    useSyncExternalStore: E_,
    useId: t0,
    useHostTransitionStatus: $p,
    useFormState: B_,
    useActionState: B_,
    useOptimistic: function(a, o) {
      var u = Nt();
      return rt !== null ? O_(u, rt, a, o) : (u.baseState = a, [a, u.queue.dispatch]);
    },
    useMemoCache: bp,
    useCacheRefresh: n0
  }, As = null, ll = 0;
  function zc(a) {
    var o = ll;
    return ll += 1, As === null && (As = []), y_(As, a, o);
  }
  function ul(a, o) {
    o = o.props.ref, a.ref = o !== void 0 ? o : null;
  }
  function Ic(a, o) {
    throw o.$$typeof === m ? Error(i(525)) : (a = Object.prototype.toString.call(o), Error(
      i(
        31,
        a === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : a
      )
    ));
  }
  function l0(a) {
    var o = a._init;
    return o(a._payload);
  }
  function u0(a) {
    function o(P, j) {
      if (a) {
        var V = P.deletions;
        V === null ? (P.deletions = [j], P.flags |= 16) : V.push(j);
      }
    }
    function u(P, j) {
      if (!a) return null;
      for (; j !== null; )
        o(P, j), j = j.sibling;
      return null;
    }
    function d(P) {
      for (var j = /* @__PURE__ */ new Map(); P !== null; )
        P.key !== null ? j.set(P.key, P) : j.set(P.index, P), P = P.sibling;
      return j;
    }
    function g(P, j) {
      return P = ei(P, j), P.index = 0, P.sibling = null, P;
    }
    function v(P, j, V) {
      return P.index = V, a ? (V = P.alternate, V !== null ? (V = V.index, V < j ? (P.flags |= 67108866, j) : V) : (P.flags |= 67108866, j)) : (P.flags |= 1048576, j);
    }
    function _(P) {
      return a && P.alternate === null && (P.flags |= 67108866), P;
    }
    function E(P, j, V, Q) {
      return j === null || j.tag !== 6 ? (j = Jh(V, P.mode, Q), j.return = P, j) : (j = g(j, V), j.return = P, j);
    }
    function R(P, j, V, Q) {
      var ve = V.type;
      return ve === x ? K(
        P,
        j,
        V.props.children,
        Q,
        V.key
      ) : j !== null && (j.elementType === ve || typeof ve == "object" && ve !== null && ve.$$typeof === Z && l0(ve) === j.type) ? (j = g(j, V.props), ul(j, V), j.return = P, j) : (j = fc(
        V.type,
        V.key,
        V.props,
        null,
        P.mode,
        Q
      ), ul(j, V), j.return = P, j);
    }
    function F(P, j, V, Q) {
      return j === null || j.tag !== 4 || j.stateNode.containerInfo !== V.containerInfo || j.stateNode.implementation !== V.implementation ? (j = Xh(V, P.mode, Q), j.return = P, j) : (j = g(j, V.children || []), j.return = P, j);
    }
    function K(P, j, V, Q, ve) {
      return j === null || j.tag !== 7 ? (j = va(
        V,
        P.mode,
        Q,
        ve
      ), j.return = P, j) : (j = g(j, V), j.return = P, j);
    }
    function ee(P, j, V) {
      if (typeof j == "string" && j !== "" || typeof j == "number" || typeof j == "bigint")
        return j = Jh(
          "" + j,
          P.mode,
          V
        ), j.return = P, j;
      if (typeof j == "object" && j !== null) {
        switch (j.$$typeof) {
          case y:
            return V = fc(
              j.type,
              j.key,
              j.props,
              null,
              P.mode,
              V
            ), ul(V, j), V.return = P, V;
          case b:
            return j = Xh(
              j,
              P.mode,
              V
            ), j.return = P, j;
          case Z:
            var Q = j._init;
            return j = Q(j._payload), ee(P, j, V);
        }
        if (ce(j) || ie(j))
          return j = va(
            j,
            P.mode,
            V,
            null
          ), j.return = P, j;
        if (typeof j.then == "function")
          return ee(P, zc(j), V);
        if (j.$$typeof === z)
          return ee(
            P,
            gc(P, j),
            V
          );
        Ic(P, j);
      }
      return null;
    }
    function q(P, j, V, Q) {
      var ve = j !== null ? j.key : null;
      if (typeof V == "string" && V !== "" || typeof V == "number" || typeof V == "bigint")
        return ve !== null ? null : E(P, j, "" + V, Q);
      if (typeof V == "object" && V !== null) {
        switch (V.$$typeof) {
          case y:
            return V.key === ve ? R(P, j, V, Q) : null;
          case b:
            return V.key === ve ? F(P, j, V, Q) : null;
          case Z:
            return ve = V._init, V = ve(V._payload), q(P, j, V, Q);
        }
        if (ce(V) || ie(V))
          return ve !== null ? null : K(P, j, V, Q, null);
        if (typeof V.then == "function")
          return q(
            P,
            j,
            zc(V),
            Q
          );
        if (V.$$typeof === z)
          return q(
            P,
            j,
            gc(P, V),
            Q
          );
        Ic(P, V);
      }
      return null;
    }
    function G(P, j, V, Q, ve) {
      if (typeof Q == "string" && Q !== "" || typeof Q == "number" || typeof Q == "bigint")
        return P = P.get(V) || null, E(j, P, "" + Q, ve);
      if (typeof Q == "object" && Q !== null) {
        switch (Q.$$typeof) {
          case y:
            return P = P.get(
              Q.key === null ? V : Q.key
            ) || null, R(j, P, Q, ve);
          case b:
            return P = P.get(
              Q.key === null ? V : Q.key
            ) || null, F(j, P, Q, ve);
          case Z:
            var Be = Q._init;
            return Q = Be(Q._payload), G(
              P,
              j,
              V,
              Q,
              ve
            );
        }
        if (ce(Q) || ie(Q))
          return P = P.get(V) || null, K(j, P, Q, ve, null);
        if (typeof Q.then == "function")
          return G(
            P,
            j,
            V,
            zc(Q),
            ve
          );
        if (Q.$$typeof === z)
          return G(
            P,
            j,
            V,
            gc(j, Q),
            ve
          );
        Ic(j, Q);
      }
      return null;
    }
    function Ae(P, j, V, Q) {
      for (var ve = null, Be = null, we = j, Te = j = 0, Jt = null; we !== null && Te < V.length; Te++) {
        we.index > Te ? (Jt = we, we = null) : Jt = we.sibling;
        var Je = q(
          P,
          we,
          V[Te],
          Q
        );
        if (Je === null) {
          we === null && (we = Jt);
          break;
        }
        a && we && Je.alternate === null && o(P, we), j = v(Je, j, Te), Be === null ? ve = Je : Be.sibling = Je, Be = Je, we = Jt;
      }
      if (Te === V.length)
        return u(P, we), Xe && ba(P, Te), ve;
      if (we === null) {
        for (; Te < V.length; Te++)
          we = ee(P, V[Te], Q), we !== null && (j = v(
            we,
            j,
            Te
          ), Be === null ? ve = we : Be.sibling = we, Be = we);
        return Xe && ba(P, Te), ve;
      }
      for (we = d(we); Te < V.length; Te++)
        Jt = G(
          we,
          P,
          Te,
          V[Te],
          Q
        ), Jt !== null && (a && Jt.alternate !== null && we.delete(
          Jt.key === null ? Te : Jt.key
        ), j = v(
          Jt,
          j,
          Te
        ), Be === null ? ve = Jt : Be.sibling = Jt, Be = Jt);
      return a && we.forEach(function(Gi) {
        return o(P, Gi);
      }), Xe && ba(P, Te), ve;
    }
    function ke(P, j, V, Q) {
      if (V == null) throw Error(i(151));
      for (var ve = null, Be = null, we = j, Te = j = 0, Jt = null, Je = V.next(); we !== null && !Je.done; Te++, Je = V.next()) {
        we.index > Te ? (Jt = we, we = null) : Jt = we.sibling;
        var Gi = q(P, we, Je.value, Q);
        if (Gi === null) {
          we === null && (we = Jt);
          break;
        }
        a && we && Gi.alternate === null && o(P, we), j = v(Gi, j, Te), Be === null ? ve = Gi : Be.sibling = Gi, Be = Gi, we = Jt;
      }
      if (Je.done)
        return u(P, we), Xe && ba(P, Te), ve;
      if (we === null) {
        for (; !Je.done; Te++, Je = V.next())
          Je = ee(P, Je.value, Q), Je !== null && (j = v(Je, j, Te), Be === null ? ve = Je : Be.sibling = Je, Be = Je);
        return Xe && ba(P, Te), ve;
      }
      for (we = d(we); !Je.done; Te++, Je = V.next())
        Je = G(we, P, Te, Je.value, Q), Je !== null && (a && Je.alternate !== null && we.delete(Je.key === null ? Te : Je.key), j = v(Je, j, Te), Be === null ? ve = Je : Be.sibling = Je, Be = Je);
      return a && we.forEach(function(qP) {
        return o(P, qP);
      }), Xe && ba(P, Te), ve;
    }
    function at(P, j, V, Q) {
      if (typeof V == "object" && V !== null && V.type === x && V.key === null && (V = V.props.children), typeof V == "object" && V !== null) {
        switch (V.$$typeof) {
          case y:
            e: {
              for (var ve = V.key; j !== null; ) {
                if (j.key === ve) {
                  if (ve = V.type, ve === x) {
                    if (j.tag === 7) {
                      u(
                        P,
                        j.sibling
                      ), Q = g(
                        j,
                        V.props.children
                      ), Q.return = P, P = Q;
                      break e;
                    }
                  } else if (j.elementType === ve || typeof ve == "object" && ve !== null && ve.$$typeof === Z && l0(ve) === j.type) {
                    u(
                      P,
                      j.sibling
                    ), Q = g(j, V.props), ul(Q, V), Q.return = P, P = Q;
                    break e;
                  }
                  u(P, j);
                  break;
                } else o(P, j);
                j = j.sibling;
              }
              V.type === x ? (Q = va(
                V.props.children,
                P.mode,
                Q,
                V.key
              ), Q.return = P, P = Q) : (Q = fc(
                V.type,
                V.key,
                V.props,
                null,
                P.mode,
                Q
              ), ul(Q, V), Q.return = P, P = Q);
            }
            return _(P);
          case b:
            e: {
              for (ve = V.key; j !== null; ) {
                if (j.key === ve)
                  if (j.tag === 4 && j.stateNode.containerInfo === V.containerInfo && j.stateNode.implementation === V.implementation) {
                    u(
                      P,
                      j.sibling
                    ), Q = g(j, V.children || []), Q.return = P, P = Q;
                    break e;
                  } else {
                    u(P, j);
                    break;
                  }
                else o(P, j);
                j = j.sibling;
              }
              Q = Xh(V, P.mode, Q), Q.return = P, P = Q;
            }
            return _(P);
          case Z:
            return ve = V._init, V = ve(V._payload), at(
              P,
              j,
              V,
              Q
            );
        }
        if (ce(V))
          return Ae(
            P,
            j,
            V,
            Q
          );
        if (ie(V)) {
          if (ve = ie(V), typeof ve != "function") throw Error(i(150));
          return V = ve.call(V), ke(
            P,
            j,
            V,
            Q
          );
        }
        if (typeof V.then == "function")
          return at(
            P,
            j,
            zc(V),
            Q
          );
        if (V.$$typeof === z)
          return at(
            P,
            j,
            gc(P, V),
            Q
          );
        Ic(P, V);
      }
      return typeof V == "string" && V !== "" || typeof V == "number" || typeof V == "bigint" ? (V = "" + V, j !== null && j.tag === 6 ? (u(P, j.sibling), Q = g(j, V), Q.return = P, P = Q) : (u(P, j), Q = Jh(V, P.mode, Q), Q.return = P, P = Q), _(P)) : u(P, j);
    }
    return function(P, j, V, Q) {
      try {
        ll = 0;
        var ve = at(
          P,
          j,
          V,
          Q
        );
        return As = null, ve;
      } catch (we) {
        if (we === Qo || we === yc) throw we;
        var Be = Nn(29, we, null, P.mode);
        return Be.lanes = Q, Be.return = P, Be;
      } finally {
      }
    };
  }
  var zs = u0(!0), c0 = u0(!1), rr = X(null), Nr = null;
  function Oi(a) {
    var o = a.alternate;
    I(Ut, Ut.current & 1), I(rr, a), Nr === null && (o === null || ks.current !== null || o.memoizedState !== null) && (Nr = a);
  }
  function d0(a) {
    if (a.tag === 22) {
      if (I(Ut, Ut.current), I(rr, a), Nr === null) {
        var o = a.alternate;
        o !== null && o.memoizedState !== null && (Nr = a);
      }
    } else Ri();
  }
  function Ri() {
    I(Ut, Ut.current), I(rr, rr.current);
  }
  function si(a) {
    fe(rr), Nr === a && (Nr = null), fe(Ut);
  }
  var Ut = X(0);
  function Cc(a) {
    for (var o = a; o !== null; ) {
      if (o.tag === 13) {
        var u = o.memoizedState;
        if (u !== null && (u = u.dehydrated, u === null || u.data === "$?" || ym(u)))
          return o;
      } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) {
        if ((o.flags & 128) !== 0) return o;
      } else if (o.child !== null) {
        o.child.return = o, o = o.child;
        continue;
      }
      if (o === a) break;
      for (; o.sibling === null; ) {
        if (o.return === null || o.return === a) return null;
        o = o.return;
      }
      o.sibling.return = o.return, o = o.sibling;
    }
    return null;
  }
  function zp(a, o, u, d) {
    o = a.memoizedState, u = u(d, o), u = u == null ? o : p({}, o, u), a.memoizedState = u, a.lanes === 0 && (a.updateQueue.baseState = u);
  }
  var Ip = {
    enqueueSetState: function(a, o, u) {
      a = a._reactInternals;
      var d = Pn(), g = zi(d);
      g.payload = o, u != null && (g.callback = u), o = Ii(a, g, d), o !== null && (Un(o, a, d), tl(o, a, d));
    },
    enqueueReplaceState: function(a, o, u) {
      a = a._reactInternals;
      var d = Pn(), g = zi(d);
      g.tag = 1, g.payload = o, u != null && (g.callback = u), o = Ii(a, g, d), o !== null && (Un(o, a, d), tl(o, a, d));
    },
    enqueueForceUpdate: function(a, o) {
      a = a._reactInternals;
      var u = Pn(), d = zi(u);
      d.tag = 2, o != null && (d.callback = o), o = Ii(a, d, u), o !== null && (Un(o, a, u), tl(o, a, u));
    }
  };
  function f0(a, o, u, d, g, v, _) {
    return a = a.stateNode, typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(d, v, _) : o.prototype && o.prototype.isPureReactComponent ? !Ho(u, d) || !Ho(g, v) : !0;
  }
  function h0(a, o, u, d) {
    a = o.state, typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(u, d), typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(u, d), o.state !== a && Ip.enqueueReplaceState(o, o.state, null);
  }
  function Ea(a, o) {
    var u = o;
    if ("ref" in o) {
      u = {};
      for (var d in o)
        d !== "ref" && (u[d] = o[d]);
    }
    if (a = a.defaultProps) {
      u === o && (u = p({}, u));
      for (var g in a)
        u[g] === void 0 && (u[g] = a[g]);
    }
    return u;
  }
  var Oc = typeof reportError == "function" ? reportError : function(a) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var o = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof a == "object" && a !== null && typeof a.message == "string" ? String(a.message) : String(a),
        error: a
      });
      if (!window.dispatchEvent(o)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", a);
      return;
    }
    console.error(a);
  };
  function p0(a) {
    Oc(a);
  }
  function m0(a) {
    console.error(a);
  }
  function g0(a) {
    Oc(a);
  }
  function Rc(a, o) {
    try {
      var u = a.onUncaughtError;
      u(o.value, { componentStack: o.stack });
    } catch (d) {
      setTimeout(function() {
        throw d;
      });
    }
  }
  function v0(a, o, u) {
    try {
      var d = a.onCaughtError;
      d(u.value, {
        componentStack: u.stack,
        errorBoundary: o.tag === 1 ? o.stateNode : null
      });
    } catch (g) {
      setTimeout(function() {
        throw g;
      });
    }
  }
  function Cp(a, o, u) {
    return u = zi(u), u.tag = 3, u.payload = { element: null }, u.callback = function() {
      Rc(a, o);
    }, u;
  }
  function y0(a) {
    return a = zi(a), a.tag = 3, a;
  }
  function b0(a, o, u, d) {
    var g = u.type.getDerivedStateFromError;
    if (typeof g == "function") {
      var v = d.value;
      a.payload = function() {
        return g(v);
      }, a.callback = function() {
        v0(o, u, d);
      };
    }
    var _ = u.stateNode;
    _ !== null && typeof _.componentDidCatch == "function" && (a.callback = function() {
      v0(o, u, d), typeof g != "function" && (Ui === null ? Ui = /* @__PURE__ */ new Set([this]) : Ui.add(this));
      var E = d.stack;
      this.componentDidCatch(d.value, {
        componentStack: E !== null ? E : ""
      });
    });
  }
  function q4(a, o, u, d, g) {
    if (u.flags |= 32768, d !== null && typeof d == "object" && typeof d.then == "function") {
      if (o = u.alternate, o !== null && Xo(
        o,
        u,
        g,
        !0
      ), u = rr.current, u !== null) {
        switch (u.tag) {
          case 13:
            return Nr === null ? tm() : u.alternate === null && Et === 0 && (Et = 3), u.flags &= -257, u.flags |= 65536, u.lanes = g, d === sp ? u.flags |= 16384 : (o = u.updateQueue, o === null ? u.updateQueue = /* @__PURE__ */ new Set([d]) : o.add(d), rm(a, d, g)), !1;
          case 22:
            return u.flags |= 65536, d === sp ? u.flags |= 16384 : (o = u.updateQueue, o === null ? (o = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([d])
            }, u.updateQueue = o) : (u = o.retryQueue, u === null ? o.retryQueue = /* @__PURE__ */ new Set([d]) : u.add(d)), rm(a, d, g)), !1;
        }
        throw Error(i(435, u.tag));
      }
      return rm(a, d, g), tm(), !1;
    }
    if (Xe)
      return o = rr.current, o !== null ? ((o.flags & 65536) === 0 && (o.flags |= 256), o.flags |= 65536, o.lanes = g, d !== Qh && (a = Error(i(422), { cause: d }), Jo(Qn(a, u)))) : (d !== Qh && (o = Error(i(423), {
        cause: d
      }), Jo(
        Qn(o, u)
      )), a = a.current.alternate, a.flags |= 65536, g &= -g, a.lanes |= g, d = Qn(d, u), g = Cp(
        a.stateNode,
        d,
        g
      ), up(a, g), Et !== 4 && (Et = 2)), !1;
    var v = Error(i(520), { cause: d });
    if (v = Qn(v, u), gl === null ? gl = [v] : gl.push(v), Et !== 4 && (Et = 2), o === null) return !0;
    d = Qn(d, u), u = o;
    do {
      switch (u.tag) {
        case 3:
          return u.flags |= 65536, a = g & -g, u.lanes |= a, a = Cp(u.stateNode, d, a), up(u, a), !1;
        case 1:
          if (o = u.type, v = u.stateNode, (u.flags & 128) === 0 && (typeof o.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (Ui === null || !Ui.has(v))))
            return u.flags |= 65536, g &= -g, u.lanes |= g, g = y0(g), b0(
              g,
              a,
              u,
              d
            ), up(u, g), !1;
      }
      u = u.return;
    } while (u !== null);
    return !1;
  }
  var x0 = Error(i(461)), Gt = !1;
  function Wt(a, o, u, d) {
    o.child = a === null ? c0(o, null, u, d) : zs(
      o,
      a.child,
      u,
      d
    );
  }
  function w0(a, o, u, d, g) {
    u = u.render;
    var v = o.ref;
    if ("ref" in d) {
      var _ = {};
      for (var E in d)
        E !== "ref" && (_[E] = d[E]);
    } else _ = d;
    return Sa(o), d = pp(
      a,
      o,
      u,
      _,
      v,
      g
    ), E = mp(), a !== null && !Gt ? (gp(a, o, g), oi(a, o, g)) : (Xe && E && Kh(o), o.flags |= 1, Wt(a, o, d, g), o.child);
  }
  function _0(a, o, u, d, g) {
    if (a === null) {
      var v = u.type;
      return typeof v == "function" && !Yh(v) && v.defaultProps === void 0 && u.compare === null ? (o.tag = 15, o.type = v, S0(
        a,
        o,
        v,
        d,
        g
      )) : (a = fc(
        u.type,
        null,
        d,
        o,
        o.mode,
        g
      ), a.ref = o.ref, a.return = o, o.child = a);
    }
    if (v = a.child, !Up(a, g)) {
      var _ = v.memoizedProps;
      if (u = u.compare, u = u !== null ? u : Ho, u(_, d) && a.ref === o.ref)
        return oi(a, o, g);
    }
    return o.flags |= 1, a = ei(v, d), a.ref = o.ref, a.return = o, o.child = a;
  }
  function S0(a, o, u, d, g) {
    if (a !== null) {
      var v = a.memoizedProps;
      if (Ho(v, d) && a.ref === o.ref)
        if (Gt = !1, o.pendingProps = d = v, Up(a, g))
          (a.flags & 131072) !== 0 && (Gt = !0);
        else
          return o.lanes = a.lanes, oi(a, o, g);
    }
    return Op(
      a,
      o,
      u,
      d,
      g
    );
  }
  function k0(a, o, u) {
    var d = o.pendingProps, g = d.children, v = a !== null ? a.memoizedState : null;
    if (d.mode === "hidden") {
      if ((o.flags & 128) !== 0) {
        if (d = v !== null ? v.baseLanes | u : u, a !== null) {
          for (g = o.child = a.child, v = 0; g !== null; )
            v = v | g.lanes | g.childLanes, g = g.sibling;
          o.childLanes = v & ~d;
        } else o.childLanes = 0, o.child = null;
        return T0(
          a,
          o,
          d,
          u
        );
      }
      if ((u & 536870912) !== 0)
        o.memoizedState = { baseLanes: 0, cachePool: null }, a !== null && vc(
          o,
          v !== null ? v.cachePool : null
        ), v !== null ? S_(o, v) : dp(), d0(o);
      else
        return o.lanes = o.childLanes = 536870912, T0(
          a,
          o,
          v !== null ? v.baseLanes | u : u,
          u
        );
    } else
      v !== null ? (vc(o, v.cachePool), S_(o, v), Ri(), o.memoizedState = null) : (a !== null && vc(o, null), dp(), Ri());
    return Wt(a, o, g, u), o.child;
  }
  function T0(a, o, u, d) {
    var g = ap();
    return g = g === null ? null : { parent: Pt._currentValue, pool: g }, o.memoizedState = {
      baseLanes: u,
      cachePool: g
    }, a !== null && vc(o, null), dp(), d0(o), a !== null && Xo(a, o, d, !0), null;
  }
  function Nc(a, o) {
    var u = o.ref;
    if (u === null)
      a !== null && a.ref !== null && (o.flags |= 4194816);
    else {
      if (typeof u != "function" && typeof u != "object")
        throw Error(i(284));
      (a === null || a.ref !== u) && (o.flags |= 4194816);
    }
  }
  function Op(a, o, u, d, g) {
    return Sa(o), u = pp(
      a,
      o,
      u,
      d,
      void 0,
      g
    ), d = mp(), a !== null && !Gt ? (gp(a, o, g), oi(a, o, g)) : (Xe && d && Kh(o), o.flags |= 1, Wt(a, o, u, g), o.child);
  }
  function E0(a, o, u, d, g, v) {
    return Sa(o), o.updateQueue = null, u = T_(
      o,
      d,
      u,
      g
    ), k_(a), d = mp(), a !== null && !Gt ? (gp(a, o, v), oi(a, o, v)) : (Xe && d && Kh(o), o.flags |= 1, Wt(a, o, u, v), o.child);
  }
  function $0(a, o, u, d, g) {
    if (Sa(o), o.stateNode === null) {
      var v = bs, _ = u.contextType;
      typeof _ == "object" && _ !== null && (v = rn(_)), v = new u(d, v), o.memoizedState = v.state !== null && v.state !== void 0 ? v.state : null, v.updater = Ip, o.stateNode = v, v._reactInternals = o, v = o.stateNode, v.props = d, v.state = o.memoizedState, v.refs = {}, op(o), _ = u.contextType, v.context = typeof _ == "object" && _ !== null ? rn(_) : bs, v.state = o.memoizedState, _ = u.getDerivedStateFromProps, typeof _ == "function" && (zp(
        o,
        u,
        _,
        d
      ), v.state = o.memoizedState), typeof u.getDerivedStateFromProps == "function" || typeof v.getSnapshotBeforeUpdate == "function" || typeof v.UNSAFE_componentWillMount != "function" && typeof v.componentWillMount != "function" || (_ = v.state, typeof v.componentWillMount == "function" && v.componentWillMount(), typeof v.UNSAFE_componentWillMount == "function" && v.UNSAFE_componentWillMount(), _ !== v.state && Ip.enqueueReplaceState(v, v.state, null), rl(o, d, v, g), nl(), v.state = o.memoizedState), typeof v.componentDidMount == "function" && (o.flags |= 4194308), d = !0;
    } else if (a === null) {
      v = o.stateNode;
      var E = o.memoizedProps, R = Ea(u, E);
      v.props = R;
      var F = v.context, K = u.contextType;
      _ = bs, typeof K == "object" && K !== null && (_ = rn(K));
      var ee = u.getDerivedStateFromProps;
      K = typeof ee == "function" || typeof v.getSnapshotBeforeUpdate == "function", E = o.pendingProps !== E, K || typeof v.UNSAFE_componentWillReceiveProps != "function" && typeof v.componentWillReceiveProps != "function" || (E || F !== _) && h0(
        o,
        v,
        d,
        _
      ), Ai = !1;
      var q = o.memoizedState;
      v.state = q, rl(o, d, v, g), nl(), F = o.memoizedState, E || q !== F || Ai ? (typeof ee == "function" && (zp(
        o,
        u,
        ee,
        d
      ), F = o.memoizedState), (R = Ai || f0(
        o,
        u,
        R,
        d,
        q,
        F,
        _
      )) ? (K || typeof v.UNSAFE_componentWillMount != "function" && typeof v.componentWillMount != "function" || (typeof v.componentWillMount == "function" && v.componentWillMount(), typeof v.UNSAFE_componentWillMount == "function" && v.UNSAFE_componentWillMount()), typeof v.componentDidMount == "function" && (o.flags |= 4194308)) : (typeof v.componentDidMount == "function" && (o.flags |= 4194308), o.memoizedProps = d, o.memoizedState = F), v.props = d, v.state = F, v.context = _, d = R) : (typeof v.componentDidMount == "function" && (o.flags |= 4194308), d = !1);
    } else {
      v = o.stateNode, lp(a, o), _ = o.memoizedProps, K = Ea(u, _), v.props = K, ee = o.pendingProps, q = v.context, F = u.contextType, R = bs, typeof F == "object" && F !== null && (R = rn(F)), E = u.getDerivedStateFromProps, (F = typeof E == "function" || typeof v.getSnapshotBeforeUpdate == "function") || typeof v.UNSAFE_componentWillReceiveProps != "function" && typeof v.componentWillReceiveProps != "function" || (_ !== ee || q !== R) && h0(
        o,
        v,
        d,
        R
      ), Ai = !1, q = o.memoizedState, v.state = q, rl(o, d, v, g), nl();
      var G = o.memoizedState;
      _ !== ee || q !== G || Ai || a !== null && a.dependencies !== null && mc(a.dependencies) ? (typeof E == "function" && (zp(
        o,
        u,
        E,
        d
      ), G = o.memoizedState), (K = Ai || f0(
        o,
        u,
        K,
        d,
        q,
        G,
        R
      ) || a !== null && a.dependencies !== null && mc(a.dependencies)) ? (F || typeof v.UNSAFE_componentWillUpdate != "function" && typeof v.componentWillUpdate != "function" || (typeof v.componentWillUpdate == "function" && v.componentWillUpdate(d, G, R), typeof v.UNSAFE_componentWillUpdate == "function" && v.UNSAFE_componentWillUpdate(
        d,
        G,
        R
      )), typeof v.componentDidUpdate == "function" && (o.flags |= 4), typeof v.getSnapshotBeforeUpdate == "function" && (o.flags |= 1024)) : (typeof v.componentDidUpdate != "function" || _ === a.memoizedProps && q === a.memoizedState || (o.flags |= 4), typeof v.getSnapshotBeforeUpdate != "function" || _ === a.memoizedProps && q === a.memoizedState || (o.flags |= 1024), o.memoizedProps = d, o.memoizedState = G), v.props = d, v.state = G, v.context = R, d = K) : (typeof v.componentDidUpdate != "function" || _ === a.memoizedProps && q === a.memoizedState || (o.flags |= 4), typeof v.getSnapshotBeforeUpdate != "function" || _ === a.memoizedProps && q === a.memoizedState || (o.flags |= 1024), d = !1);
    }
    return v = d, Nc(a, o), d = (o.flags & 128) !== 0, v || d ? (v = o.stateNode, u = d && typeof u.getDerivedStateFromError != "function" ? null : v.render(), o.flags |= 1, a !== null && d ? (o.child = zs(
      o,
      a.child,
      null,
      g
    ), o.child = zs(
      o,
      null,
      u,
      g
    )) : Wt(a, o, u, g), o.memoizedState = v.state, a = o.child) : a = oi(
      a,
      o,
      g
    ), a;
  }
  function A0(a, o, u, d) {
    return Yo(), o.flags |= 256, Wt(a, o, u, d), o.child;
  }
  var Rp = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function Np(a) {
    return { baseLanes: a, cachePool: m_() };
  }
  function Mp(a, o, u) {
    return a = a !== null ? a.childLanes & ~u : 0, o && (a |= ir), a;
  }
  function z0(a, o, u) {
    var d = o.pendingProps, g = !1, v = (o.flags & 128) !== 0, _;
    if ((_ = v) || (_ = a !== null && a.memoizedState === null ? !1 : (Ut.current & 2) !== 0), _ && (g = !0, o.flags &= -129), _ = (o.flags & 32) !== 0, o.flags &= -33, a === null) {
      if (Xe) {
        if (g ? Oi(o) : Ri(), Xe) {
          var E = Tt, R;
          if (R = E) {
            e: {
              for (R = E, E = Rr; R.nodeType !== 8; ) {
                if (!E) {
                  E = null;
                  break e;
                }
                if (R = gr(
                  R.nextSibling
                ), R === null) {
                  E = null;
                  break e;
                }
              }
              E = R;
            }
            E !== null ? (o.memoizedState = {
              dehydrated: E,
              treeContext: ya !== null ? { id: ti, overflow: ni } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, R = Nn(
              18,
              null,
              null,
              0
            ), R.stateNode = E, R.return = o, o.child = R, cn = o, Tt = null, R = !0) : R = !1;
          }
          R || wa(o);
        }
        if (E = o.memoizedState, E !== null && (E = E.dehydrated, E !== null))
          return ym(E) ? o.lanes = 32 : o.lanes = 536870912, null;
        si(o);
      }
      return E = d.children, d = d.fallback, g ? (Ri(), g = o.mode, E = Mc(
        { mode: "hidden", children: E },
        g
      ), d = va(
        d,
        g,
        u,
        null
      ), E.return = o, d.return = o, E.sibling = d, o.child = E, g = o.child, g.memoizedState = Np(u), g.childLanes = Mp(
        a,
        _,
        u
      ), o.memoizedState = Rp, d) : (Oi(o), Dp(o, E));
    }
    if (R = a.memoizedState, R !== null && (E = R.dehydrated, E !== null)) {
      if (v)
        o.flags & 256 ? (Oi(o), o.flags &= -257, o = jp(
          a,
          o,
          u
        )) : o.memoizedState !== null ? (Ri(), o.child = a.child, o.flags |= 128, o = null) : (Ri(), g = d.fallback, E = o.mode, d = Mc(
          { mode: "visible", children: d.children },
          E
        ), g = va(
          g,
          E,
          u,
          null
        ), g.flags |= 2, d.return = o, g.return = o, d.sibling = g, o.child = d, zs(
          o,
          a.child,
          null,
          u
        ), d = o.child, d.memoizedState = Np(u), d.childLanes = Mp(
          a,
          _,
          u
        ), o.memoizedState = Rp, o = g);
      else if (Oi(o), ym(E)) {
        if (_ = E.nextSibling && E.nextSibling.dataset, _) var F = _.dgst;
        _ = F, d = Error(i(419)), d.stack = "", d.digest = _, Jo({ value: d, source: null, stack: null }), o = jp(
          a,
          o,
          u
        );
      } else if (Gt || Xo(a, o, u, !1), _ = (u & a.childLanes) !== 0, Gt || _) {
        if (_ = lt, _ !== null && (d = u & -u, d = (d & 42) !== 0 ? 1 : bh(d), d = (d & (_.suspendedLanes | u)) !== 0 ? 0 : d, d !== 0 && d !== R.retryLane))
          throw R.retryLane = d, ys(a, d), Un(_, a, d), x0;
        E.data === "$?" || tm(), o = jp(
          a,
          o,
          u
        );
      } else
        E.data === "$?" ? (o.flags |= 192, o.child = a.child, o = null) : (a = R.treeContext, Tt = gr(
          E.nextSibling
        ), cn = o, Xe = !0, xa = null, Rr = !1, a !== null && (tr[nr++] = ti, tr[nr++] = ni, tr[nr++] = ya, ti = a.id, ni = a.overflow, ya = o), o = Dp(
          o,
          d.children
        ), o.flags |= 4096);
      return o;
    }
    return g ? (Ri(), g = d.fallback, E = o.mode, R = a.child, F = R.sibling, d = ei(R, {
      mode: "hidden",
      children: d.children
    }), d.subtreeFlags = R.subtreeFlags & 65011712, F !== null ? g = ei(F, g) : (g = va(
      g,
      E,
      u,
      null
    ), g.flags |= 2), g.return = o, d.return = o, d.sibling = g, o.child = d, d = g, g = o.child, E = a.child.memoizedState, E === null ? E = Np(u) : (R = E.cachePool, R !== null ? (F = Pt._currentValue, R = R.parent !== F ? { parent: F, pool: F } : R) : R = m_(), E = {
      baseLanes: E.baseLanes | u,
      cachePool: R
    }), g.memoizedState = E, g.childLanes = Mp(
      a,
      _,
      u
    ), o.memoizedState = Rp, d) : (Oi(o), u = a.child, a = u.sibling, u = ei(u, {
      mode: "visible",
      children: d.children
    }), u.return = o, u.sibling = null, a !== null && (_ = o.deletions, _ === null ? (o.deletions = [a], o.flags |= 16) : _.push(a)), o.child = u, o.memoizedState = null, u);
  }
  function Dp(a, o) {
    return o = Mc(
      { mode: "visible", children: o },
      a.mode
    ), o.return = a, a.child = o;
  }
  function Mc(a, o) {
    return a = Nn(22, a, null, o), a.lanes = 0, a.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }, a;
  }
  function jp(a, o, u) {
    return zs(o, a.child, null, u), a = Dp(
      o,
      o.pendingProps.children
    ), a.flags |= 2, o.memoizedState = null, a;
  }
  function I0(a, o, u) {
    a.lanes |= o;
    var d = a.alternate;
    d !== null && (d.lanes |= o), tp(a.return, o, u);
  }
  function Pp(a, o, u, d, g) {
    var v = a.memoizedState;
    v === null ? a.memoizedState = {
      isBackwards: o,
      rendering: null,
      renderingStartTime: 0,
      last: d,
      tail: u,
      tailMode: g
    } : (v.isBackwards = o, v.rendering = null, v.renderingStartTime = 0, v.last = d, v.tail = u, v.tailMode = g);
  }
  function C0(a, o, u) {
    var d = o.pendingProps, g = d.revealOrder, v = d.tail;
    if (Wt(a, o, d.children, u), d = Ut.current, (d & 2) !== 0)
      d = d & 1 | 2, o.flags |= 128;
    else {
      if (a !== null && (a.flags & 128) !== 0)
        e: for (a = o.child; a !== null; ) {
          if (a.tag === 13)
            a.memoizedState !== null && I0(a, u, o);
          else if (a.tag === 19)
            I0(a, u, o);
          else if (a.child !== null) {
            a.child.return = a, a = a.child;
            continue;
          }
          if (a === o) break e;
          for (; a.sibling === null; ) {
            if (a.return === null || a.return === o)
              break e;
            a = a.return;
          }
          a.sibling.return = a.return, a = a.sibling;
        }
      d &= 1;
    }
    switch (I(Ut, d), g) {
      case "forwards":
        for (u = o.child, g = null; u !== null; )
          a = u.alternate, a !== null && Cc(a) === null && (g = u), u = u.sibling;
        u = g, u === null ? (g = o.child, o.child = null) : (g = u.sibling, u.sibling = null), Pp(
          o,
          !1,
          g,
          u,
          v
        );
        break;
      case "backwards":
        for (u = null, g = o.child, o.child = null; g !== null; ) {
          if (a = g.alternate, a !== null && Cc(a) === null) {
            o.child = g;
            break;
          }
          a = g.sibling, g.sibling = u, u = g, g = a;
        }
        Pp(
          o,
          !0,
          u,
          null,
          v
        );
        break;
      case "together":
        Pp(o, !1, null, null, void 0);
        break;
      default:
        o.memoizedState = null;
    }
    return o.child;
  }
  function oi(a, o, u) {
    if (a !== null && (o.dependencies = a.dependencies), Pi |= o.lanes, (u & o.childLanes) === 0)
      if (a !== null) {
        if (Xo(
          a,
          o,
          u,
          !1
        ), (u & o.childLanes) === 0)
          return null;
      } else return null;
    if (a !== null && o.child !== a.child)
      throw Error(i(153));
    if (o.child !== null) {
      for (a = o.child, u = ei(a, a.pendingProps), o.child = u, u.return = o; a.sibling !== null; )
        a = a.sibling, u = u.sibling = ei(a, a.pendingProps), u.return = o;
      u.sibling = null;
    }
    return o.child;
  }
  function Up(a, o) {
    return (a.lanes & o) !== 0 ? !0 : (a = a.dependencies, !!(a !== null && mc(a)));
  }
  function G4(a, o, u) {
    switch (o.tag) {
      case 3:
        Pe(o, o.stateNode.containerInfo), $i(o, Pt, a.memoizedState.cache), Yo();
        break;
      case 27:
      case 5:
        Kt(o);
        break;
      case 4:
        Pe(o, o.stateNode.containerInfo);
        break;
      case 10:
        $i(
          o,
          o.type,
          o.memoizedProps.value
        );
        break;
      case 13:
        var d = o.memoizedState;
        if (d !== null)
          return d.dehydrated !== null ? (Oi(o), o.flags |= 128, null) : (u & o.child.childLanes) !== 0 ? z0(a, o, u) : (Oi(o), a = oi(
            a,
            o,
            u
          ), a !== null ? a.sibling : null);
        Oi(o);
        break;
      case 19:
        var g = (a.flags & 128) !== 0;
        if (d = (u & o.childLanes) !== 0, d || (Xo(
          a,
          o,
          u,
          !1
        ), d = (u & o.childLanes) !== 0), g) {
          if (d)
            return C0(
              a,
              o,
              u
            );
          o.flags |= 128;
        }
        if (g = o.memoizedState, g !== null && (g.rendering = null, g.tail = null, g.lastEffect = null), I(Ut, Ut.current), d) break;
        return null;
      case 22:
      case 23:
        return o.lanes = 0, k0(a, o, u);
      case 24:
        $i(o, Pt, a.memoizedState.cache);
    }
    return oi(a, o, u);
  }
  function O0(a, o, u) {
    if (a !== null)
      if (a.memoizedProps !== o.pendingProps)
        Gt = !0;
      else {
        if (!Up(a, u) && (o.flags & 128) === 0)
          return Gt = !1, G4(
            a,
            o,
            u
          );
        Gt = (a.flags & 131072) !== 0;
      }
    else
      Gt = !1, Xe && (o.flags & 1048576) !== 0 && l_(o, pc, o.index);
    switch (o.lanes = 0, o.tag) {
      case 16:
        e: {
          a = o.pendingProps;
          var d = o.elementType, g = d._init;
          if (d = g(d._payload), o.type = d, typeof d == "function")
            Yh(d) ? (a = Ea(d, a), o.tag = 1, o = $0(
              null,
              o,
              d,
              a,
              u
            )) : (o.tag = 0, o = Op(
              null,
              o,
              d,
              a,
              u
            ));
          else {
            if (d != null) {
              if (g = d.$$typeof, g === O) {
                o.tag = 11, o = w0(
                  null,
                  o,
                  d,
                  a,
                  u
                );
                break e;
              } else if (g === U) {
                o.tag = 14, o = _0(
                  null,
                  o,
                  d,
                  a,
                  u
                );
                break e;
              }
            }
            throw o = se(d) || d, Error(i(306, o, ""));
          }
        }
        return o;
      case 0:
        return Op(
          a,
          o,
          o.type,
          o.pendingProps,
          u
        );
      case 1:
        return d = o.type, g = Ea(
          d,
          o.pendingProps
        ), $0(
          a,
          o,
          d,
          g,
          u
        );
      case 3:
        e: {
          if (Pe(
            o,
            o.stateNode.containerInfo
          ), a === null) throw Error(i(387));
          d = o.pendingProps;
          var v = o.memoizedState;
          g = v.element, lp(a, o), rl(o, d, null, u);
          var _ = o.memoizedState;
          if (d = _.cache, $i(o, Pt, d), d !== v.cache && np(
            o,
            [Pt],
            u,
            !0
          ), nl(), d = _.element, v.isDehydrated)
            if (v = {
              element: d,
              isDehydrated: !1,
              cache: _.cache
            }, o.updateQueue.baseState = v, o.memoizedState = v, o.flags & 256) {
              o = A0(
                a,
                o,
                d,
                u
              );
              break e;
            } else if (d !== g) {
              g = Qn(
                Error(i(424)),
                o
              ), Jo(g), o = A0(
                a,
                o,
                d,
                u
              );
              break e;
            } else {
              switch (a = o.stateNode.containerInfo, a.nodeType) {
                case 9:
                  a = a.body;
                  break;
                default:
                  a = a.nodeName === "HTML" ? a.ownerDocument.body : a;
              }
              for (Tt = gr(a.firstChild), cn = o, Xe = !0, xa = null, Rr = !0, u = c0(
                o,
                null,
                d,
                u
              ), o.child = u; u; )
                u.flags = u.flags & -3 | 4096, u = u.sibling;
            }
          else {
            if (Yo(), d === g) {
              o = oi(
                a,
                o,
                u
              );
              break e;
            }
            Wt(
              a,
              o,
              d,
              u
            );
          }
          o = o.child;
        }
        return o;
      case 26:
        return Nc(a, o), a === null ? (u = DS(
          o.type,
          null,
          o.pendingProps,
          null
        )) ? o.memoizedState = u : Xe || (u = o.type, a = o.pendingProps, d = Jc(
          pe.current
        ).createElement(u), d[nn] = o, d[bn] = a, en(d, u, a), qt(d), o.stateNode = d) : o.memoizedState = DS(
          o.type,
          a.memoizedProps,
          o.pendingProps,
          a.memoizedState
        ), null;
      case 27:
        return Kt(o), a === null && Xe && (d = o.stateNode = RS(
          o.type,
          o.pendingProps,
          pe.current
        ), cn = o, Rr = !0, g = Tt, Zi(o.type) ? (bm = g, Tt = gr(
          d.firstChild
        )) : Tt = g), Wt(
          a,
          o,
          o.pendingProps.children,
          u
        ), Nc(a, o), a === null && (o.flags |= 4194304), o.child;
      case 5:
        return a === null && Xe && ((g = d = Tt) && (d = wP(
          d,
          o.type,
          o.pendingProps,
          Rr
        ), d !== null ? (o.stateNode = d, cn = o, Tt = gr(
          d.firstChild
        ), Rr = !1, g = !0) : g = !1), g || wa(o)), Kt(o), g = o.type, v = o.pendingProps, _ = a !== null ? a.memoizedProps : null, d = v.children, mm(g, v) ? d = null : _ !== null && mm(g, _) && (o.flags |= 32), o.memoizedState !== null && (g = pp(
          a,
          o,
          U4,
          null,
          null,
          u
        ), Tl._currentValue = g), Nc(a, o), Wt(a, o, d, u), o.child;
      case 6:
        return a === null && Xe && ((a = u = Tt) && (u = _P(
          u,
          o.pendingProps,
          Rr
        ), u !== null ? (o.stateNode = u, cn = o, Tt = null, a = !0) : a = !1), a || wa(o)), null;
      case 13:
        return z0(a, o, u);
      case 4:
        return Pe(
          o,
          o.stateNode.containerInfo
        ), d = o.pendingProps, a === null ? o.child = zs(
          o,
          null,
          d,
          u
        ) : Wt(
          a,
          o,
          d,
          u
        ), o.child;
      case 11:
        return w0(
          a,
          o,
          o.type,
          o.pendingProps,
          u
        );
      case 7:
        return Wt(
          a,
          o,
          o.pendingProps,
          u
        ), o.child;
      case 8:
        return Wt(
          a,
          o,
          o.pendingProps.children,
          u
        ), o.child;
      case 12:
        return Wt(
          a,
          o,
          o.pendingProps.children,
          u
        ), o.child;
      case 10:
        return d = o.pendingProps, $i(o, o.type, d.value), Wt(
          a,
          o,
          d.children,
          u
        ), o.child;
      case 9:
        return g = o.type._context, d = o.pendingProps.children, Sa(o), g = rn(g), d = d(g), o.flags |= 1, Wt(a, o, d, u), o.child;
      case 14:
        return _0(
          a,
          o,
          o.type,
          o.pendingProps,
          u
        );
      case 15:
        return S0(
          a,
          o,
          o.type,
          o.pendingProps,
          u
        );
      case 19:
        return C0(a, o, u);
      case 31:
        return d = o.pendingProps, u = o.mode, d = {
          mode: d.mode,
          children: d.children
        }, a === null ? (u = Mc(
          d,
          u
        ), u.ref = o.ref, o.child = u, u.return = o, o = u) : (u = ei(a.child, d), u.ref = o.ref, o.child = u, u.return = o, o = u), o;
      case 22:
        return k0(a, o, u);
      case 24:
        return Sa(o), d = rn(Pt), a === null ? (g = ap(), g === null && (g = lt, v = rp(), g.pooledCache = v, v.refCount++, v !== null && (g.pooledCacheLanes |= u), g = v), o.memoizedState = {
          parent: d,
          cache: g
        }, op(o), $i(o, Pt, g)) : ((a.lanes & u) !== 0 && (lp(a, o), rl(o, null, null, u), nl()), g = a.memoizedState, v = o.memoizedState, g.parent !== d ? (g = { parent: d, cache: d }, o.memoizedState = g, o.lanes === 0 && (o.memoizedState = o.updateQueue.baseState = g), $i(o, Pt, d)) : (d = v.cache, $i(o, Pt, d), d !== g.cache && np(
          o,
          [Pt],
          u,
          !0
        ))), Wt(
          a,
          o,
          o.pendingProps.children,
          u
        ), o.child;
      case 29:
        throw o.pendingProps;
    }
    throw Error(i(156, o.tag));
  }
  function li(a) {
    a.flags |= 4;
  }
  function R0(a, o) {
    if (o.type !== "stylesheet" || (o.state.loading & 4) !== 0)
      a.flags &= -16777217;
    else if (a.flags |= 16777216, !BS(o)) {
      if (o = rr.current, o !== null && ((qe & 4194048) === qe ? Nr !== null : (qe & 62914560) !== qe && (qe & 536870912) === 0 || o !== Nr))
        throw el = sp, g_;
      a.flags |= 8192;
    }
  }
  function Dc(a, o) {
    o !== null && (a.flags |= 4), a.flags & 16384 && (o = a.tag !== 22 ? dw() : 536870912, a.lanes |= o, Rs |= o);
  }
  function cl(a, o) {
    if (!Xe)
      switch (a.tailMode) {
        case "hidden":
          o = a.tail;
          for (var u = null; o !== null; )
            o.alternate !== null && (u = o), o = o.sibling;
          u === null ? a.tail = null : u.sibling = null;
          break;
        case "collapsed":
          u = a.tail;
          for (var d = null; u !== null; )
            u.alternate !== null && (d = u), u = u.sibling;
          d === null ? o || a.tail === null ? a.tail = null : a.tail.sibling = null : d.sibling = null;
      }
  }
  function xt(a) {
    var o = a.alternate !== null && a.alternate.child === a.child, u = 0, d = 0;
    if (o)
      for (var g = a.child; g !== null; )
        u |= g.lanes | g.childLanes, d |= g.subtreeFlags & 65011712, d |= g.flags & 65011712, g.return = a, g = g.sibling;
    else
      for (g = a.child; g !== null; )
        u |= g.lanes | g.childLanes, d |= g.subtreeFlags, d |= g.flags, g.return = a, g = g.sibling;
    return a.subtreeFlags |= d, a.childLanes = u, o;
  }
  function Y4(a, o, u) {
    var d = o.pendingProps;
    switch (Wh(o), o.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return xt(o), null;
      case 1:
        return xt(o), null;
      case 3:
        return u = o.stateNode, d = null, a !== null && (d = a.memoizedState.cache), o.memoizedState.cache !== d && (o.flags |= 2048), ii(Pt), kt(), u.pendingContext && (u.context = u.pendingContext, u.pendingContext = null), (a === null || a.child === null) && (Go(o) ? li(o) : a === null || a.memoizedState.isDehydrated && (o.flags & 256) === 0 || (o.flags |= 1024, d_())), xt(o), null;
      case 26:
        return u = o.memoizedState, a === null ? (li(o), u !== null ? (xt(o), R0(o, u)) : (xt(o), o.flags &= -16777217)) : u ? u !== a.memoizedState ? (li(o), xt(o), R0(o, u)) : (xt(o), o.flags &= -16777217) : (a.memoizedProps !== d && li(o), xt(o), o.flags &= -16777217), null;
      case 27:
        un(o), u = pe.current;
        var g = o.type;
        if (a !== null && o.stateNode != null)
          a.memoizedProps !== d && li(o);
        else {
          if (!d) {
            if (o.stateNode === null)
              throw Error(i(166));
            return xt(o), null;
          }
          a = he.current, Go(o) ? u_(o) : (a = RS(g, d, u), o.stateNode = a, li(o));
        }
        return xt(o), null;
      case 5:
        if (un(o), u = o.type, a !== null && o.stateNode != null)
          a.memoizedProps !== d && li(o);
        else {
          if (!d) {
            if (o.stateNode === null)
              throw Error(i(166));
            return xt(o), null;
          }
          if (a = he.current, Go(o))
            u_(o);
          else {
            switch (g = Jc(
              pe.current
            ), a) {
              case 1:
                a = g.createElementNS(
                  "http://www.w3.org/2000/svg",
                  u
                );
                break;
              case 2:
                a = g.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  u
                );
                break;
              default:
                switch (u) {
                  case "svg":
                    a = g.createElementNS(
                      "http://www.w3.org/2000/svg",
                      u
                    );
                    break;
                  case "math":
                    a = g.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      u
                    );
                    break;
                  case "script":
                    a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild);
                    break;
                  case "select":
                    a = typeof d.is == "string" ? g.createElement("select", { is: d.is }) : g.createElement("select"), d.multiple ? a.multiple = !0 : d.size && (a.size = d.size);
                    break;
                  default:
                    a = typeof d.is == "string" ? g.createElement(u, { is: d.is }) : g.createElement(u);
                }
            }
            a[nn] = o, a[bn] = d;
            e: for (g = o.child; g !== null; ) {
              if (g.tag === 5 || g.tag === 6)
                a.appendChild(g.stateNode);
              else if (g.tag !== 4 && g.tag !== 27 && g.child !== null) {
                g.child.return = g, g = g.child;
                continue;
              }
              if (g === o) break e;
              for (; g.sibling === null; ) {
                if (g.return === null || g.return === o)
                  break e;
                g = g.return;
              }
              g.sibling.return = g.return, g = g.sibling;
            }
            o.stateNode = a;
            e: switch (en(a, u, d), u) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                a = !!d.autoFocus;
                break e;
              case "img":
                a = !0;
                break e;
              default:
                a = !1;
            }
            a && li(o);
          }
        }
        return xt(o), o.flags &= -16777217, null;
      case 6:
        if (a && o.stateNode != null)
          a.memoizedProps !== d && li(o);
        else {
          if (typeof d != "string" && o.stateNode === null)
            throw Error(i(166));
          if (a = pe.current, Go(o)) {
            if (a = o.stateNode, u = o.memoizedProps, d = null, g = cn, g !== null)
              switch (g.tag) {
                case 27:
                case 5:
                  d = g.memoizedProps;
              }
            a[nn] = o, a = !!(a.nodeValue === u || d !== null && d.suppressHydrationWarning === !0 || ES(a.nodeValue, u)), a || wa(o);
          } else
            a = Jc(a).createTextNode(
              d
            ), a[nn] = o, o.stateNode = a;
        }
        return xt(o), null;
      case 13:
        if (d = o.memoizedState, a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
          if (g = Go(o), d !== null && d.dehydrated !== null) {
            if (a === null) {
              if (!g) throw Error(i(318));
              if (g = o.memoizedState, g = g !== null ? g.dehydrated : null, !g) throw Error(i(317));
              g[nn] = o;
            } else
              Yo(), (o.flags & 128) === 0 && (o.memoizedState = null), o.flags |= 4;
            xt(o), g = !1;
          } else
            g = d_(), a !== null && a.memoizedState !== null && (a.memoizedState.hydrationErrors = g), g = !0;
          if (!g)
            return o.flags & 256 ? (si(o), o) : (si(o), null);
        }
        if (si(o), (o.flags & 128) !== 0)
          return o.lanes = u, o;
        if (u = d !== null, a = a !== null && a.memoizedState !== null, u) {
          d = o.child, g = null, d.alternate !== null && d.alternate.memoizedState !== null && d.alternate.memoizedState.cachePool !== null && (g = d.alternate.memoizedState.cachePool.pool);
          var v = null;
          d.memoizedState !== null && d.memoizedState.cachePool !== null && (v = d.memoizedState.cachePool.pool), v !== g && (d.flags |= 2048);
        }
        return u !== a && u && (o.child.flags |= 8192), Dc(o, o.updateQueue), xt(o), null;
      case 4:
        return kt(), a === null && cm(o.stateNode.containerInfo), xt(o), null;
      case 10:
        return ii(o.type), xt(o), null;
      case 19:
        if (fe(Ut), g = o.memoizedState, g === null) return xt(o), null;
        if (d = (o.flags & 128) !== 0, v = g.rendering, v === null)
          if (d) cl(g, !1);
          else {
            if (Et !== 0 || a !== null && (a.flags & 128) !== 0)
              for (a = o.child; a !== null; ) {
                if (v = Cc(a), v !== null) {
                  for (o.flags |= 128, cl(g, !1), a = v.updateQueue, o.updateQueue = a, Dc(o, a), o.subtreeFlags = 0, a = u, u = o.child; u !== null; )
                    o_(u, a), u = u.sibling;
                  return I(
                    Ut,
                    Ut.current & 1 | 2
                  ), o.child;
                }
                a = a.sibling;
              }
            g.tail !== null && In() > Uc && (o.flags |= 128, d = !0, cl(g, !1), o.lanes = 4194304);
          }
        else {
          if (!d)
            if (a = Cc(v), a !== null) {
              if (o.flags |= 128, d = !0, a = a.updateQueue, o.updateQueue = a, Dc(o, a), cl(g, !0), g.tail === null && g.tailMode === "hidden" && !v.alternate && !Xe)
                return xt(o), null;
            } else
              2 * In() - g.renderingStartTime > Uc && u !== 536870912 && (o.flags |= 128, d = !0, cl(g, !1), o.lanes = 4194304);
          g.isBackwards ? (v.sibling = o.child, o.child = v) : (a = g.last, a !== null ? a.sibling = v : o.child = v, g.last = v);
        }
        return g.tail !== null ? (o = g.tail, g.rendering = o, g.tail = o.sibling, g.renderingStartTime = In(), o.sibling = null, a = Ut.current, I(Ut, d ? a & 1 | 2 : a & 1), o) : (xt(o), null);
      case 22:
      case 23:
        return si(o), fp(), d = o.memoizedState !== null, a !== null ? a.memoizedState !== null !== d && (o.flags |= 8192) : d && (o.flags |= 8192), d ? (u & 536870912) !== 0 && (o.flags & 128) === 0 && (xt(o), o.subtreeFlags & 6 && (o.flags |= 8192)) : xt(o), u = o.updateQueue, u !== null && Dc(o, u.retryQueue), u = null, a !== null && a.memoizedState !== null && a.memoizedState.cachePool !== null && (u = a.memoizedState.cachePool.pool), d = null, o.memoizedState !== null && o.memoizedState.cachePool !== null && (d = o.memoizedState.cachePool.pool), d !== u && (o.flags |= 2048), a !== null && fe(ka), null;
      case 24:
        return u = null, a !== null && (u = a.memoizedState.cache), o.memoizedState.cache !== u && (o.flags |= 2048), ii(Pt), xt(o), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(i(156, o.tag));
  }
  function J4(a, o) {
    switch (Wh(o), o.tag) {
      case 1:
        return a = o.flags, a & 65536 ? (o.flags = a & -65537 | 128, o) : null;
      case 3:
        return ii(Pt), kt(), a = o.flags, (a & 65536) !== 0 && (a & 128) === 0 ? (o.flags = a & -65537 | 128, o) : null;
      case 26:
      case 27:
      case 5:
        return un(o), null;
      case 13:
        if (si(o), a = o.memoizedState, a !== null && a.dehydrated !== null) {
          if (o.alternate === null)
            throw Error(i(340));
          Yo();
        }
        return a = o.flags, a & 65536 ? (o.flags = a & -65537 | 128, o) : null;
      case 19:
        return fe(Ut), null;
      case 4:
        return kt(), null;
      case 10:
        return ii(o.type), null;
      case 22:
      case 23:
        return si(o), fp(), a !== null && fe(ka), a = o.flags, a & 65536 ? (o.flags = a & -65537 | 128, o) : null;
      case 24:
        return ii(Pt), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function N0(a, o) {
    switch (Wh(o), o.tag) {
      case 3:
        ii(Pt), kt();
        break;
      case 26:
      case 27:
      case 5:
        un(o);
        break;
      case 4:
        kt();
        break;
      case 13:
        si(o);
        break;
      case 19:
        fe(Ut);
        break;
      case 10:
        ii(o.type);
        break;
      case 22:
      case 23:
        si(o), fp(), a !== null && fe(ka);
        break;
      case 24:
        ii(Pt);
    }
  }
  function dl(a, o) {
    try {
      var u = o.updateQueue, d = u !== null ? u.lastEffect : null;
      if (d !== null) {
        var g = d.next;
        u = g;
        do {
          if ((u.tag & a) === a) {
            d = void 0;
            var v = u.create, _ = u.inst;
            d = v(), _.destroy = d;
          }
          u = u.next;
        } while (u !== g);
      }
    } catch (E) {
      st(o, o.return, E);
    }
  }
  function Ni(a, o, u) {
    try {
      var d = o.updateQueue, g = d !== null ? d.lastEffect : null;
      if (g !== null) {
        var v = g.next;
        d = v;
        do {
          if ((d.tag & a) === a) {
            var _ = d.inst, E = _.destroy;
            if (E !== void 0) {
              _.destroy = void 0, g = o;
              var R = u, F = E;
              try {
                F();
              } catch (K) {
                st(
                  g,
                  R,
                  K
                );
              }
            }
          }
          d = d.next;
        } while (d !== v);
      }
    } catch (K) {
      st(o, o.return, K);
    }
  }
  function M0(a) {
    var o = a.updateQueue;
    if (o !== null) {
      var u = a.stateNode;
      try {
        __(o, u);
      } catch (d) {
        st(a, a.return, d);
      }
    }
  }
  function D0(a, o, u) {
    u.props = Ea(
      a.type,
      a.memoizedProps
    ), u.state = a.memoizedState;
    try {
      u.componentWillUnmount();
    } catch (d) {
      st(a, o, d);
    }
  }
  function fl(a, o) {
    try {
      var u = a.ref;
      if (u !== null) {
        switch (a.tag) {
          case 26:
          case 27:
          case 5:
            var d = a.stateNode;
            break;
          case 30:
            d = a.stateNode;
            break;
          default:
            d = a.stateNode;
        }
        typeof u == "function" ? a.refCleanup = u(d) : u.current = d;
      }
    } catch (g) {
      st(a, o, g);
    }
  }
  function Mr(a, o) {
    var u = a.ref, d = a.refCleanup;
    if (u !== null)
      if (typeof d == "function")
        try {
          d();
        } catch (g) {
          st(a, o, g);
        } finally {
          a.refCleanup = null, a = a.alternate, a != null && (a.refCleanup = null);
        }
      else if (typeof u == "function")
        try {
          u(null);
        } catch (g) {
          st(a, o, g);
        }
      else u.current = null;
  }
  function j0(a) {
    var o = a.type, u = a.memoizedProps, d = a.stateNode;
    try {
      e: switch (o) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          u.autoFocus && d.focus();
          break e;
        case "img":
          u.src ? d.src = u.src : u.srcSet && (d.srcset = u.srcSet);
      }
    } catch (g) {
      st(a, a.return, g);
    }
  }
  function Lp(a, o, u) {
    try {
      var d = a.stateNode;
      gP(d, a.type, u, o), d[bn] = o;
    } catch (g) {
      st(a, a.return, g);
    }
  }
  function P0(a) {
    return a.tag === 5 || a.tag === 3 || a.tag === 26 || a.tag === 27 && Zi(a.type) || a.tag === 4;
  }
  function Bp(a) {
    e: for (; ; ) {
      for (; a.sibling === null; ) {
        if (a.return === null || P0(a.return)) return null;
        a = a.return;
      }
      for (a.sibling.return = a.return, a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
        if (a.tag === 27 && Zi(a.type) || a.flags & 2 || a.child === null || a.tag === 4) continue e;
        a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function Zp(a, o, u) {
    var d = a.tag;
    if (d === 5 || d === 6)
      a = a.stateNode, o ? (u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u).insertBefore(a, o) : (o = u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u, o.appendChild(a), u = u._reactRootContainer, u != null || o.onclick !== null || (o.onclick = Yc));
    else if (d !== 4 && (d === 27 && Zi(a.type) && (u = a.stateNode, o = null), a = a.child, a !== null))
      for (Zp(a, o, u), a = a.sibling; a !== null; )
        Zp(a, o, u), a = a.sibling;
  }
  function jc(a, o, u) {
    var d = a.tag;
    if (d === 5 || d === 6)
      a = a.stateNode, o ? u.insertBefore(a, o) : u.appendChild(a);
    else if (d !== 4 && (d === 27 && Zi(a.type) && (u = a.stateNode), a = a.child, a !== null))
      for (jc(a, o, u), a = a.sibling; a !== null; )
        jc(a, o, u), a = a.sibling;
  }
  function U0(a) {
    var o = a.stateNode, u = a.memoizedProps;
    try {
      for (var d = a.type, g = o.attributes; g.length; )
        o.removeAttributeNode(g[0]);
      en(o, d, u), o[nn] = a, o[bn] = u;
    } catch (v) {
      st(a, a.return, v);
    }
  }
  var ui = !1, It = !1, Vp = !1, L0 = typeof WeakSet == "function" ? WeakSet : Set, Yt = null;
  function X4(a, o) {
    if (a = a.containerInfo, hm = td, a = Kw(a), Bh(a)) {
      if ("selectionStart" in a)
        var u = {
          start: a.selectionStart,
          end: a.selectionEnd
        };
      else
        e: {
          u = (u = a.ownerDocument) && u.defaultView || window;
          var d = u.getSelection && u.getSelection();
          if (d && d.rangeCount !== 0) {
            u = d.anchorNode;
            var g = d.anchorOffset, v = d.focusNode;
            d = d.focusOffset;
            try {
              u.nodeType, v.nodeType;
            } catch {
              u = null;
              break e;
            }
            var _ = 0, E = -1, R = -1, F = 0, K = 0, ee = a, q = null;
            t: for (; ; ) {
              for (var G; ee !== u || g !== 0 && ee.nodeType !== 3 || (E = _ + g), ee !== v || d !== 0 && ee.nodeType !== 3 || (R = _ + d), ee.nodeType === 3 && (_ += ee.nodeValue.length), (G = ee.firstChild) !== null; )
                q = ee, ee = G;
              for (; ; ) {
                if (ee === a) break t;
                if (q === u && ++F === g && (E = _), q === v && ++K === d && (R = _), (G = ee.nextSibling) !== null) break;
                ee = q, q = ee.parentNode;
              }
              ee = G;
            }
            u = E === -1 || R === -1 ? null : { start: E, end: R };
          } else u = null;
        }
      u = u || { start: 0, end: 0 };
    } else u = null;
    for (pm = { focusedElem: a, selectionRange: u }, td = !1, Yt = o; Yt !== null; )
      if (o = Yt, a = o.child, (o.subtreeFlags & 1024) !== 0 && a !== null)
        a.return = o, Yt = a;
      else
        for (; Yt !== null; ) {
          switch (o = Yt, v = o.alternate, a = o.flags, o.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((a & 1024) !== 0 && v !== null) {
                a = void 0, u = o, g = v.memoizedProps, v = v.memoizedState, d = u.stateNode;
                try {
                  var Ae = Ea(
                    u.type,
                    g,
                    u.elementType === u.type
                  );
                  a = d.getSnapshotBeforeUpdate(
                    Ae,
                    v
                  ), d.__reactInternalSnapshotBeforeUpdate = a;
                } catch (ke) {
                  st(
                    u,
                    u.return,
                    ke
                  );
                }
              }
              break;
            case 3:
              if ((a & 1024) !== 0) {
                if (a = o.stateNode.containerInfo, u = a.nodeType, u === 9)
                  vm(a);
                else if (u === 1)
                  switch (a.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      vm(a);
                      break;
                    default:
                      a.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((a & 1024) !== 0) throw Error(i(163));
          }
          if (a = o.sibling, a !== null) {
            a.return = o.return, Yt = a;
            break;
          }
          Yt = o.return;
        }
  }
  function B0(a, o, u) {
    var d = u.flags;
    switch (u.tag) {
      case 0:
      case 11:
      case 15:
        Mi(a, u), d & 4 && dl(5, u);
        break;
      case 1:
        if (Mi(a, u), d & 4)
          if (a = u.stateNode, o === null)
            try {
              a.componentDidMount();
            } catch (_) {
              st(u, u.return, _);
            }
          else {
            var g = Ea(
              u.type,
              o.memoizedProps
            );
            o = o.memoizedState;
            try {
              a.componentDidUpdate(
                g,
                o,
                a.__reactInternalSnapshotBeforeUpdate
              );
            } catch (_) {
              st(
                u,
                u.return,
                _
              );
            }
          }
        d & 64 && M0(u), d & 512 && fl(u, u.return);
        break;
      case 3:
        if (Mi(a, u), d & 64 && (a = u.updateQueue, a !== null)) {
          if (o = null, u.child !== null)
            switch (u.child.tag) {
              case 27:
              case 5:
                o = u.child.stateNode;
                break;
              case 1:
                o = u.child.stateNode;
            }
          try {
            __(a, o);
          } catch (_) {
            st(u, u.return, _);
          }
        }
        break;
      case 27:
        o === null && d & 4 && U0(u);
      case 26:
      case 5:
        Mi(a, u), o === null && d & 4 && j0(u), d & 512 && fl(u, u.return);
        break;
      case 12:
        Mi(a, u);
        break;
      case 13:
        Mi(a, u), d & 4 && F0(a, u), d & 64 && (a = u.memoizedState, a !== null && (a = a.dehydrated, a !== null && (u = aP.bind(
          null,
          u
        ), SP(a, u))));
        break;
      case 22:
        if (d = u.memoizedState !== null || ui, !d) {
          o = o !== null && o.memoizedState !== null || It, g = ui;
          var v = It;
          ui = d, (It = o) && !v ? Di(
            a,
            u,
            (u.subtreeFlags & 8772) !== 0
          ) : Mi(a, u), ui = g, It = v;
        }
        break;
      case 30:
        break;
      default:
        Mi(a, u);
    }
  }
  function Z0(a) {
    var o = a.alternate;
    o !== null && (a.alternate = null, Z0(o)), a.child = null, a.deletions = null, a.sibling = null, a.tag === 5 && (o = a.stateNode, o !== null && _h(o)), a.stateNode = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
  }
  var gt = null, _n = !1;
  function ci(a, o, u) {
    for (u = u.child; u !== null; )
      V0(a, o, u), u = u.sibling;
  }
  function V0(a, o, u) {
    if (oe && typeof oe.onCommitFiberUnmount == "function")
      try {
        oe.onCommitFiberUnmount(J, u);
      } catch {
      }
    switch (u.tag) {
      case 26:
        It || Mr(u, o), ci(
          a,
          o,
          u
        ), u.memoizedState ? u.memoizedState.count-- : u.stateNode && (u = u.stateNode, u.parentNode.removeChild(u));
        break;
      case 27:
        It || Mr(u, o);
        var d = gt, g = _n;
        Zi(u.type) && (gt = u.stateNode, _n = !1), ci(
          a,
          o,
          u
        ), wl(u.stateNode), gt = d, _n = g;
        break;
      case 5:
        It || Mr(u, o);
      case 6:
        if (d = gt, g = _n, gt = null, ci(
          a,
          o,
          u
        ), gt = d, _n = g, gt !== null)
          if (_n)
            try {
              (gt.nodeType === 9 ? gt.body : gt.nodeName === "HTML" ? gt.ownerDocument.body : gt).removeChild(u.stateNode);
            } catch (v) {
              st(
                u,
                o,
                v
              );
            }
          else
            try {
              gt.removeChild(u.stateNode);
            } catch (v) {
              st(
                u,
                o,
                v
              );
            }
        break;
      case 18:
        gt !== null && (_n ? (a = gt, CS(
          a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a,
          u.stateNode
        ), zl(a)) : CS(gt, u.stateNode));
        break;
      case 4:
        d = gt, g = _n, gt = u.stateNode.containerInfo, _n = !0, ci(
          a,
          o,
          u
        ), gt = d, _n = g;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        It || Ni(2, u, o), It || Ni(4, u, o), ci(
          a,
          o,
          u
        );
        break;
      case 1:
        It || (Mr(u, o), d = u.stateNode, typeof d.componentWillUnmount == "function" && D0(
          u,
          o,
          d
        )), ci(
          a,
          o,
          u
        );
        break;
      case 21:
        ci(
          a,
          o,
          u
        );
        break;
      case 22:
        It = (d = It) || u.memoizedState !== null, ci(
          a,
          o,
          u
        ), It = d;
        break;
      default:
        ci(
          a,
          o,
          u
        );
    }
  }
  function F0(a, o) {
    if (o.memoizedState === null && (a = o.alternate, a !== null && (a = a.memoizedState, a !== null && (a = a.dehydrated, a !== null))))
      try {
        zl(a);
      } catch (u) {
        st(o, o.return, u);
      }
  }
  function K4(a) {
    switch (a.tag) {
      case 13:
      case 19:
        var o = a.stateNode;
        return o === null && (o = a.stateNode = new L0()), o;
      case 22:
        return a = a.stateNode, o = a._retryCache, o === null && (o = a._retryCache = new L0()), o;
      default:
        throw Error(i(435, a.tag));
    }
  }
  function Fp(a, o) {
    var u = K4(a);
    o.forEach(function(d) {
      var g = sP.bind(null, a, d);
      u.has(d) || (u.add(d), d.then(g, g));
    });
  }
  function Mn(a, o) {
    var u = o.deletions;
    if (u !== null)
      for (var d = 0; d < u.length; d++) {
        var g = u[d], v = a, _ = o, E = _;
        e: for (; E !== null; ) {
          switch (E.tag) {
            case 27:
              if (Zi(E.type)) {
                gt = E.stateNode, _n = !1;
                break e;
              }
              break;
            case 5:
              gt = E.stateNode, _n = !1;
              break e;
            case 3:
            case 4:
              gt = E.stateNode.containerInfo, _n = !0;
              break e;
          }
          E = E.return;
        }
        if (gt === null) throw Error(i(160));
        V0(v, _, g), gt = null, _n = !1, v = g.alternate, v !== null && (v.return = null), g.return = null;
      }
    if (o.subtreeFlags & 13878)
      for (o = o.child; o !== null; )
        H0(o, a), o = o.sibling;
  }
  var mr = null;
  function H0(a, o) {
    var u = a.alternate, d = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Mn(o, a), Dn(a), d & 4 && (Ni(3, a, a.return), dl(3, a), Ni(5, a, a.return));
        break;
      case 1:
        Mn(o, a), Dn(a), d & 512 && (It || u === null || Mr(u, u.return)), d & 64 && ui && (a = a.updateQueue, a !== null && (d = a.callbacks, d !== null && (u = a.shared.hiddenCallbacks, a.shared.hiddenCallbacks = u === null ? d : u.concat(d))));
        break;
      case 26:
        var g = mr;
        if (Mn(o, a), Dn(a), d & 512 && (It || u === null || Mr(u, u.return)), d & 4) {
          var v = u !== null ? u.memoizedState : null;
          if (d = a.memoizedState, u === null)
            if (d === null)
              if (a.stateNode === null) {
                e: {
                  d = a.type, u = a.memoizedProps, g = g.ownerDocument || g;
                  t: switch (d) {
                    case "title":
                      v = g.getElementsByTagName("title")[0], (!v || v[Do] || v[nn] || v.namespaceURI === "http://www.w3.org/2000/svg" || v.hasAttribute("itemprop")) && (v = g.createElement(d), g.head.insertBefore(
                        v,
                        g.querySelector("head > title")
                      )), en(v, d, u), v[nn] = a, qt(v), d = v;
                      break e;
                    case "link":
                      var _ = US(
                        "link",
                        "href",
                        g
                      ).get(d + (u.href || ""));
                      if (_) {
                        for (var E = 0; E < _.length; E++)
                          if (v = _[E], v.getAttribute("href") === (u.href == null || u.href === "" ? null : u.href) && v.getAttribute("rel") === (u.rel == null ? null : u.rel) && v.getAttribute("title") === (u.title == null ? null : u.title) && v.getAttribute("crossorigin") === (u.crossOrigin == null ? null : u.crossOrigin)) {
                            _.splice(E, 1);
                            break t;
                          }
                      }
                      v = g.createElement(d), en(v, d, u), g.head.appendChild(v);
                      break;
                    case "meta":
                      if (_ = US(
                        "meta",
                        "content",
                        g
                      ).get(d + (u.content || ""))) {
                        for (E = 0; E < _.length; E++)
                          if (v = _[E], v.getAttribute("content") === (u.content == null ? null : "" + u.content) && v.getAttribute("name") === (u.name == null ? null : u.name) && v.getAttribute("property") === (u.property == null ? null : u.property) && v.getAttribute("http-equiv") === (u.httpEquiv == null ? null : u.httpEquiv) && v.getAttribute("charset") === (u.charSet == null ? null : u.charSet)) {
                            _.splice(E, 1);
                            break t;
                          }
                      }
                      v = g.createElement(d), en(v, d, u), g.head.appendChild(v);
                      break;
                    default:
                      throw Error(i(468, d));
                  }
                  v[nn] = a, qt(v), d = v;
                }
                a.stateNode = d;
              } else
                LS(
                  g,
                  a.type,
                  a.stateNode
                );
            else
              a.stateNode = PS(
                g,
                d,
                a.memoizedProps
              );
          else
            v !== d ? (v === null ? u.stateNode !== null && (u = u.stateNode, u.parentNode.removeChild(u)) : v.count--, d === null ? LS(
              g,
              a.type,
              a.stateNode
            ) : PS(
              g,
              d,
              a.memoizedProps
            )) : d === null && a.stateNode !== null && Lp(
              a,
              a.memoizedProps,
              u.memoizedProps
            );
        }
        break;
      case 27:
        Mn(o, a), Dn(a), d & 512 && (It || u === null || Mr(u, u.return)), u !== null && d & 4 && Lp(
          a,
          a.memoizedProps,
          u.memoizedProps
        );
        break;
      case 5:
        if (Mn(o, a), Dn(a), d & 512 && (It || u === null || Mr(u, u.return)), a.flags & 32) {
          g = a.stateNode;
          try {
            ds(g, "");
          } catch (G) {
            st(a, a.return, G);
          }
        }
        d & 4 && a.stateNode != null && (g = a.memoizedProps, Lp(
          a,
          g,
          u !== null ? u.memoizedProps : g
        )), d & 1024 && (Vp = !0);
        break;
      case 6:
        if (Mn(o, a), Dn(a), d & 4) {
          if (a.stateNode === null)
            throw Error(i(162));
          d = a.memoizedProps, u = a.stateNode;
          try {
            u.nodeValue = d;
          } catch (G) {
            st(a, a.return, G);
          }
        }
        break;
      case 3:
        if (Wc = null, g = mr, mr = Xc(o.containerInfo), Mn(o, a), mr = g, Dn(a), d & 4 && u !== null && u.memoizedState.isDehydrated)
          try {
            zl(o.containerInfo);
          } catch (G) {
            st(a, a.return, G);
          }
        Vp && (Vp = !1, q0(a));
        break;
      case 4:
        d = mr, mr = Xc(
          a.stateNode.containerInfo
        ), Mn(o, a), Dn(a), mr = d;
        break;
      case 12:
        Mn(o, a), Dn(a);
        break;
      case 13:
        Mn(o, a), Dn(a), a.child.flags & 8192 && a.memoizedState !== null != (u !== null && u.memoizedState !== null) && (Xp = In()), d & 4 && (d = a.updateQueue, d !== null && (a.updateQueue = null, Fp(a, d)));
        break;
      case 22:
        g = a.memoizedState !== null;
        var R = u !== null && u.memoizedState !== null, F = ui, K = It;
        if (ui = F || g, It = K || R, Mn(o, a), It = K, ui = F, Dn(a), d & 8192)
          e: for (o = a.stateNode, o._visibility = g ? o._visibility & -2 : o._visibility | 1, g && (u === null || R || ui || It || $a(a)), u = null, o = a; ; ) {
            if (o.tag === 5 || o.tag === 26) {
              if (u === null) {
                R = u = o;
                try {
                  if (v = R.stateNode, g)
                    _ = v.style, typeof _.setProperty == "function" ? _.setProperty("display", "none", "important") : _.display = "none";
                  else {
                    E = R.stateNode;
                    var ee = R.memoizedProps.style, q = ee != null && ee.hasOwnProperty("display") ? ee.display : null;
                    E.style.display = q == null || typeof q == "boolean" ? "" : ("" + q).trim();
                  }
                } catch (G) {
                  st(R, R.return, G);
                }
              }
            } else if (o.tag === 6) {
              if (u === null) {
                R = o;
                try {
                  R.stateNode.nodeValue = g ? "" : R.memoizedProps;
                } catch (G) {
                  st(R, R.return, G);
                }
              }
            } else if ((o.tag !== 22 && o.tag !== 23 || o.memoizedState === null || o === a) && o.child !== null) {
              o.child.return = o, o = o.child;
              continue;
            }
            if (o === a) break e;
            for (; o.sibling === null; ) {
              if (o.return === null || o.return === a) break e;
              u === o && (u = null), o = o.return;
            }
            u === o && (u = null), o.sibling.return = o.return, o = o.sibling;
          }
        d & 4 && (d = a.updateQueue, d !== null && (u = d.retryQueue, u !== null && (d.retryQueue = null, Fp(a, u))));
        break;
      case 19:
        Mn(o, a), Dn(a), d & 4 && (d = a.updateQueue, d !== null && (a.updateQueue = null, Fp(a, d)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Mn(o, a), Dn(a);
    }
  }
  function Dn(a) {
    var o = a.flags;
    if (o & 2) {
      try {
        for (var u, d = a.return; d !== null; ) {
          if (P0(d)) {
            u = d;
            break;
          }
          d = d.return;
        }
        if (u == null) throw Error(i(160));
        switch (u.tag) {
          case 27:
            var g = u.stateNode, v = Bp(a);
            jc(a, v, g);
            break;
          case 5:
            var _ = u.stateNode;
            u.flags & 32 && (ds(_, ""), u.flags &= -33);
            var E = Bp(a);
            jc(a, E, _);
            break;
          case 3:
          case 4:
            var R = u.stateNode.containerInfo, F = Bp(a);
            Zp(
              a,
              F,
              R
            );
            break;
          default:
            throw Error(i(161));
        }
      } catch (K) {
        st(a, a.return, K);
      }
      a.flags &= -3;
    }
    o & 4096 && (a.flags &= -4097);
  }
  function q0(a) {
    if (a.subtreeFlags & 1024)
      for (a = a.child; a !== null; ) {
        var o = a;
        q0(o), o.tag === 5 && o.flags & 1024 && o.stateNode.reset(), a = a.sibling;
      }
  }
  function Mi(a, o) {
    if (o.subtreeFlags & 8772)
      for (o = o.child; o !== null; )
        B0(a, o.alternate, o), o = o.sibling;
  }
  function $a(a) {
    for (a = a.child; a !== null; ) {
      var o = a;
      switch (o.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ni(4, o, o.return), $a(o);
          break;
        case 1:
          Mr(o, o.return);
          var u = o.stateNode;
          typeof u.componentWillUnmount == "function" && D0(
            o,
            o.return,
            u
          ), $a(o);
          break;
        case 27:
          wl(o.stateNode);
        case 26:
        case 5:
          Mr(o, o.return), $a(o);
          break;
        case 22:
          o.memoizedState === null && $a(o);
          break;
        case 30:
          $a(o);
          break;
        default:
          $a(o);
      }
      a = a.sibling;
    }
  }
  function Di(a, o, u) {
    for (u = u && (o.subtreeFlags & 8772) !== 0, o = o.child; o !== null; ) {
      var d = o.alternate, g = a, v = o, _ = v.flags;
      switch (v.tag) {
        case 0:
        case 11:
        case 15:
          Di(
            g,
            v,
            u
          ), dl(4, v);
          break;
        case 1:
          if (Di(
            g,
            v,
            u
          ), d = v, g = d.stateNode, typeof g.componentDidMount == "function")
            try {
              g.componentDidMount();
            } catch (F) {
              st(d, d.return, F);
            }
          if (d = v, g = d.updateQueue, g !== null) {
            var E = d.stateNode;
            try {
              var R = g.shared.hiddenCallbacks;
              if (R !== null)
                for (g.shared.hiddenCallbacks = null, g = 0; g < R.length; g++)
                  w_(R[g], E);
            } catch (F) {
              st(d, d.return, F);
            }
          }
          u && _ & 64 && M0(v), fl(v, v.return);
          break;
        case 27:
          U0(v);
        case 26:
        case 5:
          Di(
            g,
            v,
            u
          ), u && d === null && _ & 4 && j0(v), fl(v, v.return);
          break;
        case 12:
          Di(
            g,
            v,
            u
          );
          break;
        case 13:
          Di(
            g,
            v,
            u
          ), u && _ & 4 && F0(g, v);
          break;
        case 22:
          v.memoizedState === null && Di(
            g,
            v,
            u
          ), fl(v, v.return);
          break;
        case 30:
          break;
        default:
          Di(
            g,
            v,
            u
          );
      }
      o = o.sibling;
    }
  }
  function Hp(a, o) {
    var u = null;
    a !== null && a.memoizedState !== null && a.memoizedState.cachePool !== null && (u = a.memoizedState.cachePool.pool), a = null, o.memoizedState !== null && o.memoizedState.cachePool !== null && (a = o.memoizedState.cachePool.pool), a !== u && (a != null && a.refCount++, u != null && Ko(u));
  }
  function qp(a, o) {
    a = null, o.alternate !== null && (a = o.alternate.memoizedState.cache), o = o.memoizedState.cache, o !== a && (o.refCount++, a != null && Ko(a));
  }
  function Dr(a, o, u, d) {
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; )
        G0(
          a,
          o,
          u,
          d
        ), o = o.sibling;
  }
  function G0(a, o, u, d) {
    var g = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        Dr(
          a,
          o,
          u,
          d
        ), g & 2048 && dl(9, o);
        break;
      case 1:
        Dr(
          a,
          o,
          u,
          d
        );
        break;
      case 3:
        Dr(
          a,
          o,
          u,
          d
        ), g & 2048 && (a = null, o.alternate !== null && (a = o.alternate.memoizedState.cache), o = o.memoizedState.cache, o !== a && (o.refCount++, a != null && Ko(a)));
        break;
      case 12:
        if (g & 2048) {
          Dr(
            a,
            o,
            u,
            d
          ), a = o.stateNode;
          try {
            var v = o.memoizedProps, _ = v.id, E = v.onPostCommit;
            typeof E == "function" && E(
              _,
              o.alternate === null ? "mount" : "update",
              a.passiveEffectDuration,
              -0
            );
          } catch (R) {
            st(o, o.return, R);
          }
        } else
          Dr(
            a,
            o,
            u,
            d
          );
        break;
      case 13:
        Dr(
          a,
          o,
          u,
          d
        );
        break;
      case 23:
        break;
      case 22:
        v = o.stateNode, _ = o.alternate, o.memoizedState !== null ? v._visibility & 2 ? Dr(
          a,
          o,
          u,
          d
        ) : hl(a, o) : v._visibility & 2 ? Dr(
          a,
          o,
          u,
          d
        ) : (v._visibility |= 2, Is(
          a,
          o,
          u,
          d,
          (o.subtreeFlags & 10256) !== 0
        )), g & 2048 && Hp(_, o);
        break;
      case 24:
        Dr(
          a,
          o,
          u,
          d
        ), g & 2048 && qp(o.alternate, o);
        break;
      default:
        Dr(
          a,
          o,
          u,
          d
        );
    }
  }
  function Is(a, o, u, d, g) {
    for (g = g && (o.subtreeFlags & 10256) !== 0, o = o.child; o !== null; ) {
      var v = a, _ = o, E = u, R = d, F = _.flags;
      switch (_.tag) {
        case 0:
        case 11:
        case 15:
          Is(
            v,
            _,
            E,
            R,
            g
          ), dl(8, _);
          break;
        case 23:
          break;
        case 22:
          var K = _.stateNode;
          _.memoizedState !== null ? K._visibility & 2 ? Is(
            v,
            _,
            E,
            R,
            g
          ) : hl(
            v,
            _
          ) : (K._visibility |= 2, Is(
            v,
            _,
            E,
            R,
            g
          )), g && F & 2048 && Hp(
            _.alternate,
            _
          );
          break;
        case 24:
          Is(
            v,
            _,
            E,
            R,
            g
          ), g && F & 2048 && qp(_.alternate, _);
          break;
        default:
          Is(
            v,
            _,
            E,
            R,
            g
          );
      }
      o = o.sibling;
    }
  }
  function hl(a, o) {
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; ) {
        var u = a, d = o, g = d.flags;
        switch (d.tag) {
          case 22:
            hl(u, d), g & 2048 && Hp(
              d.alternate,
              d
            );
            break;
          case 24:
            hl(u, d), g & 2048 && qp(d.alternate, d);
            break;
          default:
            hl(u, d);
        }
        o = o.sibling;
      }
  }
  var pl = 8192;
  function Cs(a) {
    if (a.subtreeFlags & pl)
      for (a = a.child; a !== null; )
        Y0(a), a = a.sibling;
  }
  function Y0(a) {
    switch (a.tag) {
      case 26:
        Cs(a), a.flags & pl && a.memoizedState !== null && DP(
          mr,
          a.memoizedState,
          a.memoizedProps
        );
        break;
      case 5:
        Cs(a);
        break;
      case 3:
      case 4:
        var o = mr;
        mr = Xc(a.stateNode.containerInfo), Cs(a), mr = o;
        break;
      case 22:
        a.memoizedState === null && (o = a.alternate, o !== null && o.memoizedState !== null ? (o = pl, pl = 16777216, Cs(a), pl = o) : Cs(a));
        break;
      default:
        Cs(a);
    }
  }
  function J0(a) {
    var o = a.alternate;
    if (o !== null && (a = o.child, a !== null)) {
      o.child = null;
      do
        o = a.sibling, a.sibling = null, a = o;
      while (a !== null);
    }
  }
  function ml(a) {
    var o = a.deletions;
    if ((a.flags & 16) !== 0) {
      if (o !== null)
        for (var u = 0; u < o.length; u++) {
          var d = o[u];
          Yt = d, K0(
            d,
            a
          );
        }
      J0(a);
    }
    if (a.subtreeFlags & 10256)
      for (a = a.child; a !== null; )
        X0(a), a = a.sibling;
  }
  function X0(a) {
    switch (a.tag) {
      case 0:
      case 11:
      case 15:
        ml(a), a.flags & 2048 && Ni(9, a, a.return);
        break;
      case 3:
        ml(a);
        break;
      case 12:
        ml(a);
        break;
      case 22:
        var o = a.stateNode;
        a.memoizedState !== null && o._visibility & 2 && (a.return === null || a.return.tag !== 13) ? (o._visibility &= -3, Pc(a)) : ml(a);
        break;
      default:
        ml(a);
    }
  }
  function Pc(a) {
    var o = a.deletions;
    if ((a.flags & 16) !== 0) {
      if (o !== null)
        for (var u = 0; u < o.length; u++) {
          var d = o[u];
          Yt = d, K0(
            d,
            a
          );
        }
      J0(a);
    }
    for (a = a.child; a !== null; ) {
      switch (o = a, o.tag) {
        case 0:
        case 11:
        case 15:
          Ni(8, o, o.return), Pc(o);
          break;
        case 22:
          u = o.stateNode, u._visibility & 2 && (u._visibility &= -3, Pc(o));
          break;
        default:
          Pc(o);
      }
      a = a.sibling;
    }
  }
  function K0(a, o) {
    for (; Yt !== null; ) {
      var u = Yt;
      switch (u.tag) {
        case 0:
        case 11:
        case 15:
          Ni(8, u, o);
          break;
        case 23:
        case 22:
          if (u.memoizedState !== null && u.memoizedState.cachePool !== null) {
            var d = u.memoizedState.cachePool.pool;
            d != null && d.refCount++;
          }
          break;
        case 24:
          Ko(u.memoizedState.cache);
      }
      if (d = u.child, d !== null) d.return = u, Yt = d;
      else
        e: for (u = a; Yt !== null; ) {
          d = Yt;
          var g = d.sibling, v = d.return;
          if (Z0(d), d === u) {
            Yt = null;
            break e;
          }
          if (g !== null) {
            g.return = v, Yt = g;
            break e;
          }
          Yt = v;
        }
    }
  }
  var W4 = {
    getCacheForType: function(a) {
      var o = rn(Pt), u = o.data.get(a);
      return u === void 0 && (u = a(), o.data.set(a, u)), u;
    }
  }, Q4 = typeof WeakMap == "function" ? WeakMap : Map, et = 0, lt = null, Ze = null, qe = 0, tt = 0, jn = null, ji = !1, Os = !1, Gp = !1, di = 0, Et = 0, Pi = 0, Aa = 0, Yp = 0, ir = 0, Rs = 0, gl = null, Sn = null, Jp = !1, Xp = 0, Uc = 1 / 0, Lc = null, Ui = null, Qt = 0, Li = null, Ns = null, Ms = 0, Kp = 0, Wp = null, W0 = null, vl = 0, Qp = null;
  function Pn() {
    if ((et & 2) !== 0 && qe !== 0)
      return qe & -qe;
    if (L.T !== null) {
      var a = _s;
      return a !== 0 ? a : sm();
    }
    return pw();
  }
  function Q0() {
    ir === 0 && (ir = (qe & 536870912) === 0 || Xe ? cw() : 536870912);
    var a = rr.current;
    return a !== null && (a.flags |= 32), ir;
  }
  function Un(a, o, u) {
    (a === lt && (tt === 2 || tt === 9) || a.cancelPendingCommit !== null) && (Ds(a, 0), Bi(
      a,
      qe,
      ir,
      !1
    )), Mo(a, u), ((et & 2) === 0 || a !== lt) && (a === lt && ((et & 2) === 0 && (Aa |= u), Et === 4 && Bi(
      a,
      qe,
      ir,
      !1
    )), jr(a));
  }
  function eS(a, o, u) {
    if ((et & 6) !== 0) throw Error(i(327));
    var d = !u && (o & 124) === 0 && (o & a.expiredLanes) === 0 || Xn(a, o), g = d ? nP(a, o) : nm(a, o, !0), v = d;
    do {
      if (g === 0) {
        Os && !d && Bi(a, o, 0, !1);
        break;
      } else {
        if (u = a.current.alternate, v && !eP(u)) {
          g = nm(a, o, !1), v = !1;
          continue;
        }
        if (g === 2) {
          if (v = o, a.errorRecoveryDisabledLanes & v)
            var _ = 0;
          else
            _ = a.pendingLanes & -536870913, _ = _ !== 0 ? _ : _ & 536870912 ? 536870912 : 0;
          if (_ !== 0) {
            o = _;
            e: {
              var E = a;
              g = gl;
              var R = E.current.memoizedState.isDehydrated;
              if (R && (Ds(E, _).flags |= 256), _ = nm(
                E,
                _,
                !1
              ), _ !== 2) {
                if (Gp && !R) {
                  E.errorRecoveryDisabledLanes |= v, Aa |= v, g = 4;
                  break e;
                }
                v = Sn, Sn = g, v !== null && (Sn === null ? Sn = v : Sn.push.apply(
                  Sn,
                  v
                ));
              }
              g = _;
            }
            if (v = !1, g !== 2) continue;
          }
        }
        if (g === 1) {
          Ds(a, 0), Bi(a, o, 0, !0);
          break;
        }
        e: {
          switch (d = a, v = g, v) {
            case 0:
            case 1:
              throw Error(i(345));
            case 4:
              if ((o & 4194048) !== o) break;
            case 6:
              Bi(
                d,
                o,
                ir,
                !ji
              );
              break e;
            case 2:
              Sn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(i(329));
          }
          if ((o & 62914560) === o && (g = Xp + 300 - In(), 10 < g)) {
            if (Bi(
              d,
              o,
              ir,
              !ji
            ), Ht(d, 0, !0) !== 0) break e;
            d.timeoutHandle = zS(
              tS.bind(
                null,
                d,
                u,
                Sn,
                Lc,
                Jp,
                o,
                ir,
                Aa,
                Rs,
                ji,
                v,
                2,
                -0,
                0
              ),
              g
            );
            break e;
          }
          tS(
            d,
            u,
            Sn,
            Lc,
            Jp,
            o,
            ir,
            Aa,
            Rs,
            ji,
            v,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    jr(a);
  }
  function tS(a, o, u, d, g, v, _, E, R, F, K, ee, q, G) {
    if (a.timeoutHandle = -1, ee = o.subtreeFlags, (ee & 8192 || (ee & 16785408) === 16785408) && (kl = { stylesheets: null, count: 0, unsuspend: MP }, Y0(o), ee = jP(), ee !== null)) {
      a.cancelPendingCommit = ee(
        lS.bind(
          null,
          a,
          o,
          v,
          u,
          d,
          g,
          _,
          E,
          R,
          K,
          1,
          q,
          G
        )
      ), Bi(a, v, _, !F);
      return;
    }
    lS(
      a,
      o,
      v,
      u,
      d,
      g,
      _,
      E,
      R
    );
  }
  function eP(a) {
    for (var o = a; ; ) {
      var u = o.tag;
      if ((u === 0 || u === 11 || u === 15) && o.flags & 16384 && (u = o.updateQueue, u !== null && (u = u.stores, u !== null)))
        for (var d = 0; d < u.length; d++) {
          var g = u[d], v = g.getSnapshot;
          g = g.value;
          try {
            if (!Rn(v(), g)) return !1;
          } catch {
            return !1;
          }
        }
      if (u = o.child, o.subtreeFlags & 16384 && u !== null)
        u.return = o, o = u;
      else {
        if (o === a) break;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === a) return !0;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
    }
    return !0;
  }
  function Bi(a, o, u, d) {
    o &= ~Yp, o &= ~Aa, a.suspendedLanes |= o, a.pingedLanes &= ~o, d && (a.warmLanes |= o), d = a.expirationTimes;
    for (var g = o; 0 < g; ) {
      var v = 31 - $e(g), _ = 1 << v;
      d[v] = -1, g &= ~_;
    }
    u !== 0 && fw(a, u, o);
  }
  function Bc() {
    return (et & 6) === 0 ? (yl(0), !1) : !0;
  }
  function em() {
    if (Ze !== null) {
      if (tt === 0)
        var a = Ze.return;
      else
        a = Ze, ri = _a = null, vp(a), As = null, ll = 0, a = Ze;
      for (; a !== null; )
        N0(a.alternate, a), a = a.return;
      Ze = null;
    }
  }
  function Ds(a, o) {
    var u = a.timeoutHandle;
    u !== -1 && (a.timeoutHandle = -1, yP(u)), u = a.cancelPendingCommit, u !== null && (a.cancelPendingCommit = null, u()), em(), lt = a, Ze = u = ei(a.current, null), qe = o, tt = 0, jn = null, ji = !1, Os = Xn(a, o), Gp = !1, Rs = ir = Yp = Aa = Pi = Et = 0, Sn = gl = null, Jp = !1, (o & 8) !== 0 && (o |= o & 32);
    var d = a.entangledLanes;
    if (d !== 0)
      for (a = a.entanglements, d &= o; 0 < d; ) {
        var g = 31 - $e(d), v = 1 << g;
        o |= a[g], d &= ~v;
      }
    return di = o, uc(), u;
  }
  function nS(a, o) {
    Ue = null, L.H = Ac, o === Qo || o === yc ? (o = b_(), tt = 3) : o === g_ ? (o = b_(), tt = 4) : tt = o === x0 ? 8 : o !== null && typeof o == "object" && typeof o.then == "function" ? 6 : 1, jn = o, Ze === null && (Et = 1, Rc(
      a,
      Qn(o, a.current)
    ));
  }
  function rS() {
    var a = L.H;
    return L.H = Ac, a === null ? Ac : a;
  }
  function iS() {
    var a = L.A;
    return L.A = W4, a;
  }
  function tm() {
    Et = 4, ji || (qe & 4194048) !== qe && rr.current !== null || (Os = !0), (Pi & 134217727) === 0 && (Aa & 134217727) === 0 || lt === null || Bi(
      lt,
      qe,
      ir,
      !1
    );
  }
  function nm(a, o, u) {
    var d = et;
    et |= 2;
    var g = rS(), v = iS();
    (lt !== a || qe !== o) && (Lc = null, Ds(a, o)), o = !1;
    var _ = Et;
    e: do
      try {
        if (tt !== 0 && Ze !== null) {
          var E = Ze, R = jn;
          switch (tt) {
            case 8:
              em(), _ = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              rr.current === null && (o = !0);
              var F = tt;
              if (tt = 0, jn = null, js(a, E, R, F), u && Os) {
                _ = 0;
                break e;
              }
              break;
            default:
              F = tt, tt = 0, jn = null, js(a, E, R, F);
          }
        }
        tP(), _ = Et;
        break;
      } catch (K) {
        nS(a, K);
      }
    while (!0);
    return o && a.shellSuspendCounter++, ri = _a = null, et = d, L.H = g, L.A = v, Ze === null && (lt = null, qe = 0, uc()), _;
  }
  function tP() {
    for (; Ze !== null; ) aS(Ze);
  }
  function nP(a, o) {
    var u = et;
    et |= 2;
    var d = rS(), g = iS();
    lt !== a || qe !== o ? (Lc = null, Uc = In() + 500, Ds(a, o)) : Os = Xn(
      a,
      o
    );
    e: do
      try {
        if (tt !== 0 && Ze !== null) {
          o = Ze;
          var v = jn;
          t: switch (tt) {
            case 1:
              tt = 0, jn = null, js(a, o, v, 1);
              break;
            case 2:
            case 9:
              if (v_(v)) {
                tt = 0, jn = null, sS(o);
                break;
              }
              o = function() {
                tt !== 2 && tt !== 9 || lt !== a || (tt = 7), jr(a);
              }, v.then(o, o);
              break e;
            case 3:
              tt = 7;
              break e;
            case 4:
              tt = 5;
              break e;
            case 7:
              v_(v) ? (tt = 0, jn = null, sS(o)) : (tt = 0, jn = null, js(a, o, v, 7));
              break;
            case 5:
              var _ = null;
              switch (Ze.tag) {
                case 26:
                  _ = Ze.memoizedState;
                case 5:
                case 27:
                  var E = Ze;
                  if (!_ || BS(_)) {
                    tt = 0, jn = null;
                    var R = E.sibling;
                    if (R !== null) Ze = R;
                    else {
                      var F = E.return;
                      F !== null ? (Ze = F, Zc(F)) : Ze = null;
                    }
                    break t;
                  }
              }
              tt = 0, jn = null, js(a, o, v, 5);
              break;
            case 6:
              tt = 0, jn = null, js(a, o, v, 6);
              break;
            case 8:
              em(), Et = 6;
              break e;
            default:
              throw Error(i(462));
          }
        }
        rP();
        break;
      } catch (K) {
        nS(a, K);
      }
    while (!0);
    return ri = _a = null, L.H = d, L.A = g, et = u, Ze !== null ? 0 : (lt = null, qe = 0, uc(), Et);
  }
  function rP() {
    for (; Ze !== null && !Ju(); )
      aS(Ze);
  }
  function aS(a) {
    var o = O0(a.alternate, a, di);
    a.memoizedProps = a.pendingProps, o === null ? Zc(a) : Ze = o;
  }
  function sS(a) {
    var o = a, u = o.alternate;
    switch (o.tag) {
      case 15:
      case 0:
        o = E0(
          u,
          o,
          o.pendingProps,
          o.type,
          void 0,
          qe
        );
        break;
      case 11:
        o = E0(
          u,
          o,
          o.pendingProps,
          o.type.render,
          o.ref,
          qe
        );
        break;
      case 5:
        vp(o);
      default:
        N0(u, o), o = Ze = o_(o, di), o = O0(u, o, di);
    }
    a.memoizedProps = a.pendingProps, o === null ? Zc(a) : Ze = o;
  }
  function js(a, o, u, d) {
    ri = _a = null, vp(o), As = null, ll = 0;
    var g = o.return;
    try {
      if (q4(
        a,
        g,
        o,
        u,
        qe
      )) {
        Et = 1, Rc(
          a,
          Qn(u, a.current)
        ), Ze = null;
        return;
      }
    } catch (v) {
      if (g !== null) throw Ze = g, v;
      Et = 1, Rc(
        a,
        Qn(u, a.current)
      ), Ze = null;
      return;
    }
    o.flags & 32768 ? (Xe || d === 1 ? a = !0 : Os || (qe & 536870912) !== 0 ? a = !1 : (ji = a = !0, (d === 2 || d === 9 || d === 3 || d === 6) && (d = rr.current, d !== null && d.tag === 13 && (d.flags |= 16384))), oS(o, a)) : Zc(o);
  }
  function Zc(a) {
    var o = a;
    do {
      if ((o.flags & 32768) !== 0) {
        oS(
          o,
          ji
        );
        return;
      }
      a = o.return;
      var u = Y4(
        o.alternate,
        o,
        di
      );
      if (u !== null) {
        Ze = u;
        return;
      }
      if (o = o.sibling, o !== null) {
        Ze = o;
        return;
      }
      Ze = o = a;
    } while (o !== null);
    Et === 0 && (Et = 5);
  }
  function oS(a, o) {
    do {
      var u = J4(a.alternate, a);
      if (u !== null) {
        u.flags &= 32767, Ze = u;
        return;
      }
      if (u = a.return, u !== null && (u.flags |= 32768, u.subtreeFlags = 0, u.deletions = null), !o && (a = a.sibling, a !== null)) {
        Ze = a;
        return;
      }
      Ze = a = u;
    } while (a !== null);
    Et = 6, Ze = null;
  }
  function lS(a, o, u, d, g, v, _, E, R) {
    a.cancelPendingCommit = null;
    do
      Vc();
    while (Qt !== 0);
    if ((et & 6) !== 0) throw Error(i(327));
    if (o !== null) {
      if (o === a.current) throw Error(i(177));
      if (v = o.lanes | o.childLanes, v |= qh, Mj(
        a,
        u,
        v,
        _,
        E,
        R
      ), a === lt && (Ze = lt = null, qe = 0), Ns = o, Li = a, Ms = u, Kp = v, Wp = g, W0 = d, (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? (a.callbackNode = null, a.callbackPriority = 0, oP(rs, function() {
        return hS(), null;
      })) : (a.callbackNode = null, a.callbackPriority = 0), d = (o.flags & 13878) !== 0, (o.subtreeFlags & 13878) !== 0 || d) {
        d = L.T, L.T = null, g = Y.p, Y.p = 2, _ = et, et |= 4;
        try {
          X4(a, o, u);
        } finally {
          et = _, Y.p = g, L.T = d;
        }
      }
      Qt = 1, uS(), cS(), dS();
    }
  }
  function uS() {
    if (Qt === 1) {
      Qt = 0;
      var a = Li, o = Ns, u = (o.flags & 13878) !== 0;
      if ((o.subtreeFlags & 13878) !== 0 || u) {
        u = L.T, L.T = null;
        var d = Y.p;
        Y.p = 2;
        var g = et;
        et |= 4;
        try {
          H0(o, a);
          var v = pm, _ = Kw(a.containerInfo), E = v.focusedElem, R = v.selectionRange;
          if (_ !== E && E && E.ownerDocument && Xw(
            E.ownerDocument.documentElement,
            E
          )) {
            if (R !== null && Bh(E)) {
              var F = R.start, K = R.end;
              if (K === void 0 && (K = F), "selectionStart" in E)
                E.selectionStart = F, E.selectionEnd = Math.min(
                  K,
                  E.value.length
                );
              else {
                var ee = E.ownerDocument || document, q = ee && ee.defaultView || window;
                if (q.getSelection) {
                  var G = q.getSelection(), Ae = E.textContent.length, ke = Math.min(R.start, Ae), at = R.end === void 0 ? ke : Math.min(R.end, Ae);
                  !G.extend && ke > at && (_ = at, at = ke, ke = _);
                  var P = Jw(
                    E,
                    ke
                  ), j = Jw(
                    E,
                    at
                  );
                  if (P && j && (G.rangeCount !== 1 || G.anchorNode !== P.node || G.anchorOffset !== P.offset || G.focusNode !== j.node || G.focusOffset !== j.offset)) {
                    var V = ee.createRange();
                    V.setStart(P.node, P.offset), G.removeAllRanges(), ke > at ? (G.addRange(V), G.extend(j.node, j.offset)) : (V.setEnd(j.node, j.offset), G.addRange(V));
                  }
                }
              }
            }
            for (ee = [], G = E; G = G.parentNode; )
              G.nodeType === 1 && ee.push({
                element: G,
                left: G.scrollLeft,
                top: G.scrollTop
              });
            for (typeof E.focus == "function" && E.focus(), E = 0; E < ee.length; E++) {
              var Q = ee[E];
              Q.element.scrollLeft = Q.left, Q.element.scrollTop = Q.top;
            }
          }
          td = !!hm, pm = hm = null;
        } finally {
          et = g, Y.p = d, L.T = u;
        }
      }
      a.current = o, Qt = 2;
    }
  }
  function cS() {
    if (Qt === 2) {
      Qt = 0;
      var a = Li, o = Ns, u = (o.flags & 8772) !== 0;
      if ((o.subtreeFlags & 8772) !== 0 || u) {
        u = L.T, L.T = null;
        var d = Y.p;
        Y.p = 2;
        var g = et;
        et |= 4;
        try {
          B0(a, o.alternate, o);
        } finally {
          et = g, Y.p = d, L.T = u;
        }
      }
      Qt = 3;
    }
  }
  function dS() {
    if (Qt === 4 || Qt === 3) {
      Qt = 0, Xu();
      var a = Li, o = Ns, u = Ms, d = W0;
      (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? Qt = 5 : (Qt = 0, Ns = Li = null, fS(a, a.pendingLanes));
      var g = a.pendingLanes;
      if (g === 0 && (Ui = null), xh(u), o = o.stateNode, oe && typeof oe.onCommitFiberRoot == "function")
        try {
          oe.onCommitFiberRoot(
            J,
            o,
            void 0,
            (o.current.flags & 128) === 128
          );
        } catch {
        }
      if (d !== null) {
        o = L.T, g = Y.p, Y.p = 2, L.T = null;
        try {
          for (var v = a.onRecoverableError, _ = 0; _ < d.length; _++) {
            var E = d[_];
            v(E.value, {
              componentStack: E.stack
            });
          }
        } finally {
          L.T = o, Y.p = g;
        }
      }
      (Ms & 3) !== 0 && Vc(), jr(a), g = a.pendingLanes, (u & 4194090) !== 0 && (g & 42) !== 0 ? a === Qp ? vl++ : (vl = 0, Qp = a) : vl = 0, yl(0);
    }
  }
  function fS(a, o) {
    (a.pooledCacheLanes &= o) === 0 && (o = a.pooledCache, o != null && (a.pooledCache = null, Ko(o)));
  }
  function Vc(a) {
    return uS(), cS(), dS(), hS();
  }
  function hS() {
    if (Qt !== 5) return !1;
    var a = Li, o = Kp;
    Kp = 0;
    var u = xh(Ms), d = L.T, g = Y.p;
    try {
      Y.p = 32 > u ? 32 : u, L.T = null, u = Wp, Wp = null;
      var v = Li, _ = Ms;
      if (Qt = 0, Ns = Li = null, Ms = 0, (et & 6) !== 0) throw Error(i(331));
      var E = et;
      if (et |= 4, X0(v.current), G0(
        v,
        v.current,
        _,
        u
      ), et = E, yl(0, !1), oe && typeof oe.onPostCommitFiberRoot == "function")
        try {
          oe.onPostCommitFiberRoot(J, v);
        } catch {
        }
      return !0;
    } finally {
      Y.p = g, L.T = d, fS(a, o);
    }
  }
  function pS(a, o, u) {
    o = Qn(u, o), o = Cp(a.stateNode, o, 2), a = Ii(a, o, 2), a !== null && (Mo(a, 2), jr(a));
  }
  function st(a, o, u) {
    if (a.tag === 3)
      pS(a, a, u);
    else
      for (; o !== null; ) {
        if (o.tag === 3) {
          pS(
            o,
            a,
            u
          );
          break;
        } else if (o.tag === 1) {
          var d = o.stateNode;
          if (typeof o.type.getDerivedStateFromError == "function" || typeof d.componentDidCatch == "function" && (Ui === null || !Ui.has(d))) {
            a = Qn(u, a), u = y0(2), d = Ii(o, u, 2), d !== null && (b0(
              u,
              d,
              o,
              a
            ), Mo(d, 2), jr(d));
            break;
          }
        }
        o = o.return;
      }
  }
  function rm(a, o, u) {
    var d = a.pingCache;
    if (d === null) {
      d = a.pingCache = new Q4();
      var g = /* @__PURE__ */ new Set();
      d.set(o, g);
    } else
      g = d.get(o), g === void 0 && (g = /* @__PURE__ */ new Set(), d.set(o, g));
    g.has(u) || (Gp = !0, g.add(u), a = iP.bind(null, a, o, u), o.then(a, a));
  }
  function iP(a, o, u) {
    var d = a.pingCache;
    d !== null && d.delete(o), a.pingedLanes |= a.suspendedLanes & u, a.warmLanes &= ~u, lt === a && (qe & u) === u && (Et === 4 || Et === 3 && (qe & 62914560) === qe && 300 > In() - Xp ? (et & 2) === 0 && Ds(a, 0) : Yp |= u, Rs === qe && (Rs = 0)), jr(a);
  }
  function mS(a, o) {
    o === 0 && (o = dw()), a = ys(a, o), a !== null && (Mo(a, o), jr(a));
  }
  function aP(a) {
    var o = a.memoizedState, u = 0;
    o !== null && (u = o.retryLane), mS(a, u);
  }
  function sP(a, o) {
    var u = 0;
    switch (a.tag) {
      case 13:
        var d = a.stateNode, g = a.memoizedState;
        g !== null && (u = g.retryLane);
        break;
      case 19:
        d = a.stateNode;
        break;
      case 22:
        d = a.stateNode._retryCache;
        break;
      default:
        throw Error(i(314));
    }
    d !== null && d.delete(o), mS(a, u);
  }
  function oP(a, o) {
    return Cr(a, o);
  }
  var Fc = null, Ps = null, im = !1, Hc = !1, am = !1, za = 0;
  function jr(a) {
    a !== Ps && a.next === null && (Ps === null ? Fc = Ps = a : Ps = Ps.next = a), Hc = !0, im || (im = !0, uP());
  }
  function yl(a, o) {
    if (!am && Hc) {
      am = !0;
      do
        for (var u = !1, d = Fc; d !== null; ) {
          if (a !== 0) {
            var g = d.pendingLanes;
            if (g === 0) var v = 0;
            else {
              var _ = d.suspendedLanes, E = d.pingedLanes;
              v = (1 << 31 - $e(42 | a) + 1) - 1, v &= g & ~(_ & ~E), v = v & 201326741 ? v & 201326741 | 1 : v ? v | 2 : 0;
            }
            v !== 0 && (u = !0, bS(d, v));
          } else
            v = qe, v = Ht(
              d,
              d === lt ? v : 0,
              d.cancelPendingCommit !== null || d.timeoutHandle !== -1
            ), (v & 3) === 0 || Xn(d, v) || (u = !0, bS(d, v));
          d = d.next;
        }
      while (u);
      am = !1;
    }
  }
  function lP() {
    gS();
  }
  function gS() {
    Hc = im = !1;
    var a = 0;
    za !== 0 && (vP() && (a = za), za = 0);
    for (var o = In(), u = null, d = Fc; d !== null; ) {
      var g = d.next, v = vS(d, o);
      v === 0 ? (d.next = null, u === null ? Fc = g : u.next = g, g === null && (Ps = u)) : (u = d, (a !== 0 || (v & 3) !== 0) && (Hc = !0)), d = g;
    }
    yl(a);
  }
  function vS(a, o) {
    for (var u = a.suspendedLanes, d = a.pingedLanes, g = a.expirationTimes, v = a.pendingLanes & -62914561; 0 < v; ) {
      var _ = 31 - $e(v), E = 1 << _, R = g[_];
      R === -1 ? ((E & u) === 0 || (E & d) !== 0) && (g[_] = hr(E, o)) : R <= o && (a.expiredLanes |= E), v &= ~E;
    }
    if (o = lt, u = qe, u = Ht(
      a,
      a === o ? u : 0,
      a.cancelPendingCommit !== null || a.timeoutHandle !== -1
    ), d = a.callbackNode, u === 0 || a === o && (tt === 2 || tt === 9) || a.cancelPendingCommit !== null)
      return d !== null && d !== null && Oo(d), a.callbackNode = null, a.callbackPriority = 0;
    if ((u & 3) === 0 || Xn(a, u)) {
      if (o = u & -u, o === a.callbackPriority) return o;
      switch (d !== null && Oo(d), xh(u)) {
        case 2:
        case 8:
          u = No;
          break;
        case 32:
          u = rs;
          break;
        case 268435456:
          u = Ku;
          break;
        default:
          u = rs;
      }
      return d = yS.bind(null, a), u = Cr(u, d), a.callbackPriority = o, a.callbackNode = u, o;
    }
    return d !== null && d !== null && Oo(d), a.callbackPriority = 2, a.callbackNode = null, 2;
  }
  function yS(a, o) {
    if (Qt !== 0 && Qt !== 5)
      return a.callbackNode = null, a.callbackPriority = 0, null;
    var u = a.callbackNode;
    if (Vc() && a.callbackNode !== u)
      return null;
    var d = qe;
    return d = Ht(
      a,
      a === lt ? d : 0,
      a.cancelPendingCommit !== null || a.timeoutHandle !== -1
    ), d === 0 ? null : (eS(a, d, o), vS(a, In()), a.callbackNode != null && a.callbackNode === u ? yS.bind(null, a) : null);
  }
  function bS(a, o) {
    if (Vc()) return null;
    eS(a, o, !0);
  }
  function uP() {
    bP(function() {
      (et & 6) !== 0 ? Cr(
        Ro,
        lP
      ) : gS();
    });
  }
  function sm() {
    return za === 0 && (za = cw()), za;
  }
  function xS(a) {
    return a == null || typeof a == "symbol" || typeof a == "boolean" ? null : typeof a == "function" ? a : nc("" + a);
  }
  function wS(a, o) {
    var u = o.ownerDocument.createElement("input");
    return u.name = o.name, u.value = o.value, a.id && u.setAttribute("form", a.id), o.parentNode.insertBefore(u, o), a = new FormData(a), u.parentNode.removeChild(u), a;
  }
  function cP(a, o, u, d, g) {
    if (o === "submit" && u && u.stateNode === g) {
      var v = xS(
        (g[bn] || null).action
      ), _ = d.submitter;
      _ && (o = (o = _[bn] || null) ? xS(o.formAction) : _.getAttribute("formAction"), o !== null && (v = o, _ = null));
      var E = new sc(
        "action",
        "action",
        null,
        d,
        g
      );
      a.push({
        event: E,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (d.defaultPrevented) {
                if (za !== 0) {
                  var R = _ ? wS(g, _) : new FormData(g);
                  Ep(
                    u,
                    {
                      pending: !0,
                      data: R,
                      method: g.method,
                      action: v
                    },
                    null,
                    R
                  );
                }
              } else
                typeof v == "function" && (E.preventDefault(), R = _ ? wS(g, _) : new FormData(g), Ep(
                  u,
                  {
                    pending: !0,
                    data: R,
                    method: g.method,
                    action: v
                  },
                  v,
                  R
                ));
            },
            currentTarget: g
          }
        ]
      });
    }
  }
  for (var om = 0; om < Hh.length; om++) {
    var lm = Hh[om], dP = lm.toLowerCase(), fP = lm[0].toUpperCase() + lm.slice(1);
    pr(
      dP,
      "on" + fP
    );
  }
  pr(e_, "onAnimationEnd"), pr(t_, "onAnimationIteration"), pr(n_, "onAnimationStart"), pr("dblclick", "onDoubleClick"), pr("focusin", "onFocus"), pr("focusout", "onBlur"), pr(z4, "onTransitionRun"), pr(I4, "onTransitionStart"), pr(C4, "onTransitionCancel"), pr(r_, "onTransitionEnd"), ls("onMouseEnter", ["mouseout", "mouseover"]), ls("onMouseLeave", ["mouseout", "mouseover"]), ls("onPointerEnter", ["pointerout", "pointerover"]), ls("onPointerLeave", ["pointerout", "pointerover"]), ha(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), ha(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), ha("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), ha(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), ha(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), ha(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var bl = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), hP = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(bl)
  );
  function _S(a, o) {
    o = (o & 4) !== 0;
    for (var u = 0; u < a.length; u++) {
      var d = a[u], g = d.event;
      d = d.listeners;
      e: {
        var v = void 0;
        if (o)
          for (var _ = d.length - 1; 0 <= _; _--) {
            var E = d[_], R = E.instance, F = E.currentTarget;
            if (E = E.listener, R !== v && g.isPropagationStopped())
              break e;
            v = E, g.currentTarget = F;
            try {
              v(g);
            } catch (K) {
              Oc(K);
            }
            g.currentTarget = null, v = R;
          }
        else
          for (_ = 0; _ < d.length; _++) {
            if (E = d[_], R = E.instance, F = E.currentTarget, E = E.listener, R !== v && g.isPropagationStopped())
              break e;
            v = E, g.currentTarget = F;
            try {
              v(g);
            } catch (K) {
              Oc(K);
            }
            g.currentTarget = null, v = R;
          }
      }
    }
  }
  function Ve(a, o) {
    var u = o[wh];
    u === void 0 && (u = o[wh] = /* @__PURE__ */ new Set());
    var d = a + "__bubble";
    u.has(d) || (SS(o, a, 2, !1), u.add(d));
  }
  function um(a, o, u) {
    var d = 0;
    o && (d |= 4), SS(
      u,
      a,
      d,
      o
    );
  }
  var qc = "_reactListening" + Math.random().toString(36).slice(2);
  function cm(a) {
    if (!a[qc]) {
      a[qc] = !0, gw.forEach(function(u) {
        u !== "selectionchange" && (hP.has(u) || um(u, !1, a), um(u, !0, a));
      });
      var o = a.nodeType === 9 ? a : a.ownerDocument;
      o === null || o[qc] || (o[qc] = !0, um("selectionchange", !1, o));
    }
  }
  function SS(a, o, u, d) {
    switch (GS(o)) {
      case 2:
        var g = LP;
        break;
      case 8:
        g = BP;
        break;
      default:
        g = km;
    }
    u = g.bind(
      null,
      o,
      u,
      a
    ), g = void 0, !Oh || o !== "touchstart" && o !== "touchmove" && o !== "wheel" || (g = !0), d ? g !== void 0 ? a.addEventListener(o, u, {
      capture: !0,
      passive: g
    }) : a.addEventListener(o, u, !0) : g !== void 0 ? a.addEventListener(o, u, {
      passive: g
    }) : a.addEventListener(o, u, !1);
  }
  function dm(a, o, u, d, g) {
    var v = d;
    if ((o & 1) === 0 && (o & 2) === 0 && d !== null)
      e: for (; ; ) {
        if (d === null) return;
        var _ = d.tag;
        if (_ === 3 || _ === 4) {
          var E = d.stateNode.containerInfo;
          if (E === g) break;
          if (_ === 4)
            for (_ = d.return; _ !== null; ) {
              var R = _.tag;
              if ((R === 3 || R === 4) && _.stateNode.containerInfo === g)
                return;
              _ = _.return;
            }
          for (; E !== null; ) {
            if (_ = as(E), _ === null) return;
            if (R = _.tag, R === 5 || R === 6 || R === 26 || R === 27) {
              d = v = _;
              continue e;
            }
            E = E.parentNode;
          }
        }
        d = d.return;
      }
    Iw(function() {
      var F = v, K = Ih(u), ee = [];
      e: {
        var q = i_.get(a);
        if (q !== void 0) {
          var G = sc, Ae = a;
          switch (a) {
            case "keypress":
              if (ic(u) === 0) break e;
            case "keydown":
            case "keyup":
              G = o4;
              break;
            case "focusin":
              Ae = "focus", G = Dh;
              break;
            case "focusout":
              Ae = "blur", G = Dh;
              break;
            case "beforeblur":
            case "afterblur":
              G = Dh;
              break;
            case "click":
              if (u.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              G = Rw;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              G = Jj;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              G = c4;
              break;
            case e_:
            case t_:
            case n_:
              G = Wj;
              break;
            case r_:
              G = f4;
              break;
            case "scroll":
            case "scrollend":
              G = Gj;
              break;
            case "wheel":
              G = p4;
              break;
            case "copy":
            case "cut":
            case "paste":
              G = e4;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              G = Mw;
              break;
            case "toggle":
            case "beforetoggle":
              G = g4;
          }
          var ke = (o & 4) !== 0, at = !ke && (a === "scroll" || a === "scrollend"), P = ke ? q !== null ? q + "Capture" : null : q;
          ke = [];
          for (var j = F, V; j !== null; ) {
            var Q = j;
            if (V = Q.stateNode, Q = Q.tag, Q !== 5 && Q !== 26 && Q !== 27 || V === null || P === null || (Q = Po(j, P), Q != null && ke.push(
              xl(j, Q, V)
            )), at) break;
            j = j.return;
          }
          0 < ke.length && (q = new G(
            q,
            Ae,
            null,
            u,
            K
          ), ee.push({ event: q, listeners: ke }));
        }
      }
      if ((o & 7) === 0) {
        e: {
          if (q = a === "mouseover" || a === "pointerover", G = a === "mouseout" || a === "pointerout", q && u !== zh && (Ae = u.relatedTarget || u.fromElement) && (as(Ae) || Ae[is]))
            break e;
          if ((G || q) && (q = K.window === K ? K : (q = K.ownerDocument) ? q.defaultView || q.parentWindow : window, G ? (Ae = u.relatedTarget || u.toElement, G = F, Ae = Ae ? as(Ae) : null, Ae !== null && (at = s(Ae), ke = Ae.tag, Ae !== at || ke !== 5 && ke !== 27 && ke !== 6) && (Ae = null)) : (G = null, Ae = F), G !== Ae)) {
            if (ke = Rw, Q = "onMouseLeave", P = "onMouseEnter", j = "mouse", (a === "pointerout" || a === "pointerover") && (ke = Mw, Q = "onPointerLeave", P = "onPointerEnter", j = "pointer"), at = G == null ? q : jo(G), V = Ae == null ? q : jo(Ae), q = new ke(
              Q,
              j + "leave",
              G,
              u,
              K
            ), q.target = at, q.relatedTarget = V, Q = null, as(K) === F && (ke = new ke(
              P,
              j + "enter",
              Ae,
              u,
              K
            ), ke.target = V, ke.relatedTarget = at, Q = ke), at = Q, G && Ae)
              t: {
                for (ke = G, P = Ae, j = 0, V = ke; V; V = Us(V))
                  j++;
                for (V = 0, Q = P; Q; Q = Us(Q))
                  V++;
                for (; 0 < j - V; )
                  ke = Us(ke), j--;
                for (; 0 < V - j; )
                  P = Us(P), V--;
                for (; j--; ) {
                  if (ke === P || P !== null && ke === P.alternate)
                    break t;
                  ke = Us(ke), P = Us(P);
                }
                ke = null;
              }
            else ke = null;
            G !== null && kS(
              ee,
              q,
              G,
              ke,
              !1
            ), Ae !== null && at !== null && kS(
              ee,
              at,
              Ae,
              ke,
              !0
            );
          }
        }
        e: {
          if (q = F ? jo(F) : window, G = q.nodeName && q.nodeName.toLowerCase(), G === "select" || G === "input" && q.type === "file")
            var ve = Vw;
          else if (Bw(q))
            if (Fw)
              ve = E4;
            else {
              ve = k4;
              var Be = S4;
            }
          else
            G = q.nodeName, !G || G.toLowerCase() !== "input" || q.type !== "checkbox" && q.type !== "radio" ? F && Ah(F.elementType) && (ve = Vw) : ve = T4;
          if (ve && (ve = ve(a, F))) {
            Zw(
              ee,
              ve,
              u,
              K
            );
            break e;
          }
          Be && Be(a, q, F), a === "focusout" && F && q.type === "number" && F.memoizedProps.value != null && $h(q, "number", q.value);
        }
        switch (Be = F ? jo(F) : window, a) {
          case "focusin":
            (Bw(Be) || Be.contentEditable === "true") && (ms = Be, Zh = F, qo = null);
            break;
          case "focusout":
            qo = Zh = ms = null;
            break;
          case "mousedown":
            Vh = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Vh = !1, Ww(ee, u, K);
            break;
          case "selectionchange":
            if (A4) break;
          case "keydown":
          case "keyup":
            Ww(ee, u, K);
        }
        var we;
        if (Ph)
          e: {
            switch (a) {
              case "compositionstart":
                var Te = "onCompositionStart";
                break e;
              case "compositionend":
                Te = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Te = "onCompositionUpdate";
                break e;
            }
            Te = void 0;
          }
        else
          ps ? Uw(a, u) && (Te = "onCompositionEnd") : a === "keydown" && u.keyCode === 229 && (Te = "onCompositionStart");
        Te && (Dw && u.locale !== "ko" && (ps || Te !== "onCompositionStart" ? Te === "onCompositionEnd" && ps && (we = Cw()) : (Ei = K, Rh = "value" in Ei ? Ei.value : Ei.textContent, ps = !0)), Be = Gc(F, Te), 0 < Be.length && (Te = new Nw(
          Te,
          a,
          null,
          u,
          K
        ), ee.push({ event: Te, listeners: Be }), we ? Te.data = we : (we = Lw(u), we !== null && (Te.data = we)))), (we = y4 ? b4(a, u) : x4(a, u)) && (Te = Gc(F, "onBeforeInput"), 0 < Te.length && (Be = new Nw(
          "onBeforeInput",
          "beforeinput",
          null,
          u,
          K
        ), ee.push({
          event: Be,
          listeners: Te
        }), Be.data = we)), cP(
          ee,
          a,
          F,
          u,
          K
        );
      }
      _S(ee, o);
    });
  }
  function xl(a, o, u) {
    return {
      instance: a,
      listener: o,
      currentTarget: u
    };
  }
  function Gc(a, o) {
    for (var u = o + "Capture", d = []; a !== null; ) {
      var g = a, v = g.stateNode;
      if (g = g.tag, g !== 5 && g !== 26 && g !== 27 || v === null || (g = Po(a, u), g != null && d.unshift(
        xl(a, g, v)
      ), g = Po(a, o), g != null && d.push(
        xl(a, g, v)
      )), a.tag === 3) return d;
      a = a.return;
    }
    return [];
  }
  function Us(a) {
    if (a === null) return null;
    do
      a = a.return;
    while (a && a.tag !== 5 && a.tag !== 27);
    return a || null;
  }
  function kS(a, o, u, d, g) {
    for (var v = o._reactName, _ = []; u !== null && u !== d; ) {
      var E = u, R = E.alternate, F = E.stateNode;
      if (E = E.tag, R !== null && R === d) break;
      E !== 5 && E !== 26 && E !== 27 || F === null || (R = F, g ? (F = Po(u, v), F != null && _.unshift(
        xl(u, F, R)
      )) : g || (F = Po(u, v), F != null && _.push(
        xl(u, F, R)
      ))), u = u.return;
    }
    _.length !== 0 && a.push({ event: o, listeners: _ });
  }
  var pP = /\r\n?/g, mP = /\u0000|\uFFFD/g;
  function TS(a) {
    return (typeof a == "string" ? a : "" + a).replace(pP, `
`).replace(mP, "");
  }
  function ES(a, o) {
    return o = TS(o), TS(a) === o;
  }
  function Yc() {
  }
  function it(a, o, u, d, g, v) {
    switch (u) {
      case "children":
        typeof d == "string" ? o === "body" || o === "textarea" && d === "" || ds(a, d) : (typeof d == "number" || typeof d == "bigint") && o !== "body" && ds(a, "" + d);
        break;
      case "className":
        Qu(a, "class", d);
        break;
      case "tabIndex":
        Qu(a, "tabindex", d);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Qu(a, u, d);
        break;
      case "style":
        Aw(a, d, v);
        break;
      case "data":
        if (o !== "object") {
          Qu(a, "data", d);
          break;
        }
      case "src":
      case "href":
        if (d === "" && (o !== "a" || u !== "href")) {
          a.removeAttribute(u);
          break;
        }
        if (d == null || typeof d == "function" || typeof d == "symbol" || typeof d == "boolean") {
          a.removeAttribute(u);
          break;
        }
        d = nc("" + d), a.setAttribute(u, d);
        break;
      case "action":
      case "formAction":
        if (typeof d == "function") {
          a.setAttribute(
            u,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof v == "function" && (u === "formAction" ? (o !== "input" && it(a, o, "name", g.name, g, null), it(
            a,
            o,
            "formEncType",
            g.formEncType,
            g,
            null
          ), it(
            a,
            o,
            "formMethod",
            g.formMethod,
            g,
            null
          ), it(
            a,
            o,
            "formTarget",
            g.formTarget,
            g,
            null
          )) : (it(a, o, "encType", g.encType, g, null), it(a, o, "method", g.method, g, null), it(a, o, "target", g.target, g, null)));
        if (d == null || typeof d == "symbol" || typeof d == "boolean") {
          a.removeAttribute(u);
          break;
        }
        d = nc("" + d), a.setAttribute(u, d);
        break;
      case "onClick":
        d != null && (a.onclick = Yc);
        break;
      case "onScroll":
        d != null && Ve("scroll", a);
        break;
      case "onScrollEnd":
        d != null && Ve("scrollend", a);
        break;
      case "dangerouslySetInnerHTML":
        if (d != null) {
          if (typeof d != "object" || !("__html" in d))
            throw Error(i(61));
          if (u = d.__html, u != null) {
            if (g.children != null) throw Error(i(60));
            a.innerHTML = u;
          }
        }
        break;
      case "multiple":
        a.multiple = d && typeof d != "function" && typeof d != "symbol";
        break;
      case "muted":
        a.muted = d && typeof d != "function" && typeof d != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (d == null || typeof d == "function" || typeof d == "boolean" || typeof d == "symbol") {
          a.removeAttribute("xlink:href");
          break;
        }
        u = nc("" + d), a.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          u
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        d != null && typeof d != "function" && typeof d != "symbol" ? a.setAttribute(u, "" + d) : a.removeAttribute(u);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        d && typeof d != "function" && typeof d != "symbol" ? a.setAttribute(u, "") : a.removeAttribute(u);
        break;
      case "capture":
      case "download":
        d === !0 ? a.setAttribute(u, "") : d !== !1 && d != null && typeof d != "function" && typeof d != "symbol" ? a.setAttribute(u, d) : a.removeAttribute(u);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        d != null && typeof d != "function" && typeof d != "symbol" && !isNaN(d) && 1 <= d ? a.setAttribute(u, d) : a.removeAttribute(u);
        break;
      case "rowSpan":
      case "start":
        d == null || typeof d == "function" || typeof d == "symbol" || isNaN(d) ? a.removeAttribute(u) : a.setAttribute(u, d);
        break;
      case "popover":
        Ve("beforetoggle", a), Ve("toggle", a), Wu(a, "popover", d);
        break;
      case "xlinkActuate":
        Wr(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          d
        );
        break;
      case "xlinkArcrole":
        Wr(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          d
        );
        break;
      case "xlinkRole":
        Wr(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          d
        );
        break;
      case "xlinkShow":
        Wr(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          d
        );
        break;
      case "xlinkTitle":
        Wr(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          d
        );
        break;
      case "xlinkType":
        Wr(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          d
        );
        break;
      case "xmlBase":
        Wr(
          a,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          d
        );
        break;
      case "xmlLang":
        Wr(
          a,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          d
        );
        break;
      case "xmlSpace":
        Wr(
          a,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          d
        );
        break;
      case "is":
        Wu(a, "is", d);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < u.length) || u[0] !== "o" && u[0] !== "O" || u[1] !== "n" && u[1] !== "N") && (u = Hj.get(u) || u, Wu(a, u, d));
    }
  }
  function fm(a, o, u, d, g, v) {
    switch (u) {
      case "style":
        Aw(a, d, v);
        break;
      case "dangerouslySetInnerHTML":
        if (d != null) {
          if (typeof d != "object" || !("__html" in d))
            throw Error(i(61));
          if (u = d.__html, u != null) {
            if (g.children != null) throw Error(i(60));
            a.innerHTML = u;
          }
        }
        break;
      case "children":
        typeof d == "string" ? ds(a, d) : (typeof d == "number" || typeof d == "bigint") && ds(a, "" + d);
        break;
      case "onScroll":
        d != null && Ve("scroll", a);
        break;
      case "onScrollEnd":
        d != null && Ve("scrollend", a);
        break;
      case "onClick":
        d != null && (a.onclick = Yc);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!vw.hasOwnProperty(u))
          e: {
            if (u[0] === "o" && u[1] === "n" && (g = u.endsWith("Capture"), o = u.slice(2, g ? u.length - 7 : void 0), v = a[bn] || null, v = v != null ? v[u] : null, typeof v == "function" && a.removeEventListener(o, v, g), typeof d == "function")) {
              typeof v != "function" && v !== null && (u in a ? a[u] = null : a.hasAttribute(u) && a.removeAttribute(u)), a.addEventListener(o, d, g);
              break e;
            }
            u in a ? a[u] = d : d === !0 ? a.setAttribute(u, "") : Wu(a, u, d);
          }
    }
  }
  function en(a, o, u) {
    switch (o) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Ve("error", a), Ve("load", a);
        var d = !1, g = !1, v;
        for (v in u)
          if (u.hasOwnProperty(v)) {
            var _ = u[v];
            if (_ != null)
              switch (v) {
                case "src":
                  d = !0;
                  break;
                case "srcSet":
                  g = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(i(137, o));
                default:
                  it(a, o, v, _, u, null);
              }
          }
        g && it(a, o, "srcSet", u.srcSet, u, null), d && it(a, o, "src", u.src, u, null);
        return;
      case "input":
        Ve("invalid", a);
        var E = v = _ = g = null, R = null, F = null;
        for (d in u)
          if (u.hasOwnProperty(d)) {
            var K = u[d];
            if (K != null)
              switch (d) {
                case "name":
                  g = K;
                  break;
                case "type":
                  _ = K;
                  break;
                case "checked":
                  R = K;
                  break;
                case "defaultChecked":
                  F = K;
                  break;
                case "value":
                  v = K;
                  break;
                case "defaultValue":
                  E = K;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (K != null)
                    throw Error(i(137, o));
                  break;
                default:
                  it(a, o, d, K, u, null);
              }
          }
        kw(
          a,
          v,
          E,
          R,
          F,
          _,
          g,
          !1
        ), ec(a);
        return;
      case "select":
        Ve("invalid", a), d = _ = v = null;
        for (g in u)
          if (u.hasOwnProperty(g) && (E = u[g], E != null))
            switch (g) {
              case "value":
                v = E;
                break;
              case "defaultValue":
                _ = E;
                break;
              case "multiple":
                d = E;
              default:
                it(a, o, g, E, u, null);
            }
        o = v, u = _, a.multiple = !!d, o != null ? cs(a, !!d, o, !1) : u != null && cs(a, !!d, u, !0);
        return;
      case "textarea":
        Ve("invalid", a), v = g = d = null;
        for (_ in u)
          if (u.hasOwnProperty(_) && (E = u[_], E != null))
            switch (_) {
              case "value":
                d = E;
                break;
              case "defaultValue":
                g = E;
                break;
              case "children":
                v = E;
                break;
              case "dangerouslySetInnerHTML":
                if (E != null) throw Error(i(91));
                break;
              default:
                it(a, o, _, E, u, null);
            }
        Ew(a, d, g, v), ec(a);
        return;
      case "option":
        for (R in u)
          if (u.hasOwnProperty(R) && (d = u[R], d != null))
            switch (R) {
              case "selected":
                a.selected = d && typeof d != "function" && typeof d != "symbol";
                break;
              default:
                it(a, o, R, d, u, null);
            }
        return;
      case "dialog":
        Ve("beforetoggle", a), Ve("toggle", a), Ve("cancel", a), Ve("close", a);
        break;
      case "iframe":
      case "object":
        Ve("load", a);
        break;
      case "video":
      case "audio":
        for (d = 0; d < bl.length; d++)
          Ve(bl[d], a);
        break;
      case "image":
        Ve("error", a), Ve("load", a);
        break;
      case "details":
        Ve("toggle", a);
        break;
      case "embed":
      case "source":
      case "link":
        Ve("error", a), Ve("load", a);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (F in u)
          if (u.hasOwnProperty(F) && (d = u[F], d != null))
            switch (F) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(i(137, o));
              default:
                it(a, o, F, d, u, null);
            }
        return;
      default:
        if (Ah(o)) {
          for (K in u)
            u.hasOwnProperty(K) && (d = u[K], d !== void 0 && fm(
              a,
              o,
              K,
              d,
              u,
              void 0
            ));
          return;
        }
    }
    for (E in u)
      u.hasOwnProperty(E) && (d = u[E], d != null && it(a, o, E, d, u, null));
  }
  function gP(a, o, u, d) {
    switch (o) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var g = null, v = null, _ = null, E = null, R = null, F = null, K = null;
        for (G in u) {
          var ee = u[G];
          if (u.hasOwnProperty(G) && ee != null)
            switch (G) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                R = ee;
              default:
                d.hasOwnProperty(G) || it(a, o, G, null, d, ee);
            }
        }
        for (var q in d) {
          var G = d[q];
          if (ee = u[q], d.hasOwnProperty(q) && (G != null || ee != null))
            switch (q) {
              case "type":
                v = G;
                break;
              case "name":
                g = G;
                break;
              case "checked":
                F = G;
                break;
              case "defaultChecked":
                K = G;
                break;
              case "value":
                _ = G;
                break;
              case "defaultValue":
                E = G;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (G != null)
                  throw Error(i(137, o));
                break;
              default:
                G !== ee && it(
                  a,
                  o,
                  q,
                  G,
                  d,
                  ee
                );
            }
        }
        Eh(
          a,
          _,
          E,
          R,
          F,
          K,
          v,
          g
        );
        return;
      case "select":
        G = _ = E = q = null;
        for (v in u)
          if (R = u[v], u.hasOwnProperty(v) && R != null)
            switch (v) {
              case "value":
                break;
              case "multiple":
                G = R;
              default:
                d.hasOwnProperty(v) || it(
                  a,
                  o,
                  v,
                  null,
                  d,
                  R
                );
            }
        for (g in d)
          if (v = d[g], R = u[g], d.hasOwnProperty(g) && (v != null || R != null))
            switch (g) {
              case "value":
                q = v;
                break;
              case "defaultValue":
                E = v;
                break;
              case "multiple":
                _ = v;
              default:
                v !== R && it(
                  a,
                  o,
                  g,
                  v,
                  d,
                  R
                );
            }
        o = E, u = _, d = G, q != null ? cs(a, !!u, q, !1) : !!d != !!u && (o != null ? cs(a, !!u, o, !0) : cs(a, !!u, u ? [] : "", !1));
        return;
      case "textarea":
        G = q = null;
        for (E in u)
          if (g = u[E], u.hasOwnProperty(E) && g != null && !d.hasOwnProperty(E))
            switch (E) {
              case "value":
                break;
              case "children":
                break;
              default:
                it(a, o, E, null, d, g);
            }
        for (_ in d)
          if (g = d[_], v = u[_], d.hasOwnProperty(_) && (g != null || v != null))
            switch (_) {
              case "value":
                q = g;
                break;
              case "defaultValue":
                G = g;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (g != null) throw Error(i(91));
                break;
              default:
                g !== v && it(a, o, _, g, d, v);
            }
        Tw(a, q, G);
        return;
      case "option":
        for (var Ae in u)
          if (q = u[Ae], u.hasOwnProperty(Ae) && q != null && !d.hasOwnProperty(Ae))
            switch (Ae) {
              case "selected":
                a.selected = !1;
                break;
              default:
                it(
                  a,
                  o,
                  Ae,
                  null,
                  d,
                  q
                );
            }
        for (R in d)
          if (q = d[R], G = u[R], d.hasOwnProperty(R) && q !== G && (q != null || G != null))
            switch (R) {
              case "selected":
                a.selected = q && typeof q != "function" && typeof q != "symbol";
                break;
              default:
                it(
                  a,
                  o,
                  R,
                  q,
                  d,
                  G
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var ke in u)
          q = u[ke], u.hasOwnProperty(ke) && q != null && !d.hasOwnProperty(ke) && it(a, o, ke, null, d, q);
        for (F in d)
          if (q = d[F], G = u[F], d.hasOwnProperty(F) && q !== G && (q != null || G != null))
            switch (F) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (q != null)
                  throw Error(i(137, o));
                break;
              default:
                it(
                  a,
                  o,
                  F,
                  q,
                  d,
                  G
                );
            }
        return;
      default:
        if (Ah(o)) {
          for (var at in u)
            q = u[at], u.hasOwnProperty(at) && q !== void 0 && !d.hasOwnProperty(at) && fm(
              a,
              o,
              at,
              void 0,
              d,
              q
            );
          for (K in d)
            q = d[K], G = u[K], !d.hasOwnProperty(K) || q === G || q === void 0 && G === void 0 || fm(
              a,
              o,
              K,
              q,
              d,
              G
            );
          return;
        }
    }
    for (var P in u)
      q = u[P], u.hasOwnProperty(P) && q != null && !d.hasOwnProperty(P) && it(a, o, P, null, d, q);
    for (ee in d)
      q = d[ee], G = u[ee], !d.hasOwnProperty(ee) || q === G || q == null && G == null || it(a, o, ee, q, d, G);
  }
  var hm = null, pm = null;
  function Jc(a) {
    return a.nodeType === 9 ? a : a.ownerDocument;
  }
  function $S(a) {
    switch (a) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function AS(a, o) {
    if (a === 0)
      switch (o) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return a === 1 && o === "foreignObject" ? 0 : a;
  }
  function mm(a, o) {
    return a === "textarea" || a === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.children == "bigint" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null;
  }
  var gm = null;
  function vP() {
    var a = window.event;
    return a && a.type === "popstate" ? a === gm ? !1 : (gm = a, !0) : (gm = null, !1);
  }
  var zS = typeof setTimeout == "function" ? setTimeout : void 0, yP = typeof clearTimeout == "function" ? clearTimeout : void 0, IS = typeof Promise == "function" ? Promise : void 0, bP = typeof queueMicrotask == "function" ? queueMicrotask : typeof IS < "u" ? function(a) {
    return IS.resolve(null).then(a).catch(xP);
  } : zS;
  function xP(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Zi(a) {
    return a === "head";
  }
  function CS(a, o) {
    var u = o, d = 0, g = 0;
    do {
      var v = u.nextSibling;
      if (a.removeChild(u), v && v.nodeType === 8)
        if (u = v.data, u === "/$") {
          if (0 < d && 8 > d) {
            u = d;
            var _ = a.ownerDocument;
            if (u & 1 && wl(_.documentElement), u & 2 && wl(_.body), u & 4)
              for (u = _.head, wl(u), _ = u.firstChild; _; ) {
                var E = _.nextSibling, R = _.nodeName;
                _[Do] || R === "SCRIPT" || R === "STYLE" || R === "LINK" && _.rel.toLowerCase() === "stylesheet" || u.removeChild(_), _ = E;
              }
          }
          if (g === 0) {
            a.removeChild(v), zl(o);
            return;
          }
          g--;
        } else
          u === "$" || u === "$?" || u === "$!" ? g++ : d = u.charCodeAt(0) - 48;
      else d = 0;
      u = v;
    } while (u);
    zl(o);
  }
  function vm(a) {
    var o = a.firstChild;
    for (o && o.nodeType === 10 && (o = o.nextSibling); o; ) {
      var u = o;
      switch (o = o.nextSibling, u.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          vm(u), _h(u);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (u.rel.toLowerCase() === "stylesheet") continue;
      }
      a.removeChild(u);
    }
  }
  function wP(a, o, u, d) {
    for (; a.nodeType === 1; ) {
      var g = u;
      if (a.nodeName.toLowerCase() !== o.toLowerCase()) {
        if (!d && (a.nodeName !== "INPUT" || a.type !== "hidden"))
          break;
      } else if (d) {
        if (!a[Do])
          switch (o) {
            case "meta":
              if (!a.hasAttribute("itemprop")) break;
              return a;
            case "link":
              if (v = a.getAttribute("rel"), v === "stylesheet" && a.hasAttribute("data-precedence"))
                break;
              if (v !== g.rel || a.getAttribute("href") !== (g.href == null || g.href === "" ? null : g.href) || a.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin) || a.getAttribute("title") !== (g.title == null ? null : g.title))
                break;
              return a;
            case "style":
              if (a.hasAttribute("data-precedence")) break;
              return a;
            case "script":
              if (v = a.getAttribute("src"), (v !== (g.src == null ? null : g.src) || a.getAttribute("type") !== (g.type == null ? null : g.type) || a.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin)) && v && a.hasAttribute("async") && !a.hasAttribute("itemprop"))
                break;
              return a;
            default:
              return a;
          }
      } else if (o === "input" && a.type === "hidden") {
        var v = g.name == null ? null : "" + g.name;
        if (g.type === "hidden" && a.getAttribute("name") === v)
          return a;
      } else return a;
      if (a = gr(a.nextSibling), a === null) break;
    }
    return null;
  }
  function _P(a, o, u) {
    if (o === "") return null;
    for (; a.nodeType !== 3; )
      if ((a.nodeType !== 1 || a.nodeName !== "INPUT" || a.type !== "hidden") && !u || (a = gr(a.nextSibling), a === null)) return null;
    return a;
  }
  function ym(a) {
    return a.data === "$!" || a.data === "$?" && a.ownerDocument.readyState === "complete";
  }
  function SP(a, o) {
    var u = a.ownerDocument;
    if (a.data !== "$?" || u.readyState === "complete")
      o();
    else {
      var d = function() {
        o(), u.removeEventListener("DOMContentLoaded", d);
      };
      u.addEventListener("DOMContentLoaded", d), a._reactRetry = d;
    }
  }
  function gr(a) {
    for (; a != null; a = a.nextSibling) {
      var o = a.nodeType;
      if (o === 1 || o === 3) break;
      if (o === 8) {
        if (o = a.data, o === "$" || o === "$!" || o === "$?" || o === "F!" || o === "F")
          break;
        if (o === "/$") return null;
      }
    }
    return a;
  }
  var bm = null;
  function OS(a) {
    a = a.previousSibling;
    for (var o = 0; a; ) {
      if (a.nodeType === 8) {
        var u = a.data;
        if (u === "$" || u === "$!" || u === "$?") {
          if (o === 0) return a;
          o--;
        } else u === "/$" && o++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  function RS(a, o, u) {
    switch (o = Jc(u), a) {
      case "html":
        if (a = o.documentElement, !a) throw Error(i(452));
        return a;
      case "head":
        if (a = o.head, !a) throw Error(i(453));
        return a;
      case "body":
        if (a = o.body, !a) throw Error(i(454));
        return a;
      default:
        throw Error(i(451));
    }
  }
  function wl(a) {
    for (var o = a.attributes; o.length; )
      a.removeAttributeNode(o[0]);
    _h(a);
  }
  var ar = /* @__PURE__ */ new Map(), NS = /* @__PURE__ */ new Set();
  function Xc(a) {
    return typeof a.getRootNode == "function" ? a.getRootNode() : a.nodeType === 9 ? a : a.ownerDocument;
  }
  var fi = Y.d;
  Y.d = {
    f: kP,
    r: TP,
    D: EP,
    C: $P,
    L: AP,
    m: zP,
    X: CP,
    S: IP,
    M: OP
  };
  function kP() {
    var a = fi.f(), o = Bc();
    return a || o;
  }
  function TP(a) {
    var o = ss(a);
    o !== null && o.tag === 5 && o.type === "form" ? e0(o) : fi.r(a);
  }
  var Ls = typeof document > "u" ? null : document;
  function MS(a, o, u) {
    var d = Ls;
    if (d && typeof o == "string" && o) {
      var g = Wn(o);
      g = 'link[rel="' + a + '"][href="' + g + '"]', typeof u == "string" && (g += '[crossorigin="' + u + '"]'), NS.has(g) || (NS.add(g), a = { rel: a, crossOrigin: u, href: o }, d.querySelector(g) === null && (o = d.createElement("link"), en(o, "link", a), qt(o), d.head.appendChild(o)));
    }
  }
  function EP(a) {
    fi.D(a), MS("dns-prefetch", a, null);
  }
  function $P(a, o) {
    fi.C(a, o), MS("preconnect", a, o);
  }
  function AP(a, o, u) {
    fi.L(a, o, u);
    var d = Ls;
    if (d && a && o) {
      var g = 'link[rel="preload"][as="' + Wn(o) + '"]';
      o === "image" && u && u.imageSrcSet ? (g += '[imagesrcset="' + Wn(
        u.imageSrcSet
      ) + '"]', typeof u.imageSizes == "string" && (g += '[imagesizes="' + Wn(
        u.imageSizes
      ) + '"]')) : g += '[href="' + Wn(a) + '"]';
      var v = g;
      switch (o) {
        case "style":
          v = Bs(a);
          break;
        case "script":
          v = Zs(a);
      }
      ar.has(v) || (a = p(
        {
          rel: "preload",
          href: o === "image" && u && u.imageSrcSet ? void 0 : a,
          as: o
        },
        u
      ), ar.set(v, a), d.querySelector(g) !== null || o === "style" && d.querySelector(_l(v)) || o === "script" && d.querySelector(Sl(v)) || (o = d.createElement("link"), en(o, "link", a), qt(o), d.head.appendChild(o)));
    }
  }
  function zP(a, o) {
    fi.m(a, o);
    var u = Ls;
    if (u && a) {
      var d = o && typeof o.as == "string" ? o.as : "script", g = 'link[rel="modulepreload"][as="' + Wn(d) + '"][href="' + Wn(a) + '"]', v = g;
      switch (d) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          v = Zs(a);
      }
      if (!ar.has(v) && (a = p({ rel: "modulepreload", href: a }, o), ar.set(v, a), u.querySelector(g) === null)) {
        switch (d) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (u.querySelector(Sl(v)))
              return;
        }
        d = u.createElement("link"), en(d, "link", a), qt(d), u.head.appendChild(d);
      }
    }
  }
  function IP(a, o, u) {
    fi.S(a, o, u);
    var d = Ls;
    if (d && a) {
      var g = os(d).hoistableStyles, v = Bs(a);
      o = o || "default";
      var _ = g.get(v);
      if (!_) {
        var E = { loading: 0, preload: null };
        if (_ = d.querySelector(
          _l(v)
        ))
          E.loading = 5;
        else {
          a = p(
            { rel: "stylesheet", href: a, "data-precedence": o },
            u
          ), (u = ar.get(v)) && xm(a, u);
          var R = _ = d.createElement("link");
          qt(R), en(R, "link", a), R._p = new Promise(function(F, K) {
            R.onload = F, R.onerror = K;
          }), R.addEventListener("load", function() {
            E.loading |= 1;
          }), R.addEventListener("error", function() {
            E.loading |= 2;
          }), E.loading |= 4, Kc(_, o, d);
        }
        _ = {
          type: "stylesheet",
          instance: _,
          count: 1,
          state: E
        }, g.set(v, _);
      }
    }
  }
  function CP(a, o) {
    fi.X(a, o);
    var u = Ls;
    if (u && a) {
      var d = os(u).hoistableScripts, g = Zs(a), v = d.get(g);
      v || (v = u.querySelector(Sl(g)), v || (a = p({ src: a, async: !0 }, o), (o = ar.get(g)) && wm(a, o), v = u.createElement("script"), qt(v), en(v, "link", a), u.head.appendChild(v)), v = {
        type: "script",
        instance: v,
        count: 1,
        state: null
      }, d.set(g, v));
    }
  }
  function OP(a, o) {
    fi.M(a, o);
    var u = Ls;
    if (u && a) {
      var d = os(u).hoistableScripts, g = Zs(a), v = d.get(g);
      v || (v = u.querySelector(Sl(g)), v || (a = p({ src: a, async: !0, type: "module" }, o), (o = ar.get(g)) && wm(a, o), v = u.createElement("script"), qt(v), en(v, "link", a), u.head.appendChild(v)), v = {
        type: "script",
        instance: v,
        count: 1,
        state: null
      }, d.set(g, v));
    }
  }
  function DS(a, o, u, d) {
    var g = (g = pe.current) ? Xc(g) : null;
    if (!g) throw Error(i(446));
    switch (a) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof u.precedence == "string" && typeof u.href == "string" ? (o = Bs(u.href), u = os(
          g
        ).hoistableStyles, d = u.get(o), d || (d = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, u.set(o, d)), d) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (u.rel === "stylesheet" && typeof u.href == "string" && typeof u.precedence == "string") {
          a = Bs(u.href);
          var v = os(
            g
          ).hoistableStyles, _ = v.get(a);
          if (_ || (g = g.ownerDocument || g, _ = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, v.set(a, _), (v = g.querySelector(
            _l(a)
          )) && !v._p && (_.instance = v, _.state.loading = 5), ar.has(a) || (u = {
            rel: "preload",
            as: "style",
            href: u.href,
            crossOrigin: u.crossOrigin,
            integrity: u.integrity,
            media: u.media,
            hrefLang: u.hrefLang,
            referrerPolicy: u.referrerPolicy
          }, ar.set(a, u), v || RP(
            g,
            a,
            u,
            _.state
          ))), o && d === null)
            throw Error(i(528, ""));
          return _;
        }
        if (o && d !== null)
          throw Error(i(529, ""));
        return null;
      case "script":
        return o = u.async, u = u.src, typeof u == "string" && o && typeof o != "function" && typeof o != "symbol" ? (o = Zs(u), u = os(
          g
        ).hoistableScripts, d = u.get(o), d || (d = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, u.set(o, d)), d) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(i(444, a));
    }
  }
  function Bs(a) {
    return 'href="' + Wn(a) + '"';
  }
  function _l(a) {
    return 'link[rel="stylesheet"][' + a + "]";
  }
  function jS(a) {
    return p({}, a, {
      "data-precedence": a.precedence,
      precedence: null
    });
  }
  function RP(a, o, u, d) {
    a.querySelector('link[rel="preload"][as="style"][' + o + "]") ? d.loading = 1 : (o = a.createElement("link"), d.preload = o, o.addEventListener("load", function() {
      return d.loading |= 1;
    }), o.addEventListener("error", function() {
      return d.loading |= 2;
    }), en(o, "link", u), qt(o), a.head.appendChild(o));
  }
  function Zs(a) {
    return '[src="' + Wn(a) + '"]';
  }
  function Sl(a) {
    return "script[async]" + a;
  }
  function PS(a, o, u) {
    if (o.count++, o.instance === null)
      switch (o.type) {
        case "style":
          var d = a.querySelector(
            'style[data-href~="' + Wn(u.href) + '"]'
          );
          if (d)
            return o.instance = d, qt(d), d;
          var g = p({}, u, {
            "data-href": u.href,
            "data-precedence": u.precedence,
            href: null,
            precedence: null
          });
          return d = (a.ownerDocument || a).createElement(
            "style"
          ), qt(d), en(d, "style", g), Kc(d, u.precedence, a), o.instance = d;
        case "stylesheet":
          g = Bs(u.href);
          var v = a.querySelector(
            _l(g)
          );
          if (v)
            return o.state.loading |= 4, o.instance = v, qt(v), v;
          d = jS(u), (g = ar.get(g)) && xm(d, g), v = (a.ownerDocument || a).createElement("link"), qt(v);
          var _ = v;
          return _._p = new Promise(function(E, R) {
            _.onload = E, _.onerror = R;
          }), en(v, "link", d), o.state.loading |= 4, Kc(v, u.precedence, a), o.instance = v;
        case "script":
          return v = Zs(u.src), (g = a.querySelector(
            Sl(v)
          )) ? (o.instance = g, qt(g), g) : (d = u, (g = ar.get(v)) && (d = p({}, u), wm(d, g)), a = a.ownerDocument || a, g = a.createElement("script"), qt(g), en(g, "link", d), a.head.appendChild(g), o.instance = g);
        case "void":
          return null;
        default:
          throw Error(i(443, o.type));
      }
    else
      o.type === "stylesheet" && (o.state.loading & 4) === 0 && (d = o.instance, o.state.loading |= 4, Kc(d, u.precedence, a));
    return o.instance;
  }
  function Kc(a, o, u) {
    for (var d = u.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), g = d.length ? d[d.length - 1] : null, v = g, _ = 0; _ < d.length; _++) {
      var E = d[_];
      if (E.dataset.precedence === o) v = E;
      else if (v !== g) break;
    }
    v ? v.parentNode.insertBefore(a, v.nextSibling) : (o = u.nodeType === 9 ? u.head : u, o.insertBefore(a, o.firstChild));
  }
  function xm(a, o) {
    a.crossOrigin == null && (a.crossOrigin = o.crossOrigin), a.referrerPolicy == null && (a.referrerPolicy = o.referrerPolicy), a.title == null && (a.title = o.title);
  }
  function wm(a, o) {
    a.crossOrigin == null && (a.crossOrigin = o.crossOrigin), a.referrerPolicy == null && (a.referrerPolicy = o.referrerPolicy), a.integrity == null && (a.integrity = o.integrity);
  }
  var Wc = null;
  function US(a, o, u) {
    if (Wc === null) {
      var d = /* @__PURE__ */ new Map(), g = Wc = /* @__PURE__ */ new Map();
      g.set(u, d);
    } else
      g = Wc, d = g.get(u), d || (d = /* @__PURE__ */ new Map(), g.set(u, d));
    if (d.has(a)) return d;
    for (d.set(a, null), u = u.getElementsByTagName(a), g = 0; g < u.length; g++) {
      var v = u[g];
      if (!(v[Do] || v[nn] || a === "link" && v.getAttribute("rel") === "stylesheet") && v.namespaceURI !== "http://www.w3.org/2000/svg") {
        var _ = v.getAttribute(o) || "";
        _ = a + _;
        var E = d.get(_);
        E ? E.push(v) : d.set(_, [v]);
      }
    }
    return d;
  }
  function LS(a, o, u) {
    a = a.ownerDocument || a, a.head.insertBefore(
      u,
      o === "title" ? a.querySelector("head > title") : null
    );
  }
  function NP(a, o, u) {
    if (u === 1 || o.itemProp != null) return !1;
    switch (a) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof o.precedence != "string" || typeof o.href != "string" || o.href === "")
          break;
        return !0;
      case "link":
        if (typeof o.rel != "string" || typeof o.href != "string" || o.href === "" || o.onLoad || o.onError)
          break;
        switch (o.rel) {
          case "stylesheet":
            return a = o.disabled, typeof o.precedence == "string" && a == null;
          default:
            return !0;
        }
      case "script":
        if (o.async && typeof o.async != "function" && typeof o.async != "symbol" && !o.onLoad && !o.onError && o.src && typeof o.src == "string")
          return !0;
    }
    return !1;
  }
  function BS(a) {
    return !(a.type === "stylesheet" && (a.state.loading & 3) === 0);
  }
  var kl = null;
  function MP() {
  }
  function DP(a, o, u) {
    if (kl === null) throw Error(i(475));
    var d = kl;
    if (o.type === "stylesheet" && (typeof u.media != "string" || matchMedia(u.media).matches !== !1) && (o.state.loading & 4) === 0) {
      if (o.instance === null) {
        var g = Bs(u.href), v = a.querySelector(
          _l(g)
        );
        if (v) {
          a = v._p, a !== null && typeof a == "object" && typeof a.then == "function" && (d.count++, d = Qc.bind(d), a.then(d, d)), o.state.loading |= 4, o.instance = v, qt(v);
          return;
        }
        v = a.ownerDocument || a, u = jS(u), (g = ar.get(g)) && xm(u, g), v = v.createElement("link"), qt(v);
        var _ = v;
        _._p = new Promise(function(E, R) {
          _.onload = E, _.onerror = R;
        }), en(v, "link", u), o.instance = v;
      }
      d.stylesheets === null && (d.stylesheets = /* @__PURE__ */ new Map()), d.stylesheets.set(o, a), (a = o.state.preload) && (o.state.loading & 3) === 0 && (d.count++, o = Qc.bind(d), a.addEventListener("load", o), a.addEventListener("error", o));
    }
  }
  function jP() {
    if (kl === null) throw Error(i(475));
    var a = kl;
    return a.stylesheets && a.count === 0 && _m(a, a.stylesheets), 0 < a.count ? function(o) {
      var u = setTimeout(function() {
        if (a.stylesheets && _m(a, a.stylesheets), a.unsuspend) {
          var d = a.unsuspend;
          a.unsuspend = null, d();
        }
      }, 6e4);
      return a.unsuspend = o, function() {
        a.unsuspend = null, clearTimeout(u);
      };
    } : null;
  }
  function Qc() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) _m(this, this.stylesheets);
      else if (this.unsuspend) {
        var a = this.unsuspend;
        this.unsuspend = null, a();
      }
    }
  }
  var ed = null;
  function _m(a, o) {
    a.stylesheets = null, a.unsuspend !== null && (a.count++, ed = /* @__PURE__ */ new Map(), o.forEach(PP, a), ed = null, Qc.call(a));
  }
  function PP(a, o) {
    if (!(o.state.loading & 4)) {
      var u = ed.get(a);
      if (u) var d = u.get(null);
      else {
        u = /* @__PURE__ */ new Map(), ed.set(a, u);
        for (var g = a.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), v = 0; v < g.length; v++) {
          var _ = g[v];
          (_.nodeName === "LINK" || _.getAttribute("media") !== "not all") && (u.set(_.dataset.precedence, _), d = _);
        }
        d && u.set(null, d);
      }
      g = o.instance, _ = g.getAttribute("data-precedence"), v = u.get(_) || d, v === d && u.set(null, g), u.set(_, g), this.count++, d = Qc.bind(this), g.addEventListener("load", d), g.addEventListener("error", d), v ? v.parentNode.insertBefore(g, v.nextSibling) : (a = a.nodeType === 9 ? a.head : a, a.insertBefore(g, a.firstChild)), o.state.loading |= 4;
    }
  }
  var Tl = {
    $$typeof: z,
    Provider: null,
    Consumer: null,
    _currentValue: H,
    _currentValue2: H,
    _threadCount: 0
  };
  function UP(a, o, u, d, g, v, _, E) {
    this.tag = 1, this.containerInfo = a, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = yh(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = yh(0), this.hiddenUpdates = yh(null), this.identifierPrefix = d, this.onUncaughtError = g, this.onCaughtError = v, this.onRecoverableError = _, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = E, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function ZS(a, o, u, d, g, v, _, E, R, F, K, ee) {
    return a = new UP(
      a,
      o,
      u,
      _,
      E,
      R,
      F,
      ee
    ), o = 1, v === !0 && (o |= 24), v = Nn(3, null, null, o), a.current = v, v.stateNode = a, o = rp(), o.refCount++, a.pooledCache = o, o.refCount++, v.memoizedState = {
      element: d,
      isDehydrated: u,
      cache: o
    }, op(v), a;
  }
  function VS(a) {
    return a ? (a = bs, a) : bs;
  }
  function FS(a, o, u, d, g, v) {
    g = VS(g), d.context === null ? d.context = g : d.pendingContext = g, d = zi(o), d.payload = { element: u }, v = v === void 0 ? null : v, v !== null && (d.callback = v), u = Ii(a, d, o), u !== null && (Un(u, a, o), tl(u, a, o));
  }
  function HS(a, o) {
    if (a = a.memoizedState, a !== null && a.dehydrated !== null) {
      var u = a.retryLane;
      a.retryLane = u !== 0 && u < o ? u : o;
    }
  }
  function Sm(a, o) {
    HS(a, o), (a = a.alternate) && HS(a, o);
  }
  function qS(a) {
    if (a.tag === 13) {
      var o = ys(a, 67108864);
      o !== null && Un(o, a, 67108864), Sm(a, 67108864);
    }
  }
  var td = !0;
  function LP(a, o, u, d) {
    var g = L.T;
    L.T = null;
    var v = Y.p;
    try {
      Y.p = 2, km(a, o, u, d);
    } finally {
      Y.p = v, L.T = g;
    }
  }
  function BP(a, o, u, d) {
    var g = L.T;
    L.T = null;
    var v = Y.p;
    try {
      Y.p = 8, km(a, o, u, d);
    } finally {
      Y.p = v, L.T = g;
    }
  }
  function km(a, o, u, d) {
    if (td) {
      var g = Tm(d);
      if (g === null)
        dm(
          a,
          o,
          d,
          nd,
          u
        ), YS(a, d);
      else if (VP(
        g,
        a,
        o,
        u,
        d
      ))
        d.stopPropagation();
      else if (YS(a, d), o & 4 && -1 < ZP.indexOf(a)) {
        for (; g !== null; ) {
          var v = ss(g);
          if (v !== null)
            switch (v.tag) {
              case 3:
                if (v = v.stateNode, v.current.memoizedState.isDehydrated) {
                  var _ = On(v.pendingLanes);
                  if (_ !== 0) {
                    var E = v;
                    for (E.pendingLanes |= 2, E.entangledLanes |= 2; _; ) {
                      var R = 1 << 31 - $e(_);
                      E.entanglements[1] |= R, _ &= ~R;
                    }
                    jr(v), (et & 6) === 0 && (Uc = In() + 500, yl(0));
                  }
                }
                break;
              case 13:
                E = ys(v, 2), E !== null && Un(E, v, 2), Bc(), Sm(v, 2);
            }
          if (v = Tm(d), v === null && dm(
            a,
            o,
            d,
            nd,
            u
          ), v === g) break;
          g = v;
        }
        g !== null && d.stopPropagation();
      } else
        dm(
          a,
          o,
          d,
          null,
          u
        );
    }
  }
  function Tm(a) {
    return a = Ih(a), Em(a);
  }
  var nd = null;
  function Em(a) {
    if (nd = null, a = as(a), a !== null) {
      var o = s(a);
      if (o === null) a = null;
      else {
        var u = o.tag;
        if (u === 13) {
          if (a = l(o), a !== null) return a;
          a = null;
        } else if (u === 3) {
          if (o.stateNode.current.memoizedState.isDehydrated)
            return o.tag === 3 ? o.stateNode.containerInfo : null;
          a = null;
        } else o !== a && (a = null);
      }
    }
    return nd = a, null;
  }
  function GS(a) {
    switch (a) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (ph()) {
          case Ro:
            return 2;
          case No:
            return 8;
          case rs:
          case mh:
            return 32;
          case Ku:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var $m = !1, Vi = null, Fi = null, Hi = null, El = /* @__PURE__ */ new Map(), $l = /* @__PURE__ */ new Map(), qi = [], ZP = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function YS(a, o) {
    switch (a) {
      case "focusin":
      case "focusout":
        Vi = null;
        break;
      case "dragenter":
      case "dragleave":
        Fi = null;
        break;
      case "mouseover":
      case "mouseout":
        Hi = null;
        break;
      case "pointerover":
      case "pointerout":
        El.delete(o.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        $l.delete(o.pointerId);
    }
  }
  function Al(a, o, u, d, g, v) {
    return a === null || a.nativeEvent !== v ? (a = {
      blockedOn: o,
      domEventName: u,
      eventSystemFlags: d,
      nativeEvent: v,
      targetContainers: [g]
    }, o !== null && (o = ss(o), o !== null && qS(o)), a) : (a.eventSystemFlags |= d, o = a.targetContainers, g !== null && o.indexOf(g) === -1 && o.push(g), a);
  }
  function VP(a, o, u, d, g) {
    switch (o) {
      case "focusin":
        return Vi = Al(
          Vi,
          a,
          o,
          u,
          d,
          g
        ), !0;
      case "dragenter":
        return Fi = Al(
          Fi,
          a,
          o,
          u,
          d,
          g
        ), !0;
      case "mouseover":
        return Hi = Al(
          Hi,
          a,
          o,
          u,
          d,
          g
        ), !0;
      case "pointerover":
        var v = g.pointerId;
        return El.set(
          v,
          Al(
            El.get(v) || null,
            a,
            o,
            u,
            d,
            g
          )
        ), !0;
      case "gotpointercapture":
        return v = g.pointerId, $l.set(
          v,
          Al(
            $l.get(v) || null,
            a,
            o,
            u,
            d,
            g
          )
        ), !0;
    }
    return !1;
  }
  function JS(a) {
    var o = as(a.target);
    if (o !== null) {
      var u = s(o);
      if (u !== null) {
        if (o = u.tag, o === 13) {
          if (o = l(u), o !== null) {
            a.blockedOn = o, Dj(a.priority, function() {
              if (u.tag === 13) {
                var d = Pn();
                d = bh(d);
                var g = ys(u, d);
                g !== null && Un(g, u, d), Sm(u, d);
              }
            });
            return;
          }
        } else if (o === 3 && u.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = u.tag === 3 ? u.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function rd(a) {
    if (a.blockedOn !== null) return !1;
    for (var o = a.targetContainers; 0 < o.length; ) {
      var u = Tm(a.nativeEvent);
      if (u === null) {
        u = a.nativeEvent;
        var d = new u.constructor(
          u.type,
          u
        );
        zh = d, u.target.dispatchEvent(d), zh = null;
      } else
        return o = ss(u), o !== null && qS(o), a.blockedOn = u, !1;
      o.shift();
    }
    return !0;
  }
  function XS(a, o, u) {
    rd(a) && u.delete(o);
  }
  function FP() {
    $m = !1, Vi !== null && rd(Vi) && (Vi = null), Fi !== null && rd(Fi) && (Fi = null), Hi !== null && rd(Hi) && (Hi = null), El.forEach(XS), $l.forEach(XS);
  }
  function id(a, o) {
    a.blockedOn === o && (a.blockedOn = null, $m || ($m = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      FP
    )));
  }
  var ad = null;
  function KS(a) {
    ad !== a && (ad = a, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        ad === a && (ad = null);
        for (var o = 0; o < a.length; o += 3) {
          var u = a[o], d = a[o + 1], g = a[o + 2];
          if (typeof d != "function") {
            if (Em(d || u) === null)
              continue;
            break;
          }
          var v = ss(u);
          v !== null && (a.splice(o, 3), o -= 3, Ep(
            v,
            {
              pending: !0,
              data: g,
              method: u.method,
              action: d
            },
            d,
            g
          ));
        }
      }
    ));
  }
  function zl(a) {
    function o(R) {
      return id(R, a);
    }
    Vi !== null && id(Vi, a), Fi !== null && id(Fi, a), Hi !== null && id(Hi, a), El.forEach(o), $l.forEach(o);
    for (var u = 0; u < qi.length; u++) {
      var d = qi[u];
      d.blockedOn === a && (d.blockedOn = null);
    }
    for (; 0 < qi.length && (u = qi[0], u.blockedOn === null); )
      JS(u), u.blockedOn === null && qi.shift();
    if (u = (a.ownerDocument || a).$$reactFormReplay, u != null)
      for (d = 0; d < u.length; d += 3) {
        var g = u[d], v = u[d + 1], _ = g[bn] || null;
        if (typeof v == "function")
          _ || KS(u);
        else if (_) {
          var E = null;
          if (v && v.hasAttribute("formAction")) {
            if (g = v, _ = v[bn] || null)
              E = _.formAction;
            else if (Em(g) !== null) continue;
          } else E = _.action;
          typeof E == "function" ? u[d + 1] = E : (u.splice(d, 3), d -= 3), KS(u);
        }
      }
  }
  function Am(a) {
    this._internalRoot = a;
  }
  sd.prototype.render = Am.prototype.render = function(a) {
    var o = this._internalRoot;
    if (o === null) throw Error(i(409));
    var u = o.current, d = Pn();
    FS(u, d, a, o, null, null);
  }, sd.prototype.unmount = Am.prototype.unmount = function() {
    var a = this._internalRoot;
    if (a !== null) {
      this._internalRoot = null;
      var o = a.containerInfo;
      FS(a.current, 2, null, a, null, null), Bc(), o[is] = null;
    }
  };
  function sd(a) {
    this._internalRoot = a;
  }
  sd.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var o = pw();
      a = { blockedOn: null, target: a, priority: o };
      for (var u = 0; u < qi.length && o !== 0 && o < qi[u].priority; u++) ;
      qi.splice(u, 0, a), u === 0 && JS(a);
    }
  };
  var WS = t.version;
  if (WS !== "19.1.0")
    throw Error(
      i(
        527,
        WS,
        "19.1.0"
      )
    );
  Y.findDOMNode = function(a) {
    var o = a._reactInternals;
    if (o === void 0)
      throw typeof a.render == "function" ? Error(i(188)) : (a = Object.keys(a).join(","), Error(i(268, a)));
    return a = f(o), a = a !== null ? h(a) : null, a = a === null ? null : a.stateNode, a;
  };
  var HP = {
    bundleType: 0,
    version: "19.1.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: L,
    reconcilerVersion: "19.1.0"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var od = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!od.isDisabled && od.supportsFiber)
      try {
        J = od.inject(
          HP
        ), oe = od;
      } catch {
      }
  }
  return Il.createRoot = function(a, o) {
    if (!r(a)) throw Error(i(299));
    var u = !1, d = "", g = p0, v = m0, _ = g0, E = null;
    return o != null && (o.unstable_strictMode === !0 && (u = !0), o.identifierPrefix !== void 0 && (d = o.identifierPrefix), o.onUncaughtError !== void 0 && (g = o.onUncaughtError), o.onCaughtError !== void 0 && (v = o.onCaughtError), o.onRecoverableError !== void 0 && (_ = o.onRecoverableError), o.unstable_transitionCallbacks !== void 0 && (E = o.unstable_transitionCallbacks)), o = ZS(
      a,
      1,
      !1,
      null,
      null,
      u,
      d,
      g,
      v,
      _,
      E,
      null
    ), a[is] = o.current, cm(a), new Am(o);
  }, Il.hydrateRoot = function(a, o, u) {
    if (!r(a)) throw Error(i(299));
    var d = !1, g = "", v = p0, _ = m0, E = g0, R = null, F = null;
    return u != null && (u.unstable_strictMode === !0 && (d = !0), u.identifierPrefix !== void 0 && (g = u.identifierPrefix), u.onUncaughtError !== void 0 && (v = u.onUncaughtError), u.onCaughtError !== void 0 && (_ = u.onCaughtError), u.onRecoverableError !== void 0 && (E = u.onRecoverableError), u.unstable_transitionCallbacks !== void 0 && (R = u.unstable_transitionCallbacks), u.formState !== void 0 && (F = u.formState)), o = ZS(
      a,
      1,
      !0,
      o,
      u ?? null,
      d,
      g,
      v,
      _,
      E,
      R,
      F
    ), o.context = VS(null), u = o.current, d = Pn(), d = bh(d), g = zi(d), g.callback = null, Ii(u, g, d), u = d, o.current.lanes = u, Mo(o, u), jr(o), a[is] = o.current, cm(a), new sd(o);
  }, Il.version = "19.1.0", Il;
}
var s1;
function QP() {
  if (s1) return Im.exports;
  s1 = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Im.exports = WP(), Im.exports;
}
var e6 = QP();
const t6 = /* @__PURE__ */ la(e6);
var n6 = Object.defineProperty, r6 = (e, t, n) => t in e ? n6(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, ld = (e, t, n) => r6(e, typeof t != "symbol" ? t + "" : t, n);
const i6 = {
  stringify: (e) => e ? "true" : "false",
  parse: (e) => /^[ty1-9]/i.test(e)
}, a6 = {
  stringify: (e) => e.name,
  parse: (e, t, n) => {
    const i = (() => {
      if (typeof window < "u" && e in window || typeof window < "u" && e in window)
        return window[e];
    })();
    return typeof i == "function" ? i.bind(n) : void 0;
  }
}, s6 = {
  stringify: (e) => JSON.stringify(e),
  parse: (e) => JSON.parse(e)
}, o6 = {
  stringify: (e) => `${e}`,
  parse: (e) => parseFloat(e)
}, l6 = {
  stringify: (e) => e,
  parse: (e) => e
}, Nm = {
  string: l6,
  number: o6,
  boolean: i6,
  function: a6,
  json: s6
};
function u6(e) {
  return e.replace(
    /([a-z0-9])([A-Z])/g,
    (t, n, i) => `${n}-${i.toLowerCase()}`
  );
}
const ud = Symbol.for("r2wc.render"), cd = Symbol.for("r2wc.connected"), Ia = Symbol.for("r2wc.context"), hi = Symbol.for("r2wc.props");
function c6(e, t, n) {
  var i, r, s;
  t.props || (t.props = e.propTypes ? Object.keys(e.propTypes) : []), t.events || (t.events = []);
  const l = Array.isArray(t.props) ? t.props.slice() : Object.keys(t.props), c = Array.isArray(t.events) ? t.events.slice() : Object.keys(t.events), f = {}, h = {}, p = {}, m = {};
  for (const b of l) {
    f[b] = Array.isArray(t.props) ? "string" : t.props[b];
    const x = u6(b);
    p[b] = x, m[x] = b;
  }
  for (const b of c)
    h[b] = Array.isArray(t.events) ? {} : t.events[b];
  class y extends HTMLElement {
    constructor() {
      super(), ld(this, s, !0), ld(this, r), ld(this, i, {}), ld(this, "container"), t.shadow ? this.container = this.attachShadow({
        mode: t.shadow
      }) : this.container = this, this[hi].container = this.container;
      for (const x of l) {
        const w = p[x], k = this.getAttribute(w), T = f[x], A = T ? Nm[T] : null;
        A != null && A.parse && k && (this[hi][x] = A.parse(k, w, this));
      }
      for (const x of c)
        this[hi][x] = (w) => {
          const k = x.replace(/^on/, "").toLowerCase();
          this.dispatchEvent(
            new CustomEvent(k, { detail: w, ...h[x] })
          );
        };
    }
    static get observedAttributes() {
      return Object.keys(m);
    }
    connectedCallback() {
      this[cd] = !0, this[ud]();
    }
    disconnectedCallback() {
      this[cd] = !1, this[Ia] && n.unmount(this[Ia]), delete this[Ia];
    }
    attributeChangedCallback(x, w, k) {
      const T = m[x], A = f[T], z = A ? Nm[A] : null;
      T in f && z != null && z.parse && k && (this[hi][T] = z.parse(k, x, this), this[ud]());
    }
    [(s = cd, r = Ia, i = hi, ud)]() {
      this[cd] && (this[Ia] ? n.update(this[Ia], this[hi]) : this[Ia] = n.mount(
        this.container,
        e,
        this[hi]
      ));
    }
  }
  for (const b of l) {
    const x = p[b], w = f[b];
    Object.defineProperty(y.prototype, b, {
      enumerable: !0,
      configurable: !0,
      get() {
        return this[hi][b];
      },
      set(k) {
        this[hi][b] = k;
        const T = w ? Nm[w] : null;
        if (T != null && T.stringify) {
          const A = T.stringify(k, x, this);
          this.getAttribute(x) !== A && this.setAttribute(x, A);
        } else
          this[ud]();
      }
    });
  }
  return y;
}
function d6(e, t, n, i = {}) {
  function r(c, f, h) {
    const p = t.createElement(f, h);
    if ("createRoot" in n) {
      const m = n.createRoot(c);
      return m.render(p), {
        container: c,
        root: m,
        ReactComponent: f
      };
    }
    if ("render" in n)
      return n.render(p, c), {
        container: c,
        ReactComponent: f
      };
    throw new Error("Invalid ReactDOM instance provided.");
  }
  function s({ container: c, root: f, ReactComponent: h }, p) {
    const m = t.createElement(h, p);
    if (f) {
      f.render(m);
      return;
    }
    if ("render" in n) {
      n.render(m, c);
      return;
    }
  }
  function l({ container: c, root: f }) {
    if (f) {
      f.unmount();
      return;
    }
    if ("unmountComponentAtNode" in n) {
      n.unmountComponentAtNode(c);
      return;
    }
  }
  return c6(e, i, { mount: r, unmount: l, update: s });
}
var Mm = { exports: {} }, Cl = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var o1;
function f6() {
  if (o1) return Cl;
  o1 = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function n(i, r, s) {
    var l = null;
    if (s !== void 0 && (l = "" + s), r.key !== void 0 && (l = "" + r.key), "key" in r) {
      s = {};
      for (var c in r)
        c !== "key" && (s[c] = r[c]);
    } else s = r;
    return r = s.ref, {
      $$typeof: e,
      type: i,
      key: l,
      ref: r !== void 0 ? r : null,
      props: s
    };
  }
  return Cl.Fragment = t, Cl.jsx = n, Cl.jsxs = n, Cl;
}
var l1;
function h6() {
  return l1 || (l1 = 1, Mm.exports = f6()), Mm.exports;
}
var C = h6(), p6 = (e) => Array.from(e).map((n) => n.getModelContext()).sort((n, i) => (i.priority ?? 0) - (n.priority ?? 0)).reduce((n, i) => {
  if (i.system && (n.system ? n.system += `

${i.system}` : n.system = i.system), i.tools)
    for (const [r, s] of Object.entries(i.tools)) {
      const l = n.tools?.[r];
      if (l && l !== s)
        throw new Error(
          `You tried to define a tool with the name ${r}, but it already exists.`
        );
      n.tools || (n.tools = {}), n.tools[r] = s;
    }
  return i.config && (n.config = {
    ...n.config,
    ...i.config
  }), i.callSettings && (n.callSettings = {
    ...n.callSettings,
    ...i.callSettings
  }), n;
}, {}), t$ = class {
  _providers = /* @__PURE__ */ new Set();
  getModelContext() {
    return p6(this._providers);
  }
  registerModelContextProvider(e) {
    this._providers.add(e);
    const t = e.subscribe?.(() => {
      this.notifySubscribers();
    });
    return this.notifySubscribers(), () => {
      this._providers.delete(e), t?.(), this.notifySubscribers();
    };
  }
  _subscribers = /* @__PURE__ */ new Set();
  notifySubscribers() {
    for (const e of this._subscribers) e();
  }
  subscribe(e) {
    return this._subscribers.add(e), () => this._subscribers.delete(e);
  }
}, Bv = class {
  _contextProvider = new t$();
  registerModelContextProvider(e) {
    return this._contextProvider.registerModelContextProvider(e);
  }
}, Ef = class {
  _subscribers = /* @__PURE__ */ new Set();
  subscribe(e) {
    return this._subscribers.add(e), () => this._subscribers.delete(e);
  }
  waitForUpdate() {
    return new Promise((e) => {
      const t = this.subscribe(() => {
        t(), e();
      });
    });
  }
  _notifySubscribers() {
    const e = [];
    for (const t of this._subscribers)
      try {
        t();
      } catch (n) {
        e.push(n);
      }
    if (e.length > 0)
      throw e.length === 1 ? e[0] : new AggregateError(e);
  }
}, m6 = (e) => e.status.type === "complete", n$ = class extends Ef {
  isEditing = !0;
  getAttachmentAccept() {
    return this.getAttachmentAdapter()?.accept ?? "*";
  }
  _attachments = [];
  get attachments() {
    return this._attachments;
  }
  setAttachments(e) {
    this._attachments = e, this._notifySubscribers();
  }
  get isEmpty() {
    return !this.text.trim() && !this.attachments.length;
  }
  _text = "";
  get text() {
    return this._text;
  }
  _role = "user";
  get role() {
    return this._role;
  }
  _runConfig = {};
  get runConfig() {
    return this._runConfig;
  }
  setText(e) {
    this._text !== e && (this._text = e, this._notifySubscribers());
  }
  setRole(e) {
    this._role !== e && (this._role = e, this._notifySubscribers());
  }
  setRunConfig(e) {
    this._runConfig !== e && (this._runConfig = e, this._notifySubscribers());
  }
  _emptyTextAndAttachments() {
    this._attachments = [], this._text = "", this._notifySubscribers();
  }
  async _onClearAttachments() {
    const e = this.getAttachmentAdapter();
    e && await Promise.all(this._attachments.map((t) => e.remove(t)));
  }
  async reset() {
    if (this._attachments.length === 0 && this._text === "" && this._role === "user" && Object.keys(this._runConfig).length === 0)
      return;
    this._role = "user", this._runConfig = {};
    const e = this._onClearAttachments();
    this._emptyTextAndAttachments(), await e;
  }
  async clearAttachments() {
    const e = this._onClearAttachments();
    this.setAttachments([]), await e;
  }
  async send() {
    const e = this.getAttachmentAdapter(), t = e && this.attachments.length > 0 ? await Promise.all(
      this.attachments.map(async (i) => m6(i) ? i : await e.send(i))
    ) : [], n = {
      createdAt: /* @__PURE__ */ new Date(),
      role: this.role,
      content: this.text ? [{ type: "text", text: this.text }] : [],
      attachments: t,
      runConfig: this.runConfig,
      metadata: { custom: {} }
    };
    this._emptyTextAndAttachments(), this.handleSend(n), this._notifyEventSubscribers("send");
  }
  cancel() {
    this.handleCancel();
  }
  async addAttachment(e) {
    const t = this.getAttachmentAdapter();
    if (!t) throw new Error("Attachments are not supported");
    const n = (r) => {
      const s = this._attachments.findIndex(
        (l) => l.id === r.id
      );
      s !== -1 ? this._attachments = [
        ...this._attachments.slice(0, s),
        r,
        ...this._attachments.slice(s + 1)
      ] : (this._attachments = [...this._attachments, r], this._notifyEventSubscribers("attachment_add")), this._notifySubscribers();
    }, i = t.add({ file: e });
    if (Symbol.asyncIterator in i)
      for await (const r of i)
        n(r);
    else
      n(await i);
    this._notifyEventSubscribers("attachment_add"), this._notifySubscribers();
  }
  async removeAttachment(e) {
    const t = this.getAttachmentAdapter();
    if (!t) throw new Error("Attachments are not supported");
    const n = this._attachments.findIndex((r) => r.id === e);
    if (n === -1) throw new Error("Attachment not found");
    const i = this._attachments[n];
    await t.remove(i), this._attachments = [
      ...this._attachments.slice(0, n),
      ...this._attachments.slice(n + 1)
    ], this._notifySubscribers();
  }
  _eventSubscribers = /* @__PURE__ */ new Map();
  _notifyEventSubscribers(e) {
    const t = this._eventSubscribers.get(e);
    if (t)
      for (const n of t) n();
  }
  unstable_on(e, t) {
    const n = this._eventSubscribers.get(e);
    return n ? n.add(t) : this._eventSubscribers.set(e, /* @__PURE__ */ new Set([t])), () => {
      const i = this._eventSubscribers.get(e);
      i && i.delete(t);
    };
  }
}, r$ = class extends n$ {
  constructor(e) {
    super(), this.runtime = e, this.connect();
  }
  _canCancel = !1;
  get canCancel() {
    return this._canCancel;
  }
  get attachments() {
    return super.attachments;
  }
  getAttachmentAdapter() {
    return this.runtime.adapters?.attachments;
  }
  connect() {
    return this.runtime.subscribe(() => {
      this.canCancel !== this.runtime.capabilities.cancel && (this._canCancel = this.runtime.capabilities.cancel, this._notifySubscribers());
    });
  }
  async handleSend(e) {
    this.runtime.append({
      ...e,
      parentId: this.runtime.messages.at(-1)?.id ?? null,
      sourceId: null
    });
  }
  async handleCancel() {
    this.runtime.cancelRun();
  }
};
let g6 = (e, t = 21) => (n = t) => {
  let i = "", r = n | 0;
  for (; r--; )
    i += e[Math.random() * e.length | 0];
  return i;
};
var xu = g6(
  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  7
), v6 = "__optimistic__", y6 = () => `${v6}${xu()}`, i$ = Object.freeze({ type: "running" }), a$ = Object.freeze({
  type: "complete",
  reason: "unknown"
}), b6 = Object.freeze({
  type: "requires-action",
  reason: "tool-calls"
}), s$ = (e) => e === i$ || e === a$, wu = (e, t, n) => e && t ? i$ : n ? b6 : a$, Ca = { exports: {} }, u1;
function x6() {
  if (u1) return Ca.exports;
  u1 = 1;
  const e = typeof Buffer < "u", t = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/, n = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
  function i(c, f, h) {
    h == null && f !== null && typeof f == "object" && (h = f, f = void 0), e && Buffer.isBuffer(c) && (c = c.toString()), c && c.charCodeAt(0) === 65279 && (c = c.slice(1));
    const p = JSON.parse(c, f);
    if (p === null || typeof p != "object")
      return p;
    const m = h && h.protoAction || "error", y = h && h.constructorAction || "error";
    if (m === "ignore" && y === "ignore")
      return p;
    if (m !== "ignore" && y !== "ignore") {
      if (t.test(c) === !1 && n.test(c) === !1)
        return p;
    } else if (m !== "ignore" && y === "ignore") {
      if (t.test(c) === !1)
        return p;
    } else if (n.test(c) === !1)
      return p;
    return r(p, { protoAction: m, constructorAction: y, safe: h && h.safe });
  }
  function r(c, { protoAction: f = "error", constructorAction: h = "error", safe: p } = {}) {
    let m = [c];
    for (; m.length; ) {
      const y = m;
      m = [];
      for (const b of y) {
        if (f !== "ignore" && Object.prototype.hasOwnProperty.call(b, "__proto__")) {
          if (p === !0)
            return null;
          if (f === "error")
            throw new SyntaxError("Object contains forbidden prototype property");
          delete b.__proto__;
        }
        if (h !== "ignore" && Object.prototype.hasOwnProperty.call(b, "constructor") && Object.prototype.hasOwnProperty.call(b.constructor, "prototype")) {
          if (p === !0)
            return null;
          if (h === "error")
            throw new SyntaxError("Object contains forbidden prototype property");
          delete b.constructor;
        }
        for (const x in b) {
          const w = b[x];
          w && typeof w == "object" && m.push(w);
        }
      }
    }
    return c;
  }
  function s(c, f, h) {
    const { stackTraceLimit: p } = Error;
    Error.stackTraceLimit = 0;
    try {
      return i(c, f, h);
    } finally {
      Error.stackTraceLimit = p;
    }
  }
  function l(c, f) {
    const { stackTraceLimit: h } = Error;
    Error.stackTraceLimit = 0;
    try {
      return i(c, f, { safe: !0 });
    } catch {
      return;
    } finally {
      Error.stackTraceLimit = h;
    }
  }
  return Ca.exports = s, Ca.exports.default = s, Ca.exports.parse = s, Ca.exports.safeParse = l, Ca.exports.scan = r, Ca.exports;
}
var w6 = x6();
const c1 = /* @__PURE__ */ la(w6);
function _6(e) {
  const t = ["ROOT"];
  let n = -1, i = null;
  const r = [];
  let s;
  function l() {
    s !== void 0 && (r.push(JSON.parse('"' + s + '"')), s = void 0);
  }
  function c(m, y, b) {
    switch (m) {
      case '"': {
        n = y, t.pop(), t.push(b), t.push("INSIDE_STRING"), l();
        break;
      }
      case "f":
      case "t":
      case "n": {
        n = y, i = y, t.pop(), t.push(b), t.push("INSIDE_LITERAL");
        break;
      }
      case "-": {
        t.pop(), t.push(b), t.push("INSIDE_NUMBER"), l();
        break;
      }
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9": {
        n = y, t.pop(), t.push(b), t.push("INSIDE_NUMBER"), l();
        break;
      }
      case "{": {
        n = y, t.pop(), t.push(b), t.push("INSIDE_OBJECT_START"), l();
        break;
      }
      case "[": {
        n = y, t.pop(), t.push(b), t.push("INSIDE_ARRAY_START"), l();
        break;
      }
    }
  }
  function f(m, y) {
    switch (m) {
      case ",": {
        t.pop(), t.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        n = y, t.pop(), s = r.pop();
        break;
      }
    }
  }
  function h(m, y) {
    switch (m) {
      case ",": {
        t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA"), s = (Number(s) + 1).toString();
        break;
      }
      case "]": {
        n = y, t.pop(), s = r.pop();
        break;
      }
    }
  }
  for (let m = 0; m < e.length; m++) {
    const y = e[m];
    switch (t[t.length - 1]) {
      case "ROOT":
        c(y, m, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (y) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_KEY"), s = "";
            break;
          }
          case "}": {
            n = m, t.pop(), s = r.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (y) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_KEY"), s = "";
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (y) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
          case "\\": {
            t.push("INSIDE_STRING_ESCAPE"), s += y;
            break;
          }
          default: {
            s += y;
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (y) {
          case ":": {
            t.pop(), t.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        c(y, m, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        f(y, m);
        break;
      }
      case "INSIDE_STRING": {
        switch (y) {
          case '"': {
            t.pop(), n = m, s = r.pop();
            break;
          }
          case "\\": {
            t.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default:
            n = m;
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (y) {
          case "]": {
            n = m, t.pop(), s = r.pop();
            break;
          }
          default: {
            n = m, s = "0", c(y, m, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (y) {
          case ",": {
            t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA"), s = (Number(s) + 1).toString();
            break;
          }
          case "]": {
            n = m, t.pop(), s = r.pop();
            break;
          }
          default: {
            n = m;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        c(y, m, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        t.pop(), t[t.length - 1] === "INSIDE_STRING" ? n = m : t[t.length - 1] === "INSIDE_OBJECT_KEY" && (s += y);
        break;
      }
      case "INSIDE_NUMBER": {
        switch (y) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            n = m;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".":
            break;
          case ",": {
            t.pop(), s = r.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && h(y, m), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && f(y, m);
            break;
          }
          case "}": {
            t.pop(), s = r.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && f(y, m);
            break;
          }
          case "]": {
            t.pop(), s = r.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && h(y, m);
            break;
          }
          default: {
            t.pop(), s = r.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const x = e.substring(i, m + 1);
        !"false".startsWith(x) && !"true".startsWith(x) && !"null".startsWith(x) ? (t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" ? f(y, m) : t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && h(y, m)) : n = m;
        break;
      }
    }
  }
  let p = e.slice(0, n + 1);
  for (let m = t.length - 1; m >= 0; m--)
    switch (t[m]) {
      case "INSIDE_STRING": {
        p += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        p += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        p += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const b = e.substring(i, e.length);
        "true".startsWith(b) ? p += "true".slice(b.length) : "false".startsWith(b) ? p += "false".slice(b.length) : "null".startsWith(b) && (p += "null".slice(b.length));
      }
    }
  return [p, r];
}
var Dm = Symbol(
  "aui.parse-partial-json-object.meta"
), o$ = (e) => {
  if (e.length === 0)
    return {
      [Dm]: { state: "partial", partialPath: [] }
    };
  try {
    const t = c1.parse(e);
    if (typeof t != "object" || t === null)
      throw new Error("argsText is expected to be an object");
    return t[Dm] = {
      state: "complete",
      partialPath: []
    }, t;
  } catch {
    try {
      const [t, n] = _6(e), i = c1.parse(t);
      if (typeof i != "object" || i === null)
        throw new Error("argsText is expected to be an object");
      return i[Dm] = {
        state: "partial",
        partialPath: n
      }, i;
    } catch {
      return;
    }
  }
}, Wa = (e, t, n) => {
  const { role: i, id: r, createdAt: s, attachments: l, status: c, metadata: f } = e, h = {
    id: r ?? t,
    createdAt: s ?? /* @__PURE__ */ new Date()
  }, p = typeof e.content == "string" ? [{ type: "text", text: e.content }] : e.content, m = ({
    image: y,
    ...b
  }) => y.match(
    /^data:image\/(png|jpeg|jpg|gif|webp);base64,(.*)$/
  ) ? { ...b, image: y } : (console.warn("Invalid image data format detected"), null);
  if (i !== "user" && l?.length)
    throw new Error("attachments are only supported for user messages");
  if (i !== "assistant" && c)
    throw new Error("status is only supported for assistant messages");
  if (i !== "assistant" && f?.steps)
    throw new Error("metadata.steps is only supported for assistant messages");
  switch (i) {
    case "assistant":
      return {
        ...h,
        role: i,
        content: p.map((y) => {
          const b = y.type;
          switch (b) {
            case "text":
            case "reasoning":
              return y.text.trim().length === 0 ? null : y;
            case "file":
            case "source":
              return y;
            case "image":
              return m(y);
            case "tool-call": {
              const { parentId: x, ...w } = y, k = {
                ...w,
                toolCallId: y.toolCallId ?? "tool-" + xu(),
                ...x !== void 0 && { parentId: x }
              };
              return y.args ? {
                ...k,
                args: y.args,
                argsText: JSON.stringify(y.args)
              } : {
                ...k,
                args: y.args ?? o$(y.argsText ?? "") ?? {},
                argsText: y.argsText ?? ""
              };
            }
            default: {
              const x = b;
              throw new Error(
                `Unsupported assistant message part type: ${x}`
              );
            }
          }
        }).filter((y) => !!y),
        status: c ?? n,
        metadata: {
          unstable_state: f?.unstable_state ?? null,
          unstable_annotations: f?.unstable_annotations ?? [],
          unstable_data: f?.unstable_data ?? [],
          custom: f?.custom ?? {},
          steps: f?.steps ?? []
        }
      };
    case "user":
      return {
        ...h,
        role: i,
        content: p.map((y) => {
          const b = y.type;
          switch (b) {
            case "text":
            case "image":
            case "audio":
            case "file":
              return y;
            default: {
              const x = b;
              throw new Error(
                `Unsupported user message part type: ${x}`
              );
            }
          }
        }),
        attachments: l ?? [],
        metadata: {
          custom: f?.custom ?? {}
        }
      };
    case "system":
      if (p.length !== 1 || p[0].type !== "text")
        throw new Error(
          "System messages must have exactly one text message part."
        );
      return {
        ...h,
        role: i,
        content: p,
        metadata: {
          custom: f?.custom ?? {}
        }
      };
    default: {
      const y = i;
      throw new Error(`Unknown message role: ${y}`);
    }
  }
}, l$ = {
  /**
   * Converts an array of messages to an ExportedMessageRepository format.
   * Creates parent-child relationships based on the order of messages in the array.
   *
   * @param messages - Array of message-like objects to convert
   * @returns ExportedMessageRepository with parent-child relationships established
   */
  fromArray: (e) => {
    const t = e.map(
      (n) => Wa(
        n,
        xu(),
        wu(!1, !1, !1)
      )
    );
    return {
      messages: t.map((n, i) => ({
        parentId: i > 0 ? t[i - 1].id : null,
        message: n
      }))
    };
  }
}, Nd = (e) => e.next ? Nd(e.next) : "current" in e ? e : null, S6 = class {
  /**
   * @param func - The function that computes the cached value
   */
  constructor(e) {
    this.func = e;
  }
  _value = null;
  /**
   * Gets the cached value, computing it if necessary.
   */
  get value() {
    return this._value === null && (this._value = this.func()), this._value;
  }
  /**
   * Invalidates the cache, forcing recomputation on next access.
   */
  dirty() {
    this._value = null;
  }
}, u$ = class {
  /** Map of message IDs to repository message objects */
  messages = /* @__PURE__ */ new Map();
  /** Reference to the current head (most recent) message in the active branch */
  head = null;
  /** Root node of the tree structure */
  root = {
    children: [],
    next: null
  };
  /**
   * Performs link/unlink operations between messages in the tree.
   *
   * @param newParent - The new parent message, or null
   * @param child - The child message to operate on
   * @param operation - The type of operation to perform:
   *   - "cut": Remove the child from its current parent
   *   - "link": Add the child to a new parent
   *   - "relink": Both cut and link operations
   */
  performOp(t, n, i) {
    const r = n.prev ?? this.root, s = t ?? this.root;
    if (!(i === "relink" && r === s)) {
      if (i !== "link" && (r.children = r.children.filter(
        (l) => l !== n.current.id
      ), r.next === n)) {
        const l = r.children.at(-1), c = l ? this.messages.get(l) : null;
        if (c === void 0)
          throw new Error(
            "MessageRepository(performOp/cut): Fallback sibling message not found. This is likely an internal bug in assistant-ui."
          );
        r.next = c;
      }
      if (i !== "cut") {
        for (let l = t; l; l = l.prev)
          if (l.current.id === n.current.id)
            throw new Error(
              "MessageRepository(performOp/link): A message with the same id already exists in the parent tree. This error occurs if the same message id is found multiple times. This is likely an internal bug in assistant-ui."
            );
        s.children = [
          ...s.children,
          n.current.id
        ], (Nd(n) === this.head || s.next === null) && (s.next = n), n.prev = t;
      }
    }
  }
  /** Cached array of messages in the current active branch, from root to head */
  _messages = new S6(() => {
    const t = new Array(this.head?.level ?? 0);
    for (let n = this.head; n; n = n.prev)
      t[n.level] = n.current;
    return t;
  });
  /**
   * Gets the ID of the current head message.
   * @returns The ID of the head message, or null if no messages exist
   */
  get headId() {
    return this.head?.current.id ?? null;
  }
  /**
   * Gets all messages in the current active branch, from root to head.
   * @returns Array of messages in the current branch
   */
  getMessages() {
    return this._messages.value;
  }
  /**
   * Adds a new message or updates an existing one in the repository.
   * If the message ID already exists, the message is updated and potentially relinked to a new parent.
   * If the message is new, it's added as a child of the specified parent.
   *
   * @param parentId - ID of the parent message, or null for root messages
   * @param message - The message to add or update
   * @throws Error if the parent message is not found
   */
  addOrUpdateMessage(t, n) {
    const i = this.messages.get(n.id), r = t ? this.messages.get(t) : null;
    if (r === void 0)
      throw new Error(
        "MessageRepository(addOrUpdateMessage): Parent message not found. This is likely an internal bug in assistant-ui."
      );
    if (i) {
      i.current = n, this.performOp(r, i, "relink"), this._messages.dirty();
      return;
    }
    const s = {
      prev: r,
      current: n,
      next: null,
      children: [],
      level: r ? r.level + 1 : 0
    };
    this.messages.set(n.id, s), this.performOp(r, s, "link"), this.head === r && (this.head = s), this._messages.dirty();
  }
  /**
   * Gets a message and its parent ID by message ID.
   *
   * @param messageId - ID of the message to retrieve
   * @returns Object containing the message and its parent ID
   * @throws Error if the message is not found
   */
  getMessage(t) {
    const n = this.messages.get(t);
    if (!n)
      throw new Error(
        "MessageRepository(updateMessage): Message not found. This is likely an internal bug in assistant-ui."
      );
    return {
      parentId: n.prev?.current.id ?? null,
      message: n.current
    };
  }
  /**
   * Adds an optimistic message to the repository.
   * An optimistic message is a temporary placeholder that will be replaced by a real message later.
   *
   * @param parentId - ID of the parent message, or null for root messages
   * @param message - The core message to convert to an optimistic message
   * @returns The generated optimistic ID
   */
  appendOptimisticMessage(t, n) {
    let i;
    do
      i = y6();
    while (this.messages.has(i));
    return this.addOrUpdateMessage(
      t,
      Wa(n, i, { type: "running" })
    ), i;
  }
  /**
   * Deletes a message from the repository and relinks its children.
   *
   * @param messageId - ID of the message to delete
   * @param replacementId - Optional ID of the message to become the new parent of the children,
   *                       undefined means use the deleted message's parent,
   *                       null means use the root
   * @throws Error if the message or replacement is not found
   */
  deleteMessage(t, n) {
    const i = this.messages.get(t);
    if (!i)
      throw new Error(
        "MessageRepository(deleteMessage): Message not found. This is likely an internal bug in assistant-ui."
      );
    const r = n === void 0 ? i.prev : n === null ? null : this.messages.get(n);
    if (r === void 0)
      throw new Error(
        "MessageRepository(deleteMessage): Replacement not found. This is likely an internal bug in assistant-ui."
      );
    for (const s of i.children) {
      const l = this.messages.get(s);
      if (!l)
        throw new Error(
          "MessageRepository(deleteMessage): Child message not found. This is likely an internal bug in assistant-ui."
        );
      this.performOp(r, l, "relink");
    }
    this.performOp(null, i, "cut"), this.messages.delete(t), this.head === i && (this.head = Nd(r ?? this.root)), this._messages.dirty();
  }
  /**
   * Gets all branch IDs (sibling messages) at the level of a specified message.
   *
   * @param messageId - ID of the message to find branches for
   * @returns Array of message IDs representing branches
   * @throws Error if the message is not found
   */
  getBranches(t) {
    const n = this.messages.get(t);
    if (!n)
      throw new Error(
        "MessageRepository(getBranches): Message not found. This is likely an internal bug in assistant-ui."
      );
    const { children: i } = n.prev ?? this.root;
    return i;
  }
  /**
   * Switches the active branch to the one containing the specified message.
   *
   * @param messageId - ID of the message in the branch to switch to
   * @throws Error if the branch is not found
   */
  switchToBranch(t) {
    const n = this.messages.get(t);
    if (!n)
      throw new Error(
        "MessageRepository(switchToBranch): Branch not found. This is likely an internal bug in assistant-ui."
      );
    const i = n.prev ?? this.root;
    i.next = n, this.head = Nd(n), this._messages.dirty();
  }
  /**
   * Resets the head to a specific message or null.
   *
   * @param messageId - ID of the message to set as head, or null to clear the head
   * @throws Error if the message is not found
   */
  resetHead(t) {
    if (t === null) {
      this.head = null, this._messages.dirty();
      return;
    }
    const n = this.messages.get(t);
    if (!n)
      throw new Error(
        "MessageRepository(resetHead): Branch not found. This is likely an internal bug in assistant-ui."
      );
    this.head = n;
    for (let i = n; i; i = i.prev)
      i.prev && (i.prev.next = i);
    this._messages.dirty();
  }
  /**
   * Clears all messages from the repository.
   */
  clear() {
    this.messages.clear(), this.head = null, this.root = {
      children: [],
      next: null
    }, this._messages.dirty();
  }
  /**
   * Exports the repository state for persistence.
   *
   * @returns Exportable repository state
   */
  export() {
    const t = [];
    for (const [, n] of this.messages)
      t.push({
        message: n.current,
        parentId: n.prev?.current.id ?? null
      });
    return {
      headId: this.head?.current.id ?? null,
      messages: t
    };
  }
  /**
   * Imports repository state from an exported repository.
   *
   * @param repository - The exported repository state to import
   */
  import({ headId: t, messages: n }) {
    for (const { message: i, parentId: r } of n)
      this.addOrUpdateMessage(r, i);
    this.resetHead(t ?? n.at(-1)?.message.id ?? null);
  }
}, $f = class {
  _subscriptions = /* @__PURE__ */ new Set();
  _connection;
  get isConnected() {
    return !!this._connection;
  }
  notifySubscribers() {
    for (const e of this._subscriptions) e();
  }
  _updateConnection() {
    if (this._subscriptions.size > 0) {
      if (this._connection) return;
      this._connection = this._connect();
    } else
      this._connection?.(), this._connection = void 0;
  }
  subscribe(e) {
    return this._subscriptions.add(e), this._updateConnection(), () => {
      this._subscriptions.delete(e), this._updateConnection();
    };
  }
}, kr = Symbol("skip-update"), Zv = class extends $f {
  constructor(e) {
    super(), this.binding = e;
  }
  get path() {
    return this.binding.path;
  }
  _previousStateDirty = !0;
  _previousState;
  getState = () => {
    if (!this.isConnected || this._previousStateDirty) {
      const e = this.binding.getState();
      e !== kr && (this._previousState = e), this._previousStateDirty = !1;
    }
    if (this._previousState === void 0)
      throw new Error("Entry not available in the store");
    return this._previousState;
  };
  _connect() {
    const e = () => {
      this._previousStateDirty = !0, this.notifySubscribers();
    };
    return this.binding.subscribe(e);
  }
}, dd = class {
  constructor(e, t) {
    this._core = e, this._threadListBinding = t;
  }
  get path() {
    return this._core.path;
  }
  __internal_bindMethods() {
    this.switchTo = this.switchTo.bind(this), this.rename = this.rename.bind(this), this.archive = this.archive.bind(this), this.unarchive = this.unarchive.bind(this), this.delete = this.delete.bind(this), this.initialize = this.initialize.bind(this), this.generateTitle = this.generateTitle.bind(this), this.subscribe = this.subscribe.bind(this), this.unstable_on = this.unstable_on.bind(this), this.getState = this.getState.bind(this), this.detach = this.detach.bind(this);
  }
  getState() {
    return this._core.getState();
  }
  switchTo() {
    const e = this._core.getState();
    return this._threadListBinding.switchToThread(e.id);
  }
  rename(e) {
    const t = this._core.getState();
    return this._threadListBinding.rename(t.id, e);
  }
  archive() {
    const e = this._core.getState();
    return this._threadListBinding.archive(e.id);
  }
  unarchive() {
    const e = this._core.getState();
    return this._threadListBinding.unarchive(e.id);
  }
  delete() {
    const e = this._core.getState();
    return this._threadListBinding.delete(e.id);
  }
  initialize() {
    const e = this._core.getState();
    return this._threadListBinding.initialize(e.id);
  }
  generateTitle() {
    const e = this._core.getState();
    return this._threadListBinding.generateTitle(e.id);
  }
  unstable_on(e, t) {
    let n = this._core.getState().isMain;
    return this.subscribe(() => {
      const i = this._core.getState().isMain;
      n !== i && (n = i, !(e === "switched-to" && !i) && (e === "switched-away" && i || t()));
    });
  }
  subscribe(e) {
    return this._core.subscribe(e);
  }
  detach() {
    const e = this._core.getState();
    this._threadListBinding.detach(e.id);
  }
};
function k6(e, t) {
  if (e === void 0 && t === void 0) return !0;
  if (e === void 0 || t === void 0) return !1;
  for (const n of Object.keys(e)) {
    const i = e[n], r = t[n];
    if (!Object.is(i, r)) return !1;
  }
  return !0;
}
var xr = class extends $f {
  constructor(e) {
    super(), this.binding = e;
    const t = e.getState();
    if (t === kr)
      throw new Error("Entry not available in the store");
    this._previousState = t;
  }
  get path() {
    return this.binding.path;
  }
  _previousState;
  getState = () => (this.isConnected || this._syncState(), this._previousState);
  _syncState() {
    const e = this.binding.getState();
    return e === kr || k6(e, this._previousState) ? !1 : (this._previousState = e, !0);
  }
  _connect() {
    const e = () => {
      this._syncState() && this.notifySubscribers();
    };
    return this.binding.subscribe(e);
  }
}, Vn = Symbol("innerMessage"), jm = Symbol("innerMessages"), T6 = (e) => e[Vn], E6 = [], Za = (e) => {
  const t = "messages" in e ? e.messages : e, n = t[jm] || t[Vn];
  return n ? Array.isArray(n) ? n : (t[jm] = [n], t[jm]) : E6;
}, eu = (e) => e.content.filter(
  (n) => n.type === "text"
).map((n) => n.text).join(`

`), c$ = class {
  constructor(e) {
    this._core = e;
  }
  get path() {
    return this._core.path;
  }
  __internal_bindMethods() {
    this.getState = this.getState.bind(this), this.remove = this.remove.bind(this), this.subscribe = this.subscribe.bind(this);
  }
  getState() {
    return this._core.getState();
  }
  subscribe(e) {
    return this._core.subscribe(e);
  }
}, d$ = class extends c$ {
  constructor(e, t) {
    super(e), this._composerApi = t;
  }
  remove() {
    const e = this._composerApi.getState();
    if (!e) throw new Error("Composer is not available");
    return e.removeAttachment(this.getState().id);
  }
}, $6 = class extends d$ {
  get source() {
    return "thread-composer";
  }
}, A6 = class extends d$ {
  get source() {
    return "edit-composer";
  }
}, z6 = class extends c$ {
  get source() {
    return "message";
  }
  constructor(e) {
    super(e);
  }
  remove() {
    throw new Error("Message attachments cannot be removed");
  }
}, f$ = class extends $f {
  constructor(e) {
    super(), this.config = e;
  }
  getState() {
    return this.config.binding.getState();
  }
  outerSubscribe(e) {
    return this.config.binding.subscribe(e);
  }
  _connect() {
    const e = () => {
      this.notifySubscribers();
    };
    let t = this.config.binding.getState(), n = t?.unstable_on(this.config.event, e);
    const i = () => {
      const s = this.config.binding.getState();
      s !== t && (t = s, n?.(), n = this.config.binding.getState()?.unstable_on(this.config.event, e));
    }, r = this.outerSubscribe(i);
    return () => {
      r?.(), n?.();
    };
  }
}, h$ = Object.freeze([]), p$ = Object.freeze({}), I6 = (e) => Object.freeze({
  type: "thread",
  isEditing: e?.isEditing ?? !1,
  canCancel: e?.canCancel ?? !1,
  isEmpty: e?.isEmpty ?? !0,
  attachments: e?.attachments ?? h$,
  text: e?.text ?? "",
  role: e?.role ?? "user",
  runConfig: e?.runConfig ?? p$,
  value: e?.text ?? ""
}), C6 = (e) => Object.freeze({
  type: "edit",
  isEditing: e?.isEditing ?? !1,
  canCancel: e?.canCancel ?? !1,
  isEmpty: e?.isEmpty ?? !0,
  text: e?.text ?? "",
  role: e?.role ?? "user",
  attachments: e?.attachments ?? h$,
  runConfig: e?.runConfig ?? p$,
  value: e?.text ?? ""
}), m$ = class {
  constructor(e) {
    this._core = e;
  }
  get path() {
    return this._core.path;
  }
  __internal_bindMethods() {
    this.setText = this.setText.bind(this), this.setRunConfig = this.setRunConfig.bind(this), this.getState = this.getState.bind(this), this.subscribe = this.subscribe.bind(this), this.addAttachment = this.addAttachment.bind(this), this.reset = this.reset.bind(this), this.clearAttachments = this.clearAttachments.bind(this), this.send = this.send.bind(this), this.cancel = this.cancel.bind(this), this.setRole = this.setRole.bind(this), this.getAttachmentAccept = this.getAttachmentAccept.bind(this), this.getAttachmentByIndex = this.getAttachmentByIndex.bind(this), this.unstable_on = this.unstable_on.bind(this);
  }
  setText(e) {
    const t = this._core.getState();
    if (!t) throw new Error("Composer is not available");
    t.setText(e);
  }
  setRunConfig(e) {
    const t = this._core.getState();
    if (!t) throw new Error("Composer is not available");
    t.setRunConfig(e);
  }
  addAttachment(e) {
    const t = this._core.getState();
    if (!t) throw new Error("Composer is not available");
    return t.addAttachment(e);
  }
  reset() {
    const e = this._core.getState();
    if (!e) throw new Error("Composer is not available");
    return e.reset();
  }
  clearAttachments() {
    const e = this._core.getState();
    if (!e) throw new Error("Composer is not available");
    return e.clearAttachments();
  }
  send() {
    const e = this._core.getState();
    if (!e) throw new Error("Composer is not available");
    e.send();
  }
  cancel() {
    const e = this._core.getState();
    if (!e) throw new Error("Composer is not available");
    e.cancel();
  }
  setRole(e) {
    const t = this._core.getState();
    if (!t) throw new Error("Composer is not available");
    t.setRole(e);
  }
  subscribe(e) {
    return this._core.subscribe(e);
  }
  _eventSubscriptionSubjects = /* @__PURE__ */ new Map();
  unstable_on(e, t) {
    let n = this._eventSubscriptionSubjects.get(e);
    return n || (n = new f$({
      event: e,
      binding: this._core
    }), this._eventSubscriptionSubjects.set(e, n)), n.subscribe(t);
  }
  getAttachmentAccept() {
    const e = this._core.getState();
    if (!e) throw new Error("Composer is not available");
    return e.getAttachmentAccept();
  }
}, O6 = class extends m$ {
  get path() {
    return this._core.path;
  }
  get type() {
    return "thread";
  }
  _getState;
  constructor(e) {
    const t = new Zv({
      path: e.path,
      getState: () => I6(e.getState()),
      subscribe: (n) => e.subscribe(n)
    });
    super({
      path: e.path,
      getState: () => e.getState(),
      subscribe: (n) => t.subscribe(n)
    }), this._getState = t.getState.bind(t);
  }
  getState() {
    return this._getState();
  }
  getAttachmentByIndex(e) {
    return new $6(
      new xr({
        path: {
          ...this.path,
          attachmentSource: "thread-composer",
          attachmentSelector: { type: "index", index: e },
          ref: this.path.ref + `${this.path.ref}.attachments[${e}]`
        },
        getState: () => {
          const n = this.getState().attachments[e];
          return n ? {
            ...n,
            source: "thread-composer"
          } : kr;
        },
        subscribe: (t) => this._core.subscribe(t)
      }),
      this._core
    );
  }
}, R6 = class extends m$ {
  constructor(e, t) {
    const n = new Zv({
      path: e.path,
      getState: () => C6(e.getState()),
      subscribe: (i) => e.subscribe(i)
    });
    super({
      path: e.path,
      getState: () => e.getState(),
      subscribe: (i) => n.subscribe(i)
    }), this._beginEdit = t, this._getState = n.getState.bind(n);
  }
  get path() {
    return this._core.path;
  }
  get type() {
    return "edit";
  }
  _getState;
  __internal_bindMethods() {
    super.__internal_bindMethods(), this.beginEdit = this.beginEdit.bind(this);
  }
  getState() {
    return this._getState();
  }
  beginEdit() {
    this._beginEdit();
  }
  getAttachmentByIndex(e) {
    return new A6(
      new xr({
        path: {
          ...this.path,
          attachmentSource: "edit-composer",
          attachmentSelector: { type: "index", index: e },
          ref: this.path.ref + `${this.path.ref}.attachments[${e}]`
        },
        getState: () => {
          const n = this.getState().attachments[e];
          return n ? {
            ...n,
            source: "edit-composer"
          } : kr;
        },
        subscribe: (t) => this._core.subscribe(t)
      }),
      this._core
    );
  }
}, zg = {
  toResponse(e, t) {
    return new Response(zg.toByteStream(e, t), {
      headers: t.headers ?? {}
    });
  },
  fromResponse(e, t) {
    return zg.fromByteStream(e.body, t);
  },
  toByteStream(e, t) {
    return e.pipeThrough(t);
  },
  fromByteStream(e, t) {
    return e.pipeThrough(t);
  }
}, g$ = function() {
  let e, t;
  const n = new Promise((i, r) => {
    e = i, t = r;
  });
  if (!e || !t) throw new Error("Failed to create promise");
  return { promise: n, resolve: e, reject: t };
}, N6 = () => {
  const e = [];
  let t = !1, n, i;
  const r = (l) => {
    l.promise || (l.promise = l.reader.read().then(({ done: c, value: f }) => {
      l.promise = void 0, c ? (e.splice(e.indexOf(l), 1), t && e.length === 0 && n.close()) : n.enqueue(f), i?.resolve(), i = void 0;
    }).catch((c) => {
      console.error(c), e.forEach((f) => {
        f.reader.cancel();
      }), e.length = 0, n.error(c), i?.reject(c), i = void 0;
    }));
  };
  return {
    readable: new ReadableStream({
      start(l) {
        n = l;
      },
      pull() {
        return i = g$(), e.forEach((l) => {
          r(l);
        }), i.promise;
      },
      cancel() {
        e.forEach((l) => {
          l.reader.cancel();
        }), e.length = 0;
      }
    }),
    isSealed() {
      return t;
    },
    seal() {
      t = !0, e.length === 0 && n.close();
    },
    addStream(l) {
      if (t)
        throw new Error(
          "Cannot add streams after the run callback has settled."
        );
      const c = { reader: l.getReader() };
      e.push(c), r(c);
    },
    enqueue(l) {
      this.addStream(
        new ReadableStream({
          start(c) {
            c.enqueue(l), c.close();
          }
        })
      );
    }
  };
}, d1 = class {
  _controller;
  _isClosed = !1;
  constructor(e) {
    this._controller = e;
  }
  append(e) {
    return this._controller.enqueue({
      type: "text-delta",
      path: [],
      textDelta: e
    }), this;
  }
  close() {
    this._isClosed || (this._isClosed = !0, this._controller.enqueue({
      type: "part-finish",
      path: []
    }), this._controller.close());
  }
}, v$ = (e) => new ReadableStream({
  start(t) {
    return e.start?.(new d1(t));
  },
  pull(t) {
    return e.pull?.(new d1(t));
  },
  cancel(t) {
    return e.cancel?.(t);
  }
}), f1 = () => {
  let e;
  return [v$({
    start(n) {
      e = n;
    }
  }), e];
}, h1 = class {
  constructor(e) {
    this._controller = e;
    const t = v$({
      start: (i) => {
        this._argsTextController = i;
      }
    });
    let n = !1;
    this._mergeTask = t.pipeTo(
      new WritableStream({
        write: (i) => {
          switch (i.type) {
            case "text-delta":
              n = !0, this._controller.enqueue(i);
              break;
            case "part-finish":
              n || this._controller.enqueue({
                type: "text-delta",
                textDelta: "{}",
                path: []
              }), this._controller.enqueue({
                type: "tool-call-args-text-finish",
                path: []
              });
              break;
            default:
              throw new Error(`Unexpected chunk type: ${i.type}`);
          }
        }
      })
    );
  }
  _isClosed = !1;
  _mergeTask;
  get argsText() {
    return this._argsTextController;
  }
  _argsTextController;
  async setResponse(e) {
    this._argsTextController.close(), await Promise.resolve(), this._controller.enqueue({
      type: "result",
      path: [],
      ...e.artifact !== void 0 ? { artifact: e.artifact } : {},
      result: e.result,
      isError: e.isError ?? !1
    });
  }
  async close() {
    this._isClosed || (this._isClosed = !0, this._argsTextController.close(), await this._mergeTask, this._controller.enqueue({
      type: "part-finish",
      path: []
    }), this._controller.close());
  }
}, M6 = (e) => new ReadableStream({
  start(t) {
    return e.start?.(new h1(t));
  },
  pull(t) {
    return e.pull?.(new h1(t));
  },
  cancel(t) {
    return e.cancel?.(t);
  }
}), D6 = () => {
  let e;
  return [M6({
    start(n) {
      e = n;
    }
  }), e];
}, y$ = class {
  value = -1;
  up() {
    return ++this.value;
  }
}, j6 = class extends TransformStream {
  constructor(e) {
    super({
      transform(t, n) {
        n.enqueue({
          ...t,
          path: [e, ...t.path]
        });
      }
    });
  }
};
(class extends TransformStream {
  constructor(e) {
    super({
      transform(t, n) {
        const {
          path: [i, ...r]
        } = t;
        if (e !== i)
          throw new Error(`Path mismatch: expected ${e}, got ${i}`);
        n.enqueue({
          ...t,
          path: r
        });
      }
    });
  }
});
var P6 = class extends TransformStream {
  constructor(e) {
    const t = new y$(), n = /* @__PURE__ */ new Map();
    super({
      transform(i, r) {
        i.type === "part-start" && i.path.length === 0 && n.set(t.up(), e.up());
        const [s, ...l] = i.path;
        if (s === void 0) {
          r.enqueue(i);
          return;
        }
        const c = n.get(s);
        if (c === void 0) throw new Error("Path not found");
        r.enqueue({
          ...i,
          path: [c, ...l]
        });
      }
    });
  }
}, U6 = class extends TransformStream {
  constructor(e, t, n) {
    const [i, r] = F6();
    let s;
    super(
      {
        start(l) {
          return s = i.pipeTo(
            new WritableStream({
              write(c) {
                l.enqueue(c);
              },
              abort(c) {
                l.error(c);
              },
              close() {
                l.terminate();
              }
            })
          ).catch((c) => {
            l.error(c);
          }), e.start?.(r);
        },
        transform(l) {
          return e.transform?.(l, r);
        },
        async flush() {
          await e.flush?.(r), r.close(), await s;
        }
      },
      t,
      n
    );
  }
}, L6 = class extends TransformStream {
  constructor(e) {
    super();
    const t = e(super.readable);
    Object.defineProperty(this, "readable", {
      value: t,
      writable: !1
    });
  }
};
let B6 = (e, t = 21) => (n = t) => {
  let i = "", r = n | 0;
  for (; r--; )
    i += e[Math.random() * e.length | 0];
  return i;
};
var b$ = B6(
  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  7
), Z6 = class x$ {
  _state;
  _parentId;
  constructor(t) {
    this._state = t || {
      merger: N6(),
      contentCounter: new y$()
    };
  }
  get __internal_isClosed() {
    return this._state.merger.isSealed();
  }
  __internal_getReadable() {
    return this._state.merger.readable;
  }
  __internal_subscribeToClose(t) {
    this._state.closeSubscriber = t;
  }
  _addPart(t, n) {
    this._state.append && (this._state.append.controller.close(), this._state.append = void 0), this.enqueue({
      type: "part-start",
      part: t,
      path: []
    }), this._state.merger.addStream(
      n.pipeThrough(
        new j6(this._state.contentCounter.value)
      )
    );
  }
  merge(t) {
    this._state.merger.addStream(
      t.pipeThrough(new P6(this._state.contentCounter))
    );
  }
  appendText(t) {
    this._state.append?.kind !== "text" && (this._state.append = {
      kind: "text",
      controller: this.addTextPart()
    }), this._state.append.controller.append(t);
  }
  appendReasoning(t) {
    this._state.append?.kind !== "reasoning" && (this._state.append = {
      kind: "reasoning",
      controller: this.addReasoningPart()
    }), this._state.append.controller.append(t);
  }
  addTextPart() {
    const [t, n] = f1();
    return this._addPart({ type: "text" }, t), n;
  }
  addReasoningPart() {
    const [t, n] = f1();
    return this._addPart({ type: "reasoning" }, t), n;
  }
  addToolCallPart(t) {
    const n = typeof t == "string" ? { toolName: t } : t, i = n.toolName, r = n.toolCallId ?? b$(), [s, l] = D6();
    return this._addPart(
      {
        type: "tool-call",
        toolName: i,
        toolCallId: r,
        ...this._parentId && { parentId: this._parentId }
      },
      s
    ), n.argsText !== void 0 && (l.argsText.append(n.argsText), l.argsText.close()), n.args !== void 0 && (l.argsText.append(JSON.stringify(n.args)), l.argsText.close()), n.response !== void 0 && l.setResponse(n.response), l;
  }
  appendSource(t) {
    this._addPart(
      { ...t, ...this._parentId && { parentId: this._parentId } },
      new ReadableStream({
        start(n) {
          n.enqueue({
            type: "part-finish",
            path: []
          }), n.close();
        }
      })
    );
  }
  appendFile(t) {
    this._addPart(
      t,
      new ReadableStream({
        start(n) {
          n.enqueue({
            type: "part-finish",
            path: []
          }), n.close();
        }
      })
    );
  }
  enqueue(t) {
    this._state.merger.enqueue(t), t.type === "part-start" && t.path.length === 0 && this._state.contentCounter.up();
  }
  withParentId(t) {
    const n = new x$(this._state);
    return n._parentId = t, n;
  }
  close() {
    this._state.merger.seal(), this._state.append?.controller?.close(), this._state.closeSubscriber?.();
  }
};
function V6(e) {
  const t = new Z6();
  let n;
  try {
    n = e(t);
  } catch (i) {
    throw t.__internal_isClosed || (t.enqueue({
      type: "error",
      path: [],
      error: String(i)
    }), t.close()), i;
  }
  return n instanceof Promise ? (async () => {
    try {
      await n;
    } catch (r) {
      throw t.__internal_isClosed || t.enqueue({
        type: "error",
        path: [],
        error: String(r)
      }), r;
    } finally {
      t.__internal_isClosed || t.close();
    }
  })() : t.__internal_isClosed || t.close(), t.__internal_getReadable();
}
function F6() {
  const { resolve: e, promise: t } = g$();
  let n;
  return [V6((r) => (n = r, n.__internal_subscribeToClose(
    e
  ), t)), n];
}
var H6 = class Md {
  _state;
  constructor(t = null) {
    this._state = t;
  }
  get state() {
    return this._state;
  }
  append(t) {
    this._state = t.reduce(
      (n, i) => Md.apply(n, i),
      this._state
    );
  }
  static apply(t, n) {
    const i = n.type;
    switch (i) {
      case "set":
        return Md.updatePath(
          t,
          n.path,
          () => n.value
        );
      case "append-text":
        return Md.updatePath(t, n.path, (r) => {
          if (typeof r != "string")
            throw new Error(`Expected string at path [${n.path.join(", ")}]`);
          return r + n.value;
        });
      default: {
        const r = i;
        throw new Error(`Invalid operation type: ${r}`);
      }
    }
  }
  static updatePath(t, n, i) {
    if (n.length === 0) return i(t);
    if (t ??= {}, typeof t != "object")
      throw new Error(`Invalid path: [${n.join(", ")}]`);
    const [r, ...s] = n;
    if (Array.isArray(t)) {
      const c = Number(r);
      if (isNaN(c))
        throw new Error(`Expected array index at [${n.join(", ")}]`);
      if (c > t.length || c < 0)
        throw new Error("Insert array index out of bounds");
      const f = [...t];
      return f[c] = this.updatePath(f[c], s, i), f;
    }
    const l = { ...t };
    return l[r] = this.updatePath(l[r], s, i), l;
  }
}, q6 = () => ({
  role: "assistant",
  status: { type: "running" },
  parts: [],
  get content() {
    return this.parts;
  },
  metadata: {
    unstable_state: null,
    unstable_data: [],
    unstable_annotations: [],
    steps: [],
    custom: {}
  }
}), Af = (e, t, n) => {
  if (e.parts.length === 0)
    throw new Error("No parts available to update.");
  if (t.path.length !== 1)
    throw new Error("Nested paths are not supported yet.");
  const i = t.path[0], r = n(e.parts[i]);
  return {
    ...e,
    parts: [
      ...e.parts.slice(0, i),
      r,
      ...e.parts.slice(i + 1)
    ],
    get content() {
      return this.parts;
    }
  };
}, G6 = (e, t) => {
  const n = t.part;
  if (n.type === "text" || n.type === "reasoning") {
    const i = {
      type: n.type,
      text: "",
      status: { type: "running" },
      ...n.parentId && { parentId: n.parentId }
    };
    return {
      ...e,
      parts: [...e.parts, i],
      get content() {
        return this.parts;
      }
    };
  } else if (n.type === "tool-call") {
    const i = {
      type: "tool-call",
      state: "partial-call",
      status: { type: "running", isArgsComplete: !1 },
      toolCallId: n.toolCallId,
      toolName: n.toolName,
      argsText: "",
      args: {},
      ...n.parentId && { parentId: n.parentId }
    };
    return {
      ...e,
      parts: [...e.parts, i],
      get content() {
        return this.parts;
      }
    };
  } else if (n.type === "source") {
    const i = {
      type: "source",
      sourceType: n.sourceType,
      id: n.id,
      url: n.url,
      ...n.title ? { title: n.title } : void 0,
      ...n.parentId && { parentId: n.parentId }
    };
    return {
      ...e,
      parts: [...e.parts, i],
      get content() {
        return this.parts;
      }
    };
  } else if (n.type === "file") {
    const i = {
      type: "file",
      mimeType: n.mimeType,
      data: n.data
    };
    return {
      ...e,
      parts: [...e.parts, i],
      get content() {
        return this.parts;
      }
    };
  } else
    throw new Error(`Unsupported part type: ${n.type}`);
}, Y6 = (e, t) => Af(e, t, (n) => {
  if (n.type !== "tool-call")
    throw new Error("Last is not a tool call");
  return n.state !== "partial-call" ? n : {
    ...n,
    state: "call"
  };
}), J6 = (e, t) => Af(e, t, (n) => ({
  ...n,
  status: { type: "complete", reason: "unknown" }
})), X6 = (e, t) => Af(e, t, (n) => {
  if (n.type === "text" || n.type === "reasoning")
    return { ...n, text: n.text + t.textDelta };
  if (n.type === "tool-call") {
    const i = n.argsText + t.textDelta, r = o$(i) ?? n.args;
    return { ...n, argsText: i, args: r };
  } else
    throw new Error(
      "text-delta received but part is neither text nor tool-call"
    );
}), K6 = (e, t) => Af(e, t, (n) => {
  if (n.type === "tool-call")
    return {
      ...n,
      state: "result",
      ...t.artifact !== void 0 ? { artifact: t.artifact } : {},
      result: t.result,
      isError: t.isError ?? !1,
      status: { type: "complete", reason: "stop" }
    };
  throw new Error("Result chunk received but part is not a tool-call");
}), p1 = (e, t) => {
  if (e.status?.type === "incomplete" && e.status?.reason === "error")
    return e;
  const n = W6(t);
  return { ...e, status: n };
}, W6 = (e) => e.finishReason === "tool-calls" ? {
  type: "requires-action",
  reason: "tool-calls"
} : e.finishReason === "stop" || e.finishReason === "unknown" ? {
  type: "complete",
  reason: e.finishReason
} : {
  type: "incomplete",
  reason: e.finishReason
}, Q6 = (e, t) => ({
  ...e,
  metadata: {
    ...e.metadata,
    unstable_annotations: [
      ...e.metadata.unstable_annotations,
      ...t.annotations
    ]
  }
}), eU = (e, t) => ({
  ...e,
  metadata: {
    ...e.metadata,
    unstable_data: [...e.metadata.unstable_data, ...t.data]
  }
}), tU = (e, t) => ({
  ...e,
  metadata: {
    ...e.metadata,
    steps: [
      ...e.metadata.steps,
      { state: "started", messageId: t.messageId }
    ]
  }
}), nU = (e, t) => {
  const n = e.metadata.steps.slice(), i = n.length - 1;
  return n.length > 0 && n[i]?.state === "started" ? n[i] = {
    ...n[i],
    state: "finished",
    finishReason: t.finishReason,
    usage: t.usage,
    isContinued: t.isContinued
  } : n.push({
    state: "finished",
    messageId: b$(),
    finishReason: t.finishReason,
    usage: t.usage,
    isContinued: t.isContinued
  }), {
    ...e,
    metadata: {
      ...e.metadata,
      steps: n
    }
  };
}, rU = (e, t) => ({
  ...e,
  status: { type: "incomplete", reason: "error", error: t.error }
}), iU = (e, t) => {
  const n = new H6(e.metadata.unstable_state);
  return n.append(t.operations), {
    ...e,
    metadata: {
      ...e.metadata,
      unstable_state: n.state
    }
  };
}, aU = class extends TransformStream {
  constructor({
    initialMessage: e
  } = {}) {
    let t = e ?? q6();
    super({
      transform(n, i) {
        const r = n.type;
        switch (r) {
          case "part-start":
            t = G6(t, n);
            break;
          case "tool-call-args-text-finish":
            t = Y6(t, n);
            break;
          case "part-finish":
            t = J6(t, n);
            break;
          case "text-delta":
            t = X6(t, n);
            break;
          case "result":
            t = K6(t, n);
            break;
          case "message-finish":
            t = p1(t, n);
            break;
          case "annotations":
            t = Q6(t, n);
            break;
          case "data":
            t = eU(t, n);
            break;
          case "step-start":
            t = tU(t, n);
            break;
          case "step-finish":
            t = nU(t, n);
            break;
          case "error":
            t = rU(t, n);
            break;
          case "update-state":
            t = iU(t, n);
            break;
          default: {
            const s = r;
            throw new Error(`Unsupported chunk type: ${s}`);
          }
        }
        i.enqueue(t);
      },
      flush(n) {
        if (t.status?.type === "running") {
          const i = t.parts?.at(-1)?.type === "tool-call";
          t = p1(t, {
            finishReason: i ? "tool-calls" : "unknown"
          }), n.enqueue(t);
        }
      }
    });
  }
}, sU = class extends L6 {
  constructor() {
    super((e) => {
      const t = new U6({
        transform(n, i) {
          i.appendText(n);
        }
      });
      return e.pipeThrough(new TextDecoderStream()).pipeThrough(t);
    });
  }
}, oU = class Dd {
  constructor(t) {
    this.readable = t, this.readable = t;
  }
  static fromAssistantStream(t) {
    return new Dd(
      t.pipeThrough(new aU())
    );
  }
  async unstable_result() {
    let t;
    for await (const n of this)
      t = n;
    return t || {
      role: "assistant",
      status: { type: "complete", reason: "unknown" },
      parts: [],
      content: [],
      metadata: {
        unstable_state: null,
        unstable_data: [],
        unstable_annotations: [],
        steps: [],
        custom: {}
      }
    };
  }
  [Symbol.asyncIterator]() {
    const t = this.readable.getReader();
    return {
      async next() {
        const { done: n, value: i } = await t.read();
        return n ? { done: !0, value: void 0 } : { done: !1, value: i };
      }
    };
  }
  tee() {
    const [t, n] = this.readable.tee();
    return [
      new Dd(t),
      new Dd(n)
    ];
  }
}, m1 = Symbol.for("aui.tool-response"), lU = class Ig {
  get [m1]() {
    return !0;
  }
  artifact;
  result;
  isError;
  constructor(t) {
    t.artifact !== void 0 && (this.artifact = t.artifact), this.result = t.result, this.isError = t.isError ?? !1;
  }
  static [Symbol.hasInstance](t) {
    return typeof t == "object" && t !== null && m1 in t;
  }
  static toResponse(t) {
    return t instanceof Ig ? t : new Ig({
      result: t === void 0 ? "<no result>" : t
    });
  }
}, Cg = class {
  constructor(e, t, n) {
    this.contentBinding = e, this.messageApi = t, this.threadApi = n;
  }
  get path() {
    return this.contentBinding.path;
  }
  __internal_bindMethods() {
    this.addToolResult = this.addToolResult.bind(this), this.getState = this.getState.bind(this), this.subscribe = this.subscribe.bind(this);
  }
  getState() {
    return this.contentBinding.getState();
  }
  addToolResult(e) {
    const t = this.contentBinding.getState();
    if (!t) throw new Error("Message part is not available");
    if (t.type !== "tool-call")
      throw new Error("Tried to add tool result to non-tool message part");
    if (!this.messageApi)
      throw new Error(
        "Message API is not available. This is likely a bug in assistant-ui."
      );
    if (!this.threadApi) throw new Error("Thread API is not available");
    const n = this.messageApi.getState();
    if (!n) throw new Error("Message is not available");
    const i = t.toolName, r = t.toolCallId, s = lU.toResponse(e);
    this.threadApi.getState().addToolResult({
      messageId: n.id,
      toolName: i,
      toolCallId: r,
      result: s.result,
      artifact: s.artifact,
      isError: s.isError
    });
  }
  subscribe(e) {
    return this.contentBinding.subscribe(e);
  }
}, qd = class extends $f {
  constructor(e) {
    super(), this.binding = e;
  }
  get path() {
    return this.binding.path;
  }
  getState() {
    return this.binding.getState();
  }
  outerSubscribe(e) {
    return this.binding.subscribe(e);
  }
  _connect() {
    const e = () => {
      this.notifySubscribers();
    };
    let t = this.binding.getState(), n = t?.subscribe(e);
    const i = () => {
      const s = this.binding.getState();
      s !== t && (t = s, n?.(), n = this.binding.getState()?.subscribe(e), e());
    }, r = this.outerSubscribe(i);
    return () => {
      r?.(), n?.();
    };
  }
}, fd = Object.freeze({
  type: "complete"
}), uU = (e, t, n) => {
  if (e.role !== "assistant") return fd;
  if (n.type === "tool-call")
    return n.result ? fd : e.status;
  const i = t === Math.max(0, e.content.length - 1);
  return e.status.type === "requires-action" ? fd : i ? e.status : fd;
}, g1 = (e, t) => {
  const n = e.content[t];
  if (!n)
    return kr;
  const i = uU(e, t, n);
  return Object.freeze({
    ...n,
    [Vn]: n[Vn],
    status: i
  });
}, cU = class {
  constructor(e, t) {
    this._core = e, this._threadBinding = t, this.composer = new R6(
      new qd({
        path: {
          ...this.path,
          ref: this.path.ref + `${this.path.ref}.composer`,
          composerSource: "edit"
        },
        getState: this._getEditComposerRuntimeCore,
        subscribe: (n) => this._threadBinding.subscribe(n)
      }),
      () => this._threadBinding.getState().beginEdit(this._core.getState().id)
    );
  }
  get path() {
    return this._core.path;
  }
  __internal_bindMethods() {
    this.reload = this.reload.bind(this), this.getState = this.getState.bind(this), this.subscribe = this.subscribe.bind(this), this.getMessagePartByIndex = this.getMessagePartByIndex.bind(this), this.getMessagePartByToolCallId = this.getMessagePartByToolCallId.bind(this), this.getAttachmentByIndex = this.getAttachmentByIndex.bind(this), this.unstable_getCopyText = this.unstable_getCopyText.bind(this), this.speak = this.speak.bind(this), this.stopSpeaking = this.stopSpeaking.bind(this), this.submitFeedback = this.submitFeedback.bind(this), this.switchToBranch = this.switchToBranch.bind(this);
  }
  composer;
  _getEditComposerRuntimeCore = () => this._threadBinding.getState().getEditComposer(this._core.getState().id);
  getState() {
    return this._core.getState();
  }
  reload(e = {}) {
    const t = this._getEditComposerRuntimeCore(), n = t ?? this._threadBinding.getState().composer, i = t ?? n, { runConfig: r = i.runConfig } = e, s = this._core.getState();
    if (s.role !== "assistant")
      throw new Error("Can only reload assistant messages");
    this._threadBinding.getState().startRun({
      parentId: s.parentId,
      sourceId: s.id,
      runConfig: r
    });
  }
  speak() {
    const e = this._core.getState();
    return this._threadBinding.getState().speak(e.id);
  }
  stopSpeaking() {
    const e = this._core.getState();
    if (this._threadBinding.getState().speech?.messageId === e.id)
      this._threadBinding.getState().stopSpeaking();
    else
      throw new Error("Message is not being spoken");
  }
  submitFeedback({ type: e }) {
    const t = this._core.getState();
    this._threadBinding.getState().submitFeedback({
      messageId: t.id,
      type: e
    });
  }
  switchToBranch({
    position: e,
    branchId: t
  }) {
    const n = this._core.getState();
    if (t && e)
      throw new Error("May not specify both branchId and position");
    if (!t && !e)
      throw new Error("Must specify either branchId or position");
    const r = this._threadBinding.getState().getBranches(n.id);
    let s = t;
    if (e === "previous" ? s = r[n.branchNumber - 2] : e === "next" && (s = r[n.branchNumber]), !s) throw new Error("Branch not found");
    this._threadBinding.getState().switchToBranch(s);
  }
  unstable_getCopyText() {
    return eu(this.getState());
  }
  subscribe(e) {
    return this._core.subscribe(e);
  }
  getMessagePartByIndex(e) {
    if (e < 0) throw new Error("Message part index must be >= 0");
    return new Cg(
      new xr({
        path: {
          ...this.path,
          ref: this.path.ref + `${this.path.ref}.content[${e}]`,
          messagePartSelector: { type: "index", index: e }
        },
        getState: () => g1(this.getState(), e),
        subscribe: (t) => this._core.subscribe(t)
      }),
      this._core,
      this._threadBinding
    );
  }
  getMessagePartByToolCallId(e) {
    return new Cg(
      new xr({
        path: {
          ...this.path,
          ref: this.path.ref + `${this.path.ref}.content[toolCallId=${JSON.stringify(e)}]`,
          messagePartSelector: { type: "toolCallId", toolCallId: e }
        },
        getState: () => {
          const t = this._core.getState(), n = t.content.findIndex(
            (i) => i.type === "tool-call" && i.toolCallId === e
          );
          return n === -1 ? kr : g1(t, n);
        },
        subscribe: (t) => this._core.subscribe(t)
      }),
      this._core,
      this._threadBinding
    );
  }
  getAttachmentByIndex(e) {
    return new z6(
      new xr({
        path: {
          ...this.path,
          ref: this.path.ref + `${this.path.ref}.attachments[${e}]`,
          attachmentSource: "message",
          attachmentSelector: { type: "index", index: e }
        },
        getState: () => {
          const n = this.getState().attachments?.[e];
          return n ? {
            ...n,
            source: "message"
          } : kr;
        },
        subscribe: (t) => this._core.subscribe(t)
      })
    );
  }
}, dU = (e) => ({
  parentId: e.parentId ?? null,
  sourceId: e.sourceId ?? null,
  runConfig: e.runConfig ?? {},
  stream: e.stream
}), fU = (e) => ({
  parentId: e.parentId ?? null,
  sourceId: e.sourceId ?? null,
  runConfig: e.runConfig ?? {}
}), hU = (e, t) => typeof t == "string" ? {
  createdAt: /* @__PURE__ */ new Date(),
  parentId: e.at(-1)?.id ?? null,
  sourceId: null,
  runConfig: {},
  role: "user",
  content: [{ type: "text", text: t }],
  attachments: [],
  metadata: { custom: {} }
} : {
  createdAt: t.createdAt ?? /* @__PURE__ */ new Date(),
  parentId: t.parentId ?? e.at(-1)?.id ?? null,
  sourceId: t.sourceId ?? null,
  role: t.role ?? "user",
  content: t.content,
  attachments: t.attachments ?? [],
  metadata: t.metadata ?? { custom: {} },
  runConfig: t.runConfig ?? {},
  startRun: t.startRun
}, pU = (e, t) => {
  const n = e.messages.at(-1);
  return Object.freeze({
    threadId: t.id,
    metadata: t,
    capabilities: e.capabilities,
    isDisabled: e.isDisabled,
    isLoading: e.isLoading,
    isRunning: n?.role !== "assistant" ? !1 : n.status.type === "running",
    messages: e.messages,
    state: e.state,
    suggestions: e.suggestions,
    extras: e.extras,
    speech: e.speech
  });
}, w$ = class {
  get path() {
    return this._threadBinding.path;
  }
  get __internal_threadBinding() {
    return this._threadBinding;
  }
  _threadBinding;
  constructor(e, t) {
    const n = new xr({
      path: e.path,
      getState: () => pU(
        e.getState(),
        t.getState()
      ),
      subscribe: (i) => {
        const r = e.subscribe(i), s = t.subscribe(i);
        return () => {
          r(), s();
        };
      }
    });
    this._threadBinding = {
      path: e.path,
      getState: () => e.getState(),
      getStateState: () => n.getState(),
      outerSubscribe: (i) => e.outerSubscribe(i),
      subscribe: (i) => e.subscribe(i)
    }, this.composer = new O6(
      new qd({
        path: {
          ...this.path,
          ref: this.path.ref + `${this.path.ref}.composer`,
          composerSource: "thread"
        },
        getState: () => this._threadBinding.getState().composer,
        subscribe: (i) => this._threadBinding.subscribe(i)
      })
    );
  }
  __internal_bindMethods() {
    this.append = this.append.bind(this), this.unstable_resumeRun = this.unstable_resumeRun.bind(this), this.startRun = this.startRun.bind(this), this.cancelRun = this.cancelRun.bind(this), this.stopSpeaking = this.stopSpeaking.bind(this), this.export = this.export.bind(this), this.import = this.import.bind(this), this.reset = this.reset.bind(this), this.getMesssageByIndex = this.getMesssageByIndex.bind(this), this.getMesssageById = this.getMesssageById.bind(this), this.subscribe = this.subscribe.bind(this), this.unstable_on = this.unstable_on.bind(this), this.getModelContext = this.getModelContext.bind(this), this.getModelConfig = this.getModelConfig.bind(this), this.getState = this.getState.bind(this);
  }
  composer;
  getState() {
    return this._threadBinding.getStateState();
  }
  append(e) {
    this._threadBinding.getState().append(
      hU(this._threadBinding.getState().messages, e)
    );
  }
  subscribe(e) {
    return this._threadBinding.subscribe(e);
  }
  getModelContext() {
    return this._threadBinding.getState().getModelContext();
  }
  getModelConfig() {
    return this.getModelContext();
  }
  startRun(e) {
    const t = e === null || typeof e == "string" ? { parentId: e } : e;
    return this._threadBinding.getState().startRun(fU(t));
  }
  unstable_resumeRun(e) {
    return this._threadBinding.getState().resumeRun(dU(e));
  }
  cancelRun() {
    this._threadBinding.getState().cancelRun();
  }
  stopSpeaking() {
    return this._threadBinding.getState().stopSpeaking();
  }
  export() {
    return this._threadBinding.getState().export();
  }
  import(e) {
    this._threadBinding.getState().import(e);
  }
  reset(e) {
    this._threadBinding.getState().reset(e);
  }
  getMesssageByIndex(e) {
    if (e < 0) throw new Error("Message index must be >= 0");
    return this._getMessageRuntime(
      {
        ...this.path,
        ref: this.path.ref + `${this.path.ref}.messages[${e}]`,
        messageSelector: { type: "index", index: e }
      },
      () => {
        const t = this._threadBinding.getState().messages, n = t[e];
        if (n)
          return {
            message: n,
            parentId: t[e - 1]?.id ?? null
          };
      }
    );
  }
  getMesssageById(e) {
    return this._getMessageRuntime(
      {
        ...this.path,
        ref: this.path.ref + `${this.path.ref}.messages[messageId=${JSON.stringify(e)}]`,
        messageSelector: { type: "messageId", messageId: e }
      },
      () => this._threadBinding.getState().getMessageById(e)
    );
  }
  _getMessageRuntime(e, t) {
    return new cU(
      new xr({
        path: e,
        getState: () => {
          const { message: n, parentId: i } = t() ?? {}, { messages: r, speech: s } = this._threadBinding.getState();
          if (!n || i === void 0) return kr;
          const l = this._threadBinding.getState(), c = l.getBranches(n.id), f = l.getSubmittedFeedback(n.id);
          return {
            ...n,
            [Vn]: n[Vn],
            isLast: r.at(-1)?.id === n.id,
            parentId: i,
            branchNumber: c.indexOf(n.id) + 1,
            branchCount: c.length,
            speech: s?.messageId === n.id ? s : void 0,
            submittedFeedback: f
          };
        },
        subscribe: (n) => this._threadBinding.subscribe(n)
      }),
      this._threadBinding
    );
  }
  _eventSubscriptionSubjects = /* @__PURE__ */ new Map();
  unstable_on(e, t) {
    let n = this._eventSubscriptionSubjects.get(e);
    return n || (n = new f$({
      event: e,
      binding: this._threadBinding
    }), this._eventSubscriptionSubjects.set(e, n)), n.subscribe(t);
  }
}, mU = (e) => ({
  mainThreadId: e.mainThreadId,
  newThread: e.newThreadId,
  threads: e.threadIds,
  archivedThreads: e.archivedThreadIds,
  isLoading: e.isLoading
}), hd = (e, t) => {
  if (t === void 0) return kr;
  const n = e.getItemById(t);
  return n ? {
    id: n.threadId,
    threadId: n.threadId,
    // TODO remove in 0.8.0
    remoteId: n.remoteId,
    externalId: n.externalId,
    title: n.title,
    status: n.status,
    isMain: n.threadId === e.mainThreadId
  } : kr;
}, gU = class {
  constructor(e, t = w$) {
    this._core = e, this._runtimeFactory = t;
    const n = new Zv({
      path: {},
      getState: () => mU(e),
      subscribe: (i) => e.subscribe(i)
    });
    this._getState = n.getState.bind(n), this._mainThreadListItemRuntime = new dd(
      new xr({
        path: {
          ref: "threadItems[main]",
          threadSelector: { type: "main" }
        },
        getState: () => hd(this._core, this._core.mainThreadId),
        subscribe: (i) => this._core.subscribe(i)
      }),
      this._core
    ), this.main = new t(
      new qd({
        path: {
          ref: "threads.main",
          threadSelector: { type: "main" }
        },
        getState: () => e.getMainThreadRuntimeCore(),
        subscribe: (i) => e.subscribe(i)
      }),
      this._mainThreadListItemRuntime
      // TODO capture "main" threadListItem from context around useLocalRuntime / useExternalStoreRuntime
    );
  }
  _getState;
  __internal_bindMethods() {
    this.switchToThread = this.switchToThread.bind(this), this.switchToNewThread = this.switchToNewThread.bind(this), this.getState = this.getState.bind(this), this.subscribe = this.subscribe.bind(this), this.getById = this.getById.bind(this), this.getItemById = this.getItemById.bind(this), this.getItemByIndex = this.getItemByIndex.bind(this), this.getArchivedItemByIndex = this.getArchivedItemByIndex.bind(this);
  }
  switchToThread(e) {
    return this._core.switchToThread(e);
  }
  switchToNewThread() {
    return this._core.switchToNewThread();
  }
  getState() {
    return this._getState();
  }
  get isLoading() {
    return this._core.isLoading;
  }
  subscribe(e) {
    return this._core.subscribe(e);
  }
  _mainThreadListItemRuntime;
  main;
  get mainItem() {
    return this._mainThreadListItemRuntime;
  }
  getById(e) {
    return new this._runtimeFactory(
      new qd({
        path: {
          ref: "threads[threadId=" + JSON.stringify(e) + "]",
          threadSelector: { type: "threadId", threadId: e }
        },
        getState: () => this._core.getThreadRuntimeCore(e),
        subscribe: (t) => this._core.subscribe(t)
      }),
      this.mainItem
      // TODO capture "main" threadListItem from context around useLocalRuntime / useExternalStoreRuntime
    );
  }
  getItemByIndex(e) {
    return new dd(
      new xr({
        path: {
          ref: `threadItems[${e}]`,
          threadSelector: { type: "index", index: e }
        },
        getState: () => hd(this._core, this._core.threadIds[e]),
        subscribe: (t) => this._core.subscribe(t)
      }),
      this._core
    );
  }
  getArchivedItemByIndex(e) {
    return new dd(
      new xr({
        path: {
          ref: `archivedThreadItems[${e}]`,
          threadSelector: { type: "archiveIndex", index: e }
        },
        getState: () => hd(
          this._core,
          this._core.archivedThreadIds[e]
        ),
        subscribe: (t) => this._core.subscribe(t)
      }),
      this._core
    );
  }
  getItemById(e) {
    return new dd(
      new xr({
        path: {
          ref: `threadItems[threadId=${e}]`,
          threadSelector: { type: "threadId", threadId: e }
        },
        getState: () => hd(this._core, e),
        subscribe: (t) => this._core.subscribe(t)
      }),
      this._core
    );
  }
}, Og = $.createContext(null), _$ = ({
  adapters: e,
  children: t
}) => {
  const n = $.useContext(Og);
  return /* @__PURE__ */ C.jsx(
    Og.Provider,
    {
      value: {
        ...n,
        ...e
      },
      children: t
    }
  );
}, S$ = () => $.useContext(Og), Oa = Object.freeze([]), Xs = "DEFAULT_THREAD_ID", vU = Object.freeze([Xs]), yU = Object.freeze({
  threadId: Xs,
  status: "regular"
}), bU = Promise.resolve(), xU = class {
  constructor(e = {}, t) {
    this.adapter = e, this.threadFactory = t, this._mainThread = this.threadFactory();
  }
  _mainThreadId = Xs;
  _threads = vU;
  _archivedThreads = Oa;
  get isLoading() {
    return this.adapter.isLoading ?? !1;
  }
  get newThreadId() {
  }
  get threadIds() {
    return this._threads;
  }
  get archivedThreadIds() {
    return this._archivedThreads;
  }
  getLoadThreadsPromise() {
    return bU;
  }
  _mainThread;
  get mainThreadId() {
    return this._mainThreadId;
  }
  getMainThreadRuntimeCore() {
    return this._mainThread;
  }
  getThreadRuntimeCore() {
    throw new Error("Method not implemented.");
  }
  getItemById(e) {
    for (const t of this.adapter.threads ?? [])
      if (t.threadId === e) return t;
    for (const t of this.adapter.archivedThreads ?? [])
      if (t.threadId === e) return t;
    if (e === Xs) return yU;
  }
  __internal_setAdapter(e) {
    const t = this.adapter;
    this.adapter = e;
    const n = e.threadId ?? Xs, i = e.threads ?? Oa, r = e.archivedThreads ?? Oa, s = t.threadId ?? Xs, l = t.threads ?? Oa, c = t.archivedThreads ?? Oa;
    s === n && l === i && c === r || (l !== i && (this._threads = this.adapter.threads?.map((f) => f.threadId) ?? Oa), c !== r && (this._archivedThreads = this.adapter.archivedThreads?.map((f) => f.threadId) ?? Oa), s !== n && (this._mainThreadId = n, this._mainThread = this.threadFactory()), this._notifySubscribers());
  }
  async switchToThread(e) {
    if (this._mainThreadId === e) return;
    const t = this.adapter.onSwitchToThread;
    if (!t)
      throw new Error(
        "External store adapter does not support switching to thread"
      );
    t(e);
  }
  async switchToNewThread() {
    const e = this.adapter.onSwitchToNewThread;
    if (!e)
      throw new Error(
        "External store adapter does not support switching to new thread"
      );
    e();
  }
  async rename(e, t) {
    const n = this.adapter.onRename;
    if (!n)
      throw new Error("External store adapter does not support renaming");
    n(e, t);
  }
  async detach() {
  }
  async archive(e) {
    const t = this.adapter.onArchive;
    if (!t)
      throw new Error("External store adapter does not support archiving");
    t(e);
  }
  async unarchive(e) {
    const t = this.adapter.onUnarchive;
    if (!t)
      throw new Error("External store adapter does not support unarchiving");
    t(e);
  }
  async delete(e) {
    const t = this.adapter.onDelete;
    if (!t)
      throw new Error("External store adapter does not support deleting");
    t(e);
  }
  initialize() {
    throw new Error("Method not implemented.");
  }
  generateTitle() {
    throw new Error("Method not implemented.");
  }
  _subscriptions = /* @__PURE__ */ new Set();
  subscribe(e) {
    return this._subscriptions.add(e), () => this._subscriptions.delete(e);
  }
  _notifySubscribers() {
    for (const e of this._subscriptions) e();
  }
}, Rg = class {
  cache = /* @__PURE__ */ new WeakMap();
  convertMessages(e, t) {
    return e.map((n, i) => {
      const r = this.cache.get(n), s = t(r, n, i);
      return this.cache.set(n, s), s;
    });
  }
}, wU = class extends n$ {
  constructor(e, t, { parentId: n, message: i }) {
    super(), this.runtime = e, this.endEditCallback = t, this._parentId = n, this._sourceId = i.id, this._previousText = eu(i), this.setText(this._previousText), this.setRole(i.role), this.setAttachments(i.attachments ?? []), this._nonTextParts = i.content.filter((r) => r.type !== "text"), this.setRunConfig({ ...e.composer.runConfig });
  }
  get canCancel() {
    return !0;
  }
  getAttachmentAdapter() {
    return this.runtime.adapters?.attachments;
  }
  _nonTextParts;
  _previousText;
  _parentId;
  _sourceId;
  async handleSend(e) {
    eu(e) !== this._previousText && this.runtime.append({
      ...e,
      content: [...e.content, ...this._nonTextParts],
      parentId: this._parentId,
      sourceId: this._sourceId
    }), this.handleCancel();
  }
  handleCancel() {
    this.endEditCallback(), this._notifySubscribers();
  }
}, _U = class {
  constructor(e) {
    this._contextProvider = e;
  }
  _subscriptions = /* @__PURE__ */ new Set();
  _isInitialized = !1;
  repository = new u$();
  get messages() {
    return this.repository.getMessages();
  }
  get state() {
    let e;
    for (const t of this.messages)
      if (t.role === "assistant") {
        e = t;
        break;
      }
    return e?.metadata.unstable_state ?? null;
  }
  composer = new r$(this);
  getModelContext() {
    return this._contextProvider.getModelContext();
  }
  _editComposers = /* @__PURE__ */ new Map();
  getEditComposer(e) {
    return this._editComposers.get(e);
  }
  beginEdit(e) {
    if (this._editComposers.has(e))
      throw new Error("Edit already in progress");
    this._editComposers.set(
      e,
      new wU(
        this,
        () => this._editComposers.delete(e),
        this.repository.getMessage(e)
      )
    ), this._notifySubscribers();
  }
  getMessageById(e) {
    return this.repository.getMessage(e);
  }
  getBranches(e) {
    return this.repository.getBranches(e);
  }
  switchToBranch(e) {
    this.repository.switchToBranch(e), this._notifySubscribers();
  }
  _notifySubscribers() {
    for (const e of this._subscriptions) e();
  }
  _notifyEventSubscribers(e) {
    const t = this._eventSubscribers.get(e);
    if (t)
      for (const n of t) n();
  }
  subscribe(e) {
    return this._subscriptions.add(e), () => this._subscriptions.delete(e);
  }
  _submittedFeedback = {};
  getSubmittedFeedback(e) {
    return this._submittedFeedback[e];
  }
  submitFeedback({ messageId: e, type: t }) {
    const n = this.adapters?.feedback;
    if (!n) throw new Error("Feedback adapter not configured");
    const { message: i } = this.repository.getMessage(e);
    n.submit({ message: i, type: t }), this._submittedFeedback[e] = { type: t }, this._notifySubscribers();
  }
  _stopSpeaking;
  speech;
  speak(e) {
    const t = this.adapters?.speech;
    if (!t) throw new Error("Speech adapter not configured");
    const { message: n } = this.repository.getMessage(e);
    this._stopSpeaking?.();
    const i = t.speak(eu(n)), r = i.subscribe(() => {
      i.status.type === "ended" ? (this._stopSpeaking = void 0, this.speech = void 0) : this.speech = { messageId: e, status: i.status }, this._notifySubscribers();
    });
    this.speech = { messageId: e, status: i.status }, this._notifySubscribers(), this._stopSpeaking = () => {
      i.cancel(), r(), this.speech = void 0, this._stopSpeaking = void 0;
    };
  }
  stopSpeaking() {
    if (!this._stopSpeaking) throw new Error("No message is being spoken");
    this._stopSpeaking(), this._notifySubscribers();
  }
  ensureInitialized() {
    this._isInitialized || (this._isInitialized = !0, this._notifyEventSubscribers("initialize"));
  }
  // TODO import()/export() on external store doesn't make much sense
  export() {
    return this.repository.export();
  }
  import(e) {
    this.ensureInitialized(), this.repository.clear(), this.repository.import(e), this._notifySubscribers();
  }
  reset(e) {
    this.import(l$.fromArray(e ?? []));
  }
  _eventSubscribers = /* @__PURE__ */ new Map();
  unstable_on(e, t) {
    if (e === "model-context-update")
      return this._contextProvider.subscribe?.(t) ?? (() => {
      });
    const n = this._eventSubscribers.get(e);
    return n ? n.add(t) : this._eventSubscribers.set(e, /* @__PURE__ */ new Set([t])), () => {
      this._eventSubscribers.get(e).delete(t);
    };
  }
}, SU = Object.freeze([]), kU = (e, t) => e && t[t.length - 1]?.role !== "assistant", TU = class extends _U {
  assistantOptimisticId = null;
  _capabilities = {
    switchToBranch: !1,
    edit: !1,
    reload: !1,
    cancel: !1,
    unstable_copy: !1,
    speech: !1,
    attachments: !1,
    feedback: !1
  };
  get capabilities() {
    return this._capabilities;
  }
  _messages;
  isDisabled;
  get isLoading() {
    return this._store.isLoading ?? !1;
  }
  get messages() {
    return this._messages;
  }
  get adapters() {
    return this._store.adapters;
  }
  suggestions = [];
  extras = void 0;
  _converter = new Rg();
  _store;
  beginEdit(e) {
    if (!this._store.onEdit)
      throw new Error("Runtime does not support editing.");
    super.beginEdit(e);
  }
  constructor(e, t) {
    super(e), this.__internal_setAdapter(t);
  }
  __internal_setAdapter(e) {
    if (this._store === e) return;
    const t = e.isRunning ?? !1;
    this.isDisabled = e.isDisabled ?? !1;
    const n = this._store;
    this._store = e, this.extras = e.extras, this.suggestions = e.suggestions ?? SU, this._capabilities = {
      switchToBranch: this._store.setMessages !== void 0,
      edit: this._store.onEdit !== void 0,
      reload: this._store.onReload !== void 0,
      cancel: this._store.onCancel !== void 0,
      speech: this._store.adapters?.speech !== void 0,
      unstable_copy: this._store.unstable_capabilities?.copy !== !1,
      // default true
      attachments: !!this._store.adapters?.attachments,
      feedback: !!this._store.adapters?.feedback
    };
    let i;
    if (e.messageRepository) {
      if (n && n.isRunning === e.isRunning && n.messageRepository === e.messageRepository) {
        this._notifySubscribers();
        return;
      }
      this.repository.clear(), this.assistantOptimisticId = null, this.repository.import(e.messageRepository), i = this.repository.getMessages();
    } else if (e.messages) {
      if (n) {
        if (n.convertMessage !== e.convertMessage)
          this._converter = new Rg();
        else if (n.isRunning === e.isRunning && n.messages === e.messages) {
          this._notifySubscribers();
          return;
        }
      }
      i = e.convertMessage ? this._converter.convertMessages(e.messages, (r, s, l) => {
        if (!e.convertMessage) return s;
        const c = l === e.messages.length - 1, f = wu(c, t, !1);
        if (r && (r.role !== "assistant" || !s$(r.status) || r.status === f))
          return r;
        const h = e.convertMessage(s, l), p = Wa(
          h,
          l.toString(),
          f
        );
        return p[Vn] = s, p;
      }) : e.messages;
      for (let r = 0; r < i.length; r++) {
        const s = i[r], l = i[r - 1];
        this.repository.addOrUpdateMessage(l?.id ?? null, s);
      }
    } else
      throw new Error(
        "ExternalStoreAdapter must provide either 'messages' or 'messageRepository'"
      );
    i.length > 0 && this.ensureInitialized(), (n?.isRunning ?? !1) !== (e.isRunning ?? !1) && (e.isRunning ? this._notifyEventSubscribers("run-start") : this._notifyEventSubscribers("run-end")), this.assistantOptimisticId && (this.repository.deleteMessage(this.assistantOptimisticId), this.assistantOptimisticId = null), kU(t, i) && (this.assistantOptimisticId = this.repository.appendOptimisticMessage(
      i.at(-1)?.id ?? null,
      {
        role: "assistant",
        content: []
      }
    )), this.repository.resetHead(
      this.assistantOptimisticId ?? i.at(-1)?.id ?? null
    ), this._messages = this.repository.getMessages(), this._notifySubscribers();
  }
  switchToBranch(e) {
    if (!this._store.setMessages)
      throw new Error("Runtime does not support switching branches.");
    this.repository.switchToBranch(e), this.updateMessages(this.repository.getMessages());
  }
  async append(e) {
    if (e.parentId !== (this.messages.at(-1)?.id ?? null)) {
      if (!this._store.onEdit)
        throw new Error("Runtime does not support editing messages.");
      await this._store.onEdit(e);
    } else
      await this._store.onNew(e);
  }
  async startRun(e) {
    if (!this._store.onReload)
      throw new Error("Runtime does not support reloading messages.");
    await this._store.onReload(e.parentId, e);
  }
  async resumeRun() {
    throw new Error("Runtime does not support resuming runs.");
  }
  cancelRun() {
    if (!this._store.onCancel)
      throw new Error("Runtime does not support cancelling runs.");
    this._store.onCancel(), this.assistantOptimisticId && (this.repository.deleteMessage(this.assistantOptimisticId), this.assistantOptimisticId = null);
    let e = this.repository.getMessages();
    const t = e[e.length - 1];
    t?.role === "user" && t.id === e.at(-1)?.id ? (this.repository.deleteMessage(t.id), this.composer.text.trim() || this.composer.setText(eu(t)), e = this.repository.getMessages()) : this._notifySubscribers(), setTimeout(() => {
      this.updateMessages(e);
    }, 0);
  }
  addToolResult(e) {
    if (!this._store.onAddToolResult && !this._store.onAddToolResult)
      throw new Error("Runtime does not support tool results.");
    this._store.onAddToolResult?.(e);
  }
  updateMessages = (e) => {
    this._store.convertMessage !== void 0 ? this._store.setMessages?.(
      e.flatMap(T6).filter((n) => n != null)
    ) : this._store.setMessages?.(e);
  };
}, v1 = (e) => e.adapters?.threadList ?? {}, EU = class extends Bv {
  threads;
  constructor(e) {
    super(), this.threads = new xU(
      v1(e),
      () => new TU(this._contextProvider, e)
    );
  }
  setAdapter(e) {
    this.threads.__internal_setAdapter(v1(e)), this.threads.getMainThreadRuntimeCore().__internal_setAdapter(e);
  }
}, $U = (e) => {
  const [t] = $.useState(() => new EU(e));
  $.useEffect(() => {
    t.setAdapter(e);
  });
  const { modelContext: n } = S$() ?? {};
  return $.useEffect(() => {
    if (n)
      return t.registerModelContextProvider(n);
  }, [n, t]), $.useMemo(() => new Gv(t), [t]);
}, k$ = (e) => {
  const t = {
    role: "assistant",
    content: []
  };
  for (const n of e)
    if (n.role === "tool") {
      const i = t.content.findIndex(
        (r) => r.type === "tool-call" && r.toolCallId === n.toolCallId
      );
      if (i !== -1) {
        const r = t.content[i];
        if (n.toolName && r.toolName !== n.toolName)
          throw new Error(
            `Tool call name ${n.toolCallId} ${n.toolName} does not match existing tool call ${r.toolName}`
          );
        t.content[i] = {
          ...r,
          [Vn]: [
            ...r[Vn] ?? [],
            n
          ],
          result: n.result,
          artifact: n.artifact,
          isError: n.isError
        };
      } else
        throw new Error(
          `Tool call ${n.toolCallId} ${n.toolName} not found in assistant message`
        );
    } else {
      const i = n.role, r = (typeof n.content == "string" ? [{ type: "text", text: n.content }] : n.content).map((s) => ({
        ...s,
        [Vn]: [n]
      }));
      switch (i) {
        case "system":
        case "user":
          return {
            ...n,
            content: r
          };
        case "assistant":
          t.content.length === 0 && (t.id = n.id, t.createdAt ??= n.createdAt, t.status ??= n.status, n.attachments && (t.attachments = [
            ...t.attachments ?? [],
            ...n.attachments
          ]), n.metadata && (t.metadata ??= {}, n.metadata.unstable_state && (t.metadata.unstable_state = n.metadata.unstable_state), n.metadata.unstable_annotations && (t.metadata.unstable_annotations = [
            ...t.metadata.unstable_annotations ?? [],
            ...n.metadata.unstable_annotations
          ]), n.metadata.unstable_data && (t.metadata.unstable_data = [
            ...t.metadata.unstable_data ?? [],
            ...n.metadata.unstable_data
          ]), n.metadata.steps && (t.metadata.steps = [
            ...t.metadata.steps ?? [],
            ...n.metadata.steps
          ]), n.metadata.custom && (t.metadata.custom = {
            ...t.metadata.custom ?? {},
            ...n.metadata.custom
          }))), t.content.push(...r);
          break;
        default: {
          const s = i;
          throw new Error(`Unknown message role: ${s}`);
        }
      }
    }
  return t;
}, T$ = (e, t) => {
  const n = [];
  let i = !1, r = !1, s = [], l = [];
  const c = () => {
    l.length && n.push({
      inputs: s,
      outputs: l
    }), s = [], l = [], i = !1, r = !1;
  };
  for (const f of e)
    for (const h of f.outputs)
      (r && h.role !== "tool" || !i || h.role === "user" || h.role === "system") && c(), i = h.role === "assistant" || h.role === "tool", s.at(-1) !== f.input && s.push(f.input), l.push(h), h.role === "assistant" && (h.convertConfig?.joinStrategy === "none" || t === "none") && (r = !0);
  return c(), n;
}, AU = (e, t, n) => {
  const i = [];
  for (const s of e) {
    const l = t(s), c = Array.isArray(l) ? l : [l], f = { input: s, outputs: c };
    i.push(f);
  }
  const r = T$(i);
  return r.map((s, l) => {
    const c = l === r.length - 1, f = k$(s.outputs), h = typeof f.content == "object" && f.content.some(
      (y) => y.type === "tool-call" && y.result === void 0
    ), p = wu(c, n, h), m = Wa(
      f,
      l.toString(),
      p
    );
    return m[Vn] = s.inputs, m;
  });
}, zU = ({
  callback: e,
  messages: t,
  isRunning: n,
  joinStrategy: i
}) => {
  const r = $.useMemo(
    () => ({
      callback: e,
      callbackCache: /* @__PURE__ */ new WeakMap(),
      chunkCache: /* @__PURE__ */ new WeakMap(),
      converterCache: new Rg()
    }),
    [e]
  );
  return $.useMemo(() => {
    const s = [];
    for (const f of t) {
      let h = r.callbackCache.get(f);
      if (!h) {
        const p = r.callback(f), m = Array.isArray(p) ? p : [p];
        h = { input: f, outputs: m }, r.callbackCache.set(f, h);
      }
      s.push(h);
    }
    const l = T$(s, i).map(
      (f) => {
        const h = f.outputs[0];
        if (!h) return f;
        const p = r.chunkCache.get(h);
        return p && y1(p.outputs, f.outputs) ? p : (r.chunkCache.set(h, f), f);
      }
    ), c = r.converterCache.convertMessages(
      l,
      (f, h, p) => {
        const m = p === l.length - 1, y = k$(h.outputs), b = typeof y.content == "object" && y.content.some(
          (k) => k.type === "tool-call" && k.result === void 0
        ), x = wu(
          m,
          n,
          b
        );
        if (f && (f.role !== "assistant" || !s$(f.status) || f.status === x)) {
          const k = Za(f);
          if (y1(k, h.inputs))
            return f;
        }
        const w = Wa(
          y,
          p.toString(),
          x
        );
        return w[Vn] = h.inputs, w;
      }
    );
    return c[Vn] = t, c;
  }, [r, t, n, i]);
}, y1 = (e, t) => {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n]) return !1;
  return !0;
};
function xo(e, t) {
  function n(i) {
    const r = $.useContext(e);
    if (!i?.optional && !r)
      throw new Error(`This component must be used within ${t}.`);
    return r;
  }
  return n;
}
function zf(e, t) {
  function n(r) {
    const s = e(r);
    return s ? s[t] : null;
  }
  function i(r) {
    let s = !1, l;
    typeof r == "function" ? l = r : r && typeof r == "object" && (s = !!r.optional, l = r.selector);
    const c = n({
      optional: s
    });
    return c ? l ? c(l) : c() : null;
  }
  return {
    [t]: i,
    [`${t}Store`]: n
  };
}
var gi = (e) => {
  const t = e;
  t.__isBound || (t.__internal_bindMethods?.(), t.__isBound = !0);
};
function IU(e, t = CU) {
  gi(e);
  const n = $.useSyncExternalStore(
    e.subscribe,
    () => t(e.getState()),
    () => t(e.getState())
  );
  return $.useDebugValue(n), n;
}
var CU = (e) => e;
function wo(e) {
  function t(n) {
    let i = !1, r;
    typeof n == "function" ? r = n : n && (i = !!n.optional, r = n.selector);
    const s = e({ optional: i });
    return s ? IU(s, r) : null;
  }
  return t;
}
var E$ = $.createContext(
  null
), $$ = xo(
  E$,
  "AssistantRuntimeProvider"
);
function OU(e) {
  const t = $$(e);
  return t ? t.useAssistantRuntime() : null;
}
var { useToolUIs: RU, useToolUIsStore: Xoe } = zf(
  $$,
  "useToolUIs"
);
const b1 = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), i = (h, p) => {
    const m = typeof h == "function" ? h(t) : h;
    if (!Object.is(m, t)) {
      const y = t;
      t = p ?? (typeof m != "object" || m === null) ? m : Object.assign({}, t, m), n.forEach((b) => b(t, y));
    }
  }, r = () => t, c = { setState: i, getState: r, getInitialState: () => f, subscribe: (h) => (n.add(h), () => n.delete(h)) }, f = t = e(i, r, c);
  return c;
}, NU = ((e) => e ? b1(e) : b1), MU = (e) => e;
function DU(e, t = MU) {
  const n = Lr.useSyncExternalStore(
    e.subscribe,
    Lr.useCallback(() => t(e.getState()), [e, t]),
    Lr.useCallback(() => t(e.getInitialState()), [e, t])
  );
  return Lr.useDebugValue(n), n;
}
const x1 = (e) => {
  const t = NU(e), n = (i) => DU(t, i);
  return Object.assign(n, t), n;
}, gn = ((e) => e ? x1(e) : x1);
var jU = () => gn((e) => {
  const t = /* @__PURE__ */ new Map();
  return Object.freeze({
    getToolUI: (n) => {
      const r = t.get(n)?.at(-1);
      return r || null;
    },
    setToolUI: (n, i) => {
      let r = t.get(n);
      return r || (r = [], t.set(n, r)), r.push(i), e({}), () => {
        const s = r.indexOf(i);
        s !== -1 && r.splice(s, 1), s === r.length && e({});
      };
    }
  });
}), A$ = $.createContext(null), PU = xo(
  A$,
  "AssistantRuntimeProvider"
);
function _i(e) {
  const t = PU(e);
  return t ? t.useThreadRuntime() : null;
}
var _u = wo(_i), qr = (e) => e, z$ = $.createContext(null), UU = xo(
  z$,
  "a component passed to <ThreadListPrimitive.Items components={...}>"
);
function If(e) {
  const t = UU(e);
  return t ? t.useThreadListItemRuntime() : null;
}
var LU = wo(
  If
), BU = (e) => {
  const [t] = $.useState(() => gn(() => e));
  return $.useEffect(() => {
    gi(e), qr(t).setState(e, !0);
  }, [e, t]), t;
}, I$ = ({ runtime: e, children: t }) => {
  const n = BU(e), [i] = $.useState(() => ({ useThreadListItemRuntime: n }));
  return /* @__PURE__ */ C.jsx(z$.Provider, { value: i, children: t });
}, ZU = () => {
  const e = /* @__PURE__ */ new Set();
  return gn(() => ({
    isAtBottom: !0,
    scrollToBottom: () => {
      for (const t of e)
        t();
    },
    onScrollToBottom: (t) => (e.add(t), () => {
      e.delete(t);
    })
  }));
}, C$ = $.createContext(null), VU = xo(
  C$,
  "ThreadPrimitive.Viewport"
), { useThreadViewport: O$, useThreadViewportStore: Vv } = zf(VU, "useThreadViewport"), FU = () => {
  const e = Vv({ optional: !0 }), [t] = $.useState(() => ZU());
  return $.useEffect(() => e?.getState().onScrollToBottom(() => {
    t.getState().scrollToBottom();
  }), [e, t]), $.useEffect(() => {
    if (e)
      return t.subscribe((n) => {
        e.getState().isAtBottom !== n.isAtBottom && qr(e).setState({ isAtBottom: n.isAtBottom });
      });
  }, [t, e]), t;
}, R$ = ({ children: e }) => {
  const t = FU(), [n] = $.useState(() => ({
    useThreadViewport: t
  }));
  return /* @__PURE__ */ C.jsx(C$.Provider, { value: n, children: e });
}, HU = (e) => {
  const [t] = $.useState(() => gn(() => e));
  return $.useEffect(() => {
    gi(e), gi(e.composer), qr(t).setState(e, !0);
  }, [e, t]), t;
}, qU = ({ children: e, listItemRuntime: t, runtime: n }) => {
  const i = HU(n), [r] = $.useState(() => ({
    useThreadRuntime: i
  }));
  return /* @__PURE__ */ C.jsx(I$, { runtime: t, children: /* @__PURE__ */ C.jsx(A$.Provider, { value: r, children: /* @__PURE__ */ C.jsx(R$, { children: e }) }) });
}, GU = (e) => {
  const [t] = $.useState(() => gn(() => e));
  return $.useEffect(() => {
    gi(e), gi(e.threads), qr(t).setState(e, !0);
  }, [e, t]), t;
}, YU = () => $.useMemo(() => jU(), []), JU = (e) => e._core?.RenderComponent, XU = ({ children: e, runtime: t }) => {
  const n = GU(t), i = YU(), [r] = $.useState(() => ({
    useToolUIs: i,
    useAssistantRuntime: n
  })), s = JU(t);
  return /* @__PURE__ */ C.jsxs(E$.Provider, { value: r, children: [
    s && /* @__PURE__ */ C.jsx(s, {}),
    /* @__PURE__ */ C.jsx(
      qU,
      {
        runtime: t.thread,
        listItemRuntime: t.threads.mainItem,
        children: e
      }
    )
  ] });
}, KU = $.memo(XU), Fv = $.createContext(
  null
), WU = xo(
  Fv,
  "a component passed to <MessagePrimitive.Parts components={...}>"
);
function Hv(e) {
  const t = WU(e);
  return t ? t.useMessagePartRuntime() : null;
}
var Su = wo(Hv), w1 = {
  type: "complete"
}, _1 = {
  type: "running"
}, QU = ({
  children: e,
  text: t,
  isRunning: n
}) => {
  const [i] = $.useState(() => {
    const r = gn(() => ({
      status: n ? _1 : w1,
      type: "text",
      text: t
    })), s = new Cg({
      path: {
        ref: "text",
        threadSelector: { type: "main" },
        messageSelector: { type: "messageId", messageId: "" },
        messagePartSelector: { type: "index", index: 0 }
      },
      getState: r.getState,
      subscribe: r.subscribe
    });
    return gi(s), { useMessagePartRuntime: gn(() => s), useMessagePart: r };
  });
  return $.useEffect(() => {
    const r = i.useMessagePart.getState(), s = r.text !== t, l = n ? _1 : w1, c = r.status !== l;
    !s && !c || qr(i.useMessagePart).setState(
      {
        type: "text",
        text: t,
        status: l
      },
      !0
    );
  }, [i, n, t]), /* @__PURE__ */ C.jsx(Fv.Provider, { value: i, children: e });
}, N$ = $.createContext(null), M$ = xo(
  N$,
  "a component passed to <ThreadPrimitive.Messages components={...} />"
);
function Ar(e) {
  const t = M$(e);
  return t ? t.useMessageRuntime() : null;
}
var qn = wo(Ar), eL = (e) => Ar(e)?.composer ?? null, D$ = wo(
  eL
), { useMessageUtils: j$, useMessageUtilsStore: qv } = zf(
  M$,
  "useMessageUtils"
);
function ku(e) {
  const t = Ar({ optional: !0 }), n = _i(e);
  return t ? t.composer : n?.composer ?? null;
}
var P$ = wo(ku), tL = (e) => {
  const t = {
    useThreadMessages: ({
      messages: n,
      isRunning: i,
      joinStrategy: r
    }) => zU({
      callback: e,
      messages: n,
      isRunning: i,
      joinStrategy: r
    }),
    toThreadMessages: (n) => AU(n, e, !1),
    toOriginalMessages: (n) => {
      const i = Za(n);
      if (i.length === 0) throw new Error("No original messages found");
      return i;
    },
    toOriginalMessage: (n) => t.toOriginalMessages(n)[0],
    useOriginalMessage: () => t.useOriginalMessages()[0],
    useOriginalMessages: () => {
      const n = Su({
        optional: !0,
        selector: Za
      }), i = qn(Za), r = n ?? i;
      if (r.length === 0) throw new Error("No original messages found");
      return r;
    }
  };
  return t;
}, S1 = (e) => {
  try {
    const n = e.split(".")[1];
    if (!n)
      throw new Error("Invalid JWT format");
    let i = n.replace(/-/g, "+").replace(/_/g, "/");
    for (; i.length % 4 !== 0; )
      i += "=";
    const r = atob(i), l = JSON.parse(r).exp;
    if (!l || typeof l != "number")
      throw new Error('JWT does not contain a valid "exp" field');
    return l * 1e3;
  } catch (t) {
    throw new Error("Unable to determine the token expiry: " + t);
  }
}, U$ = class {
  strategy = "jwt";
  cachedToken = null;
  tokenExpiry = null;
  #e;
  constructor(e) {
    this.#e = e;
  }
  async getAuthHeaders() {
    const e = Date.now();
    if (this.cachedToken && this.tokenExpiry && this.tokenExpiry - e > 30 * 1e3)
      return { Authorization: `Bearer ${this.cachedToken}` };
    const t = await this.#e();
    return t ? (this.cachedToken = t, this.tokenExpiry = S1(t), { Authorization: `Bearer ${t}` }) : !1;
  }
  readAuthHeaders(e) {
    const t = e.get("Authorization");
    if (!t) return;
    const [n, i] = t.split(" ");
    if (n !== "Bearer" || !i)
      throw new Error("Invalid auth header received");
    this.cachedToken = i, this.tokenExpiry = S1(i);
  }
}, nL = class {
  strategy = "api-key";
  #e;
  #t;
  #n;
  constructor(e, t, n) {
    this.#e = e, this.#t = t, this.#n = n;
  }
  async getAuthHeaders() {
    return {
      Authorization: `Bearer ${this.#e}`,
      "Aui-User-Id": this.#t,
      "Aui-Workspace-Id": this.#n
    };
  }
  readAuthHeaders() {
  }
}, pd = "aui:refresh_token", rL = class {
  strategy = "anon";
  baseUrl;
  jwtStrategy;
  constructor(e) {
    this.baseUrl = e, this.jwtStrategy = new U$(async () => {
      const t = Date.now(), n = localStorage.getItem(
        pd
      ), i = n ? JSON.parse(n) : void 0;
      if (i)
        if (new Date(i.expires_at).getTime() - t > 30 * 1e3) {
          const h = await fetch(
            `${this.baseUrl}/v1/auth/tokens/refresh`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ refresh_token: i.token })
            }
          );
          if (h.ok) {
            const p = await h.json(), { access_token: m, refresh_token: y } = p;
            return y && localStorage.setItem(
              pd,
              JSON.stringify(y)
            ), m;
          }
        } else
          localStorage.removeItem(pd);
      const r = await fetch(`${this.baseUrl}/v1/auth/tokens/anonymous`, {
        method: "POST"
      });
      if (!r.ok) return null;
      const s = await r.json(), { access_token: l, refresh_token: c } = s;
      return !l || !c ? null : (localStorage.setItem(
        pd,
        JSON.stringify(c)
      ), l);
    });
  }
  async getAuthHeaders() {
    return this.jwtStrategy.getAuthHeaders();
  }
  readAuthHeaders(e) {
    this.jwtStrategy.readAuthHeaders(e);
  }
}, iL = class extends Error {
  constructor(e) {
    super(e), this.name = "APIError";
  }
}, aL = class {
  _auth;
  _baseUrl;
  constructor(e) {
    if ("authToken" in e)
      this._baseUrl = e.baseUrl, this._auth = new U$(e.authToken);
    else if ("apiKey" in e)
      this._baseUrl = "https://backend.assistant-api.com", this._auth = new nL(
        e.apiKey,
        e.userId,
        e.workspaceId
      );
    else if ("anonymous" in e)
      this._baseUrl = e.baseUrl, this._auth = new rL(e.baseUrl);
    else
      throw new Error(
        "Invalid configuration: Must provide authToken, apiKey, or anonymous configuration"
      );
  }
  async initializeAuth() {
    return !!this._auth.getAuthHeaders();
  }
  async makeRawRequest(e, t = {}) {
    const n = await this._auth.getAuthHeaders();
    if (!n) throw new Error("Authorization failed");
    const i = {
      ...n,
      ...t.headers,
      "Content-Type": "application/json"
    }, r = new URLSearchParams();
    if (t.query)
      for (const [c, f] of Object.entries(t.query))
        f !== !1 && (f === !0 ? r.set(c, "true") : r.set(c, f.toString()));
    const s = new URL(`${this._baseUrl}/v1${e}`);
    s.search = r.toString();
    const l = await fetch(s, {
      method: t.method ?? "GET",
      headers: i,
      body: t.body ? JSON.stringify(t.body) : null
    });
    if (this._auth.readAuthHeaders(l.headers), !l.ok) {
      const c = await l.text();
      try {
        const f = JSON.parse(c);
        throw new iL(f.message);
      } catch {
        throw new Error(
          `Request failed with status ${l.status}, ${c}`
        );
      }
    }
    return l;
  }
  async makeRequest(e, t = {}) {
    return (await this.makeRawRequest(e, t)).json();
  }
}, sL = class {
  constructor(e) {
    this.cloud = e;
  }
  async create() {
    return this.cloud.makeRequest("/auth/tokens", { method: "POST" });
  }
}, oL = class {
  constructor(e) {
    this.cloud = e;
  }
  __internal_getAssistantOptions(e) {
    return {
      api: this.cloud._baseUrl + "/v1/runs/stream",
      headers: async () => {
        const t = await this.cloud._auth.getAuthHeaders();
        if (!t) throw new Error("Authorization failed");
        return {
          ...t,
          Accept: "text/plain"
        };
      },
      body: {
        assistant_id: e,
        response_format: "vercel-ai-data-stream/v1",
        thread_id: "unstable_todo"
      }
    };
  }
  async stream(e) {
    const t = await this.cloud.makeRawRequest("/runs/stream", {
      method: "POST",
      headers: {
        Accept: "text/plain"
      },
      body: e
    });
    return zg.fromResponse(t, new sU());
  }
}, lL = class {
  constructor(e) {
    this.cloud = e;
  }
  async list(e, t) {
    return this.cloud.makeRequest(
      `/threads/${encodeURIComponent(e)}/messages`,
      { query: t }
    );
  }
  async create(e, t) {
    return this.cloud.makeRequest(
      `/threads/${encodeURIComponent(e)}/messages`,
      { method: "POST", body: t }
    );
  }
}, uL = class {
  constructor(e) {
    this.cloud = e, this.messages = new lL(e);
  }
  messages;
  async list(e) {
    return this.cloud.makeRequest("/threads", { query: e });
  }
  async create(e) {
    return this.cloud.makeRequest("/threads", { method: "POST", body: e });
  }
  async update(e, t) {
    return this.cloud.makeRequest(`/threads/${encodeURIComponent(e)}`, {
      method: "PUT",
      body: t
    });
  }
  async delete(e) {
    return this.cloud.makeRequest(`/threads/${encodeURIComponent(e)}`, {
      method: "DELETE"
    });
  }
}, cL = class {
  constructor(e) {
    this.cloud = e;
  }
  async pdfToImages(e) {
    return this.cloud.makeRequest("/files/pdf-to-images", {
      method: "POST",
      body: e
    });
  }
  async generatePresignedUploadUrl(e) {
    return this.cloud.makeRequest(
      "/files/attachments/generate-presigned-upload-url",
      {
        method: "POST",
        body: e
      }
    );
  }
}, dL = class {
  threads;
  auth;
  runs;
  files;
  constructor(e) {
    const t = new aL(e);
    this.threads = new uL(t), this.auth = {
      tokens: new sL(t)
    }, this.runs = new oL(t), this.files = new cL(t);
  }
};
function Ng(e, t = 0) {
  return t > 100 ? !1 : e === null || typeof e == "string" || typeof e == "boolean" ? !0 : typeof e == "number" ? !Number.isNaN(e) && Number.isFinite(e) : Array.isArray(e) ? e.every((n) => Ng(n, t + 1)) : typeof e == "object" ? Object.entries(e).every(
    ([n, i]) => typeof n == "string" && Ng(i, t + 1)
  ) : !1;
}
var fL = (e) => ({
  role: e.role,
  content: e.content.map((t) => {
    const n = t.type;
    switch (n) {
      case "text":
        return {
          type: "text",
          text: t.text
        };
      case "reasoning":
        return {
          type: "reasoning",
          text: t.text
        };
      case "source":
        return {
          type: "source",
          sourceType: t.sourceType,
          id: t.id,
          url: t.url,
          ...t.title ? { title: t.title } : void 0
        };
      case "tool-call":
        return Ng(t.result) || console.warn(
          "tool-call result is not JSON! " + JSON.stringify(t)
        ), {
          type: "tool-call",
          toolCallId: t.toolCallId,
          toolName: t.toolName,
          ...JSON.stringify(t.args) === t.argsText ? {
            args: t.args
          } : { argsText: t.argsText },
          ...t.result ? { result: t.result } : {},
          ...t.isError ? { isError: !0 } : {}
        };
      default: {
        const i = n;
        throw new Error(
          `Message part type not supported by aui/v0: ${i}`
        );
      }
    }
  }),
  metadata: e.metadata,
  ...e.status ? {
    status: e.status?.type === "running" ? {
      type: "incomplete",
      reason: "cancelled"
    } : e.status
  } : void 0
}), hL = (e) => {
  const t = e.content, n = Wa(
    {
      id: e.id,
      createdAt: e.created_at,
      ...t
    },
    e.id,
    {
      type: "complete",
      reason: "unknown"
    }
  );
  return {
    parentId: e.parent_id,
    message: n
  };
}, pL = class {
  constructor(e, t) {
    this.parent = e, this.formatAdapter = t;
  }
  async append(e) {
    const t = this.formatAdapter.encode(e), n = this.formatAdapter.getId(e.message);
    return this.parent._appendWithFormat(
      e.parentId,
      n,
      this.formatAdapter.format,
      t
    );
  }
  async load() {
    return this.parent._loadWithFormat(
      this.formatAdapter.format,
      (e) => this.formatAdapter.decode(e)
    );
  }
}, mL = class {
  constructor(e, t) {
    this.cloudRef = e, this.threadListItemRuntime = t;
  }
  _getIdForLocalId = {};
  withFormat(e) {
    return new pL(this, e);
  }
  async append({ parentId: e, message: t }) {
    const { remoteId: n } = await this.threadListItemRuntime.initialize(), i = this.cloudRef.current.threads.messages.create(n, {
      parent_id: e ? await this._getIdForLocalId[e] ?? e : null,
      format: "aui/v0",
      content: fL(t)
    }).then(({ message_id: r }) => (this._getIdForLocalId[t.id] = r, r));
    return this._getIdForLocalId[t.id] = i, i.then(() => {
    });
  }
  async load() {
    const e = this.threadListItemRuntime.getState().remoteId;
    if (!e) return { messages: [] };
    const { messages: t } = await this.cloudRef.current.threads.messages.list(
      e,
      {
        format: "aui/v0"
      }
    );
    return {
      messages: t.filter(
        (i) => i.format === "aui/v0"
      ).map(hL).reverse()
    };
  }
  // Internal methods for FormattedThreadHistoryAdapter
  async _appendWithFormat(e, t, n, i) {
    const { remoteId: r } = await this.threadListItemRuntime.initialize(), s = this.cloudRef.current.threads.messages.create(r, {
      parent_id: e ? await this._getIdForLocalId[e] ?? e : null,
      format: n,
      content: i
    }).then(({ message_id: l }) => (this._getIdForLocalId[t] = l, l));
    return this._getIdForLocalId[t] = s, s.then(() => {
    });
  }
  async _loadWithFormat(e, t) {
    const n = this.threadListItemRuntime.getState().remoteId;
    if (!n) return { messages: [] };
    const { messages: i } = await this.cloudRef.current.threads.messages.list(
      n,
      {
        format: e
      }
    );
    return {
      messages: i.filter((r) => r.format === e).map(
        (r) => t({
          id: r.id,
          parent_id: r.parent_id,
          format: r.format,
          content: r.content
        })
      ).reverse()
    };
  }
}, gL = (e) => {
  const t = If(), [n] = $.useState(
    () => new mL(e, t)
  );
  return n;
}, vL = class {
  list() {
    return Promise.resolve({
      threads: []
    });
  }
  rename() {
    return Promise.resolve();
  }
  archive() {
    return Promise.resolve();
  }
  unarchive() {
    return Promise.resolve();
  }
  delete() {
    return Promise.resolve();
  }
  initialize(e) {
    return Promise.resolve({ remoteId: e, externalId: void 0 });
  }
  generateTitle() {
    return Promise.resolve(new ReadableStream());
  }
}, yL = {}, k1 = typeof process < "u" && yL?.NEXT_PUBLIC_ASSISTANT_BASE_URL, T1 = k1 ? new dL({ baseUrl: k1, anonymous: !0 }) : void 0, bL = (e) => {
  const t = $.useRef(e);
  $.useEffect(() => {
    t.current = e;
  }, [e]);
  const n = $.useCallback(
    function({ children: s }) {
      const l = gL({
        get current() {
          return t.current.cloud ?? T1;
        }
      }), c = $.useMemo(() => ({ history: l }), [l]);
      return /* @__PURE__ */ C.jsx(_$, { adapters: c, children: s });
    },
    []
  ), i = e.cloud ?? T1;
  return i ? {
    list: async () => {
      const { threads: r } = await i.threads.list();
      return {
        threads: r.map((s) => ({
          status: s.is_archived ? "archived" : "regular",
          remoteId: s.id,
          title: s.title,
          externalId: s.external_id ?? void 0
        }))
      };
    },
    initialize: async () => {
      const s = await (e.create?.() ?? Promise.resolve()), l = s ? s.externalId : void 0, { thread_id: c } = await i.threads.create({
        last_message_at: /* @__PURE__ */ new Date(),
        external_id: l
      });
      return { externalId: l, remoteId: c };
    },
    rename: async (r, s) => i.threads.update(r, { title: s }),
    archive: async (r) => i.threads.update(r, { is_archived: !0 }),
    unarchive: async (r) => i.threads.update(r, { is_archived: !1 }),
    delete: async (r) => (await e.delete?.(r), i.threads.delete(r)),
    generateTitle: async (r, s) => i.runs.stream({
      thread_id: r,
      assistant_id: "system/thread_title",
      messages: s
      // TODO serialize these to a more efficient format
    }),
    unstable_Provider: n
  } : new vL();
}, Gv = class {
  constructor(e) {
    this._core = e, this.threads = new gU(e.threads), this._thread = this.threads.main;
  }
  threads;
  get threadList() {
    return this.threads;
  }
  _thread;
  __internal_bindMethods() {
    this.switchToNewThread = this.switchToNewThread.bind(this), this.switchToThread = this.switchToThread.bind(this), this.registerModelContextProvider = this.registerModelContextProvider.bind(this), this.registerModelConfigProvider = this.registerModelConfigProvider.bind(this), this.reset = this.reset.bind(this);
  }
  get thread() {
    return this._thread;
  }
  switchToNewThread() {
    return this._core.threads.switchToNewThread();
  }
  switchToThread(e) {
    return this._core.threads.switchToThread(e);
  }
  registerModelContextProvider(e) {
    return this._core.registerModelContextProvider(e);
  }
  registerModelConfigProvider(e) {
    return this.registerModelContextProvider(e);
  }
  reset({
    initialMessages: e
  } = {}) {
    return this._core.threads.getMainThreadRuntimeCore().import(l$.fromArray(e ?? []));
  }
}, xL = (e) => {
  const {
    cloud: t,
    initialMessages: n,
    maxSteps: i,
    adapters: r,
    unstable_humanToolNames: s,
    ...l
  } = e;
  return {
    localRuntimeOptions: {
      cloud: t,
      initialMessages: n,
      maxSteps: i,
      adapters: r,
      unstable_humanToolNames: s
    },
    otherOptions: l
  };
};
function Gr(e) {
  const t = $.useRef(e);
  return $.useEffect(() => {
    t.current = e;
  }), $.useMemo(() => (...n) => t.current?.(...n), []);
}
var L$ = $.createContext(null), wL = (e) => ({ useSmoothStatus: gn(() => e) }), _L = ({ children: e }) => {
  const t = B$({ optional: !0 }), n = Hv(), [i] = $.useState(
    () => wL(n.getState().status)
  );
  return t ? e : /* @__PURE__ */ C.jsx(L$.Provider, { value: i, children: e });
}, SL = (e) => {
  const t = $.forwardRef((n, i) => /* @__PURE__ */ C.jsx(_L, { children: /* @__PURE__ */ C.jsx(e, { ...n, ref: i }) }));
  return t.displayName = e.displayName, t;
};
function B$(e) {
  const t = $.useContext(L$);
  if (!e?.optional && !t)
    throw new Error(
      "This component must be used within a SmoothContextProvider."
    );
  return t;
}
var { useSmoothStatus: kL, useSmoothStatusStore: TL } = zf(
  B$,
  "useSmoothStatus"
), EL = class {
  constructor(e, t) {
    this.currentText = e, this.setText = t;
  }
  animationFrameId = null;
  lastUpdateTime = Date.now();
  targetText = "";
  start() {
    this.animationFrameId === null && (this.lastUpdateTime = Date.now(), this.animate());
  }
  stop() {
    this.animationFrameId !== null && (cancelAnimationFrame(this.animationFrameId), this.animationFrameId = null);
  }
  animate = () => {
    const e = Date.now();
    let n = e - this.lastUpdateTime;
    const i = this.targetText.length - this.currentText.length, r = Math.min(5, 250 / i);
    let s = 0;
    for (; n >= r && s < i; )
      s++, n -= r;
    s !== i ? this.animationFrameId = requestAnimationFrame(this.animate) : this.animationFrameId = null, s !== 0 && (this.currentText = this.targetText.slice(
      0,
      this.currentText.length + s
    ), this.lastUpdateTime = e - n, this.setText(this.currentText));
  };
}, Pm = Object.freeze({
  type: "running"
}), Z$ = (e, t = !1) => {
  const { text: n } = e, i = qn({
    optional: !0,
    selector: (p) => p.id
  }), r = $.useRef(i), [s, l] = $.useState(n), c = TL({ optional: !0 }), f = Gr((p) => {
    if (l(p), c) {
      const m = s !== p || e.status.type === "running" ? Pm : e.status;
      qr(c).setState(m, !0);
    }
  });
  $.useEffect(() => {
    if (c) {
      const p = s !== n || e.status.type === "running" ? Pm : e.status;
      qr(c).setState(p, !0);
    }
  }, [c, n, s, e.status]);
  const [h] = $.useState(
    new EL(n, f)
  );
  return $.useEffect(() => {
    if (!t) {
      h.stop();
      return;
    }
    if (r.current !== i || !n.startsWith(h.targetText)) {
      r.current = i, f(n), h.currentText = n, h.targetText = n, h.stop();
      return;
    }
    h.targetText = n, h.start();
  }, [f, h, i, t, n]), $.useEffect(() => () => {
    h.stop();
  }, [h]), $.useMemo(
    () => t ? {
      type: "text",
      text: s,
      status: n === s ? e.status : Pm
    } : e,
    [t, s, e, n]
  );
};
const V$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AssistantRuntimeImpl: Gv,
  BaseAssistantRuntimeCore: Bv,
  CompositeContextProvider: t$,
  DefaultThreadComposerRuntimeCore: r$,
  MessageRepository: u$,
  ThreadRuntimeImpl: w$,
  fromThreadMessageLike: Wa,
  generateId: xu,
  getAutoStatus: wu,
  splitLocalRuntimeOptions: xL,
  useSmooth: Z$,
  useSmoothStatus: kL,
  withSmoothContextProvider: SL
}, Symbol.toStringTag, { value: "Module" }));
var $L = class extends Ef {
  useRuntimeHook;
  instances = /* @__PURE__ */ new Map();
  useAliveThreadsKeysChanged = gn(() => ({}));
  constructor(e) {
    super(), this.useRuntimeHook = gn(() => ({ useRuntime: e }));
  }
  startThreadRuntime(e) {
    return this.instances.has(e) || (this.instances.set(e, {}), this.useAliveThreadsKeysChanged.setState({}, !0)), new Promise((t, n) => {
      const i = () => {
        const s = this.instances.get(e);
        if (!s)
          r(), n(new Error("Thread was deleted before runtime was started"));
        else if (s.runtime)
          r(), t(s.runtime);
        else
          return;
      }, r = this.subscribe(i);
      i();
    });
  }
  getThreadRuntimeCore(e) {
    const t = this.instances.get(e);
    if (t)
      return t.runtime;
  }
  stopThreadRuntime(e) {
    this.instances.delete(e), this.useAliveThreadsKeysChanged.setState({}, !0);
  }
  setRuntimeHook(e) {
    this.useRuntimeHook.getState().useRuntime !== e && this.useRuntimeHook.setState({ useRuntime: e }, !0);
  }
  _InnerActiveThreadProvider = () => {
    const { id: e } = LU(), { useRuntime: t } = this.useRuntimeHook(), n = t(), i = n.thread.__internal_threadBinding, r = $.useCallback(() => {
      const c = this.instances.get(e);
      if (!c)
        throw new Error("Thread not found. This is a bug in assistant-ui.");
      c.runtime = i.getState(), s && this._notifySubscribers();
    }, [e, i]), s = $.useRef(!1);
    s.current || r(), $.useEffect(() => (s.current = !0, r(), i.outerSubscribe(r)), [i, r]);
    const l = If();
    return $.useEffect(() => n.threads.main.unstable_on("initialize", () => {
      if (l.getState().status === "new") {
        l.initialize();
        const c = n.thread.unstable_on("run-end", () => {
          c(), l.generateTitle();
        });
      }
    }), [n, l]), null;
  };
  _OuterActiveThreadProvider = $.memo(({ threadId: e, provider: t }) => {
    const n = OU(), i = $.useMemo(
      () => n.threads.getItemById(e),
      [n, e]
    );
    return /* @__PURE__ */ C.jsx(I$, { runtime: i, children: /* @__PURE__ */ C.jsx(t, { children: /* @__PURE__ */ C.jsx(this._InnerActiveThreadProvider, {}) }) });
  });
  __internal_RenderThreadRuntimes = ({ provider: e }) => (this.useAliveThreadsKeysChanged(), Array.from(this.instances.keys()).map((t) => /* @__PURE__ */ C.jsx(
    this._OuterActiveThreadProvider,
    {
      threadId: t,
      provider: e
    },
    t
  )));
}, Xt = new Error(
  "This is the empty thread, a placeholder for the main thread. You cannot perform any actions on this thread instance. This error is probably because you tried to call a thread method in your render function. Call the method inside a `useEffect` hook instead."
), AL = {
  getMessageById() {
  },
  getBranches() {
    return [];
  },
  switchToBranch() {
    throw Xt;
  },
  append() {
    throw Xt;
  },
  startRun() {
    throw Xt;
  },
  resumeRun() {
    throw Xt;
  },
  cancelRun() {
    throw Xt;
  },
  addToolResult() {
    throw Xt;
  },
  speak() {
    throw Xt;
  },
  stopSpeaking() {
    throw Xt;
  },
  getSubmittedFeedback() {
  },
  submitFeedback() {
    throw Xt;
  },
  getModelContext() {
    return {};
  },
  composer: {
    attachments: [],
    getAttachmentAccept() {
      return "*";
    },
    async addAttachment() {
      throw Xt;
    },
    async removeAttachment() {
      throw Xt;
    },
    isEditing: !1,
    canCancel: !1,
    isEmpty: !0,
    text: "",
    setText() {
      throw Xt;
    },
    role: "user",
    setRole() {
      throw Xt;
    },
    runConfig: {},
    setRunConfig() {
      throw Xt;
    },
    async reset() {
    },
    async clearAttachments() {
    },
    send() {
      throw Xt;
    },
    cancel() {
    },
    subscribe() {
      return () => {
      };
    },
    unstable_on() {
      return () => {
      };
    }
  },
  getEditComposer() {
  },
  beginEdit() {
    throw Xt;
  },
  speech: void 0,
  capabilities: {
    switchToBranch: !1,
    edit: !1,
    reload: !1,
    cancel: !1,
    unstable_copy: !1,
    speech: !1,
    attachments: !1,
    feedback: !1
  },
  isDisabled: !0,
  isLoading: !1,
  messages: [],
  state: null,
  suggestions: [],
  extras: void 0,
  subscribe() {
    return () => {
    };
  },
  import() {
    throw Xt;
  },
  export() {
    return { messages: [] };
  },
  reset() {
    throw Xt;
  },
  unstable_on() {
    return () => {
    };
  }
}, E1 = (e, t, n) => n.reduce((i, r) => r?.(i, t) ?? i, e), zL = class extends Ef {
  _pendingTransforms = [];
  _baseValue;
  _cachedValue;
  constructor(e) {
    super(), this._baseValue = e, this._cachedValue = e;
  }
  _updateState() {
    this._cachedValue = this._pendingTransforms.reduce((e, t) => E1(e, t.task, [
      t.loading,
      t.optimistic
    ]), this._baseValue), this._notifySubscribers();
  }
  get baseValue() {
    return this._baseValue;
  }
  get value() {
    return this._cachedValue;
  }
  update(e) {
    this._baseValue = e, this._updateState();
  }
  async optimisticUpdate(e) {
    const t = e.execute(), n = { ...e, task: t };
    try {
      this._pendingTransforms.push(n), this._updateState();
      const i = await t;
      return this._baseValue = E1(this._baseValue, i, [
        e.optimistic,
        e.then
      ]), i;
    } finally {
      const i = this._pendingTransforms.indexOf(n);
      i > -1 && this._pendingTransforms.splice(i, 1), this._updateState();
    }
  }
};
var jd = (e, t) => {
  const n = e.threadIdMap[t];
  if (n !== void 0)
    return e.threadData[n];
}, md = (e, t, n) => {
  const i = jd(e, t);
  if (!i) return e;
  const { threadId: r, remoteId: s, status: l } = i;
  if (l === n) return e;
  const c = { ...e };
  switch (l) {
    case "new":
      c.newThreadId = void 0;
      break;
    case "regular":
      c.threadIds = c.threadIds.filter((f) => f !== r);
      break;
    case "archived":
      c.archivedThreadIds = c.archivedThreadIds.filter(
        (f) => f !== r
      );
      break;
    default: {
      const f = l;
      throw new Error(`Unsupported state: ${f}`);
    }
  }
  switch (n) {
    case "regular":
      c.threadIds = [r, ...c.threadIds];
      break;
    case "archived":
      c.archivedThreadIds = [r, ...c.archivedThreadIds];
      break;
    case "deleted":
      c.threadData = Object.fromEntries(
        Object.entries(c.threadData).filter(([f]) => f !== r)
      ), c.threadIdMap = Object.fromEntries(
        Object.entries(c.threadIdMap).filter(
          ([f]) => f !== r && f !== s
        )
      );
      break;
    default: {
      const f = n;
      throw new Error(`Unsupported state: ${f}`);
    }
  }
  return n !== "deleted" && (c.threadData = {
    ...c.threadData,
    [r]: {
      ...i,
      status: n
    }
  }), c;
}, IL = class extends Ef {
  constructor(e, t) {
    super(), this.contextProvider = t, this._state.subscribe(() => this._notifySubscribers()), this._hookManager = new $L(
      e.runtimeHook
    ), this.useProvider = gn(() => ({
      Provider: e.adapter.unstable_Provider ?? $.Fragment
    })), this.__internal_setOptions(e), this.switchToNewThread();
  }
  _options;
  _hookManager;
  _loadThreadsPromise;
  _mainThreadId;
  _state = new zL({
    isLoading: !1,
    newThreadId: void 0,
    threadIds: [],
    archivedThreadIds: [],
    threadIdMap: {},
    threadData: {}
  });
  getLoadThreadsPromise() {
    return this._loadThreadsPromise || (this._loadThreadsPromise = this._state.optimisticUpdate({
      execute: () => this._options.adapter.list(),
      loading: (e) => ({
        ...e,
        isLoading: !0
      }),
      then: (e, t) => {
        const n = [], i = [], r = {}, s = {};
        for (const l of t.threads) {
          switch (l.status) {
            case "regular":
              n.push(l.remoteId);
              break;
            case "archived":
              i.push(l.remoteId);
              break;
            default: {
              const f = l.status;
              throw new Error(`Unsupported state: ${f}`);
            }
          }
          const c = l.remoteId;
          r[l.remoteId] = c, s[c] = {
            threadId: l.remoteId,
            remoteId: l.remoteId,
            externalId: l.externalId,
            status: l.status,
            title: l.title,
            initializeTask: Promise.resolve({
              remoteId: l.remoteId,
              externalId: l.externalId
            })
          };
        }
        return {
          ...e,
          threadIds: n,
          archivedThreadIds: i,
          threadIdMap: {
            ...e.threadIdMap,
            ...r
          },
          threadData: {
            ...e.threadData,
            ...s
          }
        };
      }
    }).then(() => {
    })), this._loadThreadsPromise;
  }
  useProvider;
  __internal_setOptions(e) {
    if (this._options === e) return;
    this._options = e;
    const t = e.adapter.unstable_Provider ?? $.Fragment;
    t !== this.useProvider.getState().Provider && this.useProvider.setState({ Provider: t }, !0), this._hookManager.setRuntimeHook(e.runtimeHook);
  }
  __internal_load() {
    this.getLoadThreadsPromise();
  }
  get isLoading() {
    return this._state.value.isLoading;
  }
  get threadIds() {
    return this._state.value.threadIds;
  }
  get archivedThreadIds() {
    return this._state.value.archivedThreadIds;
  }
  get newThreadId() {
    return this._state.value.newThreadId;
  }
  get mainThreadId() {
    return this._mainThreadId;
  }
  getMainThreadRuntimeCore() {
    const e = this._hookManager.getThreadRuntimeCore(this._mainThreadId);
    return e || AL;
  }
  getThreadRuntimeCore(e) {
    const t = this.getItemById(e);
    if (!t) throw new Error("Thread not found");
    const n = this._hookManager.getThreadRuntimeCore(t.threadId);
    if (!n) throw new Error("Thread not found");
    return n;
  }
  getItemById(e) {
    return jd(this._state.value, e);
  }
  async switchToThread(e) {
    const t = this.getItemById(e);
    if (!t) throw new Error("Thread not found");
    if (this._mainThreadId === t.threadId) return;
    const n = this._hookManager.startThreadRuntime(t.threadId);
    this.mainThreadId !== void 0 ? await n : n.then(() => this._notifySubscribers()), t.status === "archived" && await this.unarchive(t.threadId), this._mainThreadId = t.threadId, this._notifySubscribers();
  }
  async switchToNewThread() {
    for (; this._state.baseValue.newThreadId !== void 0 && this._state.value.newThreadId === void 0; )
      await this._state.waitForUpdate();
    const e = this._state.value;
    let t = this._state.value.newThreadId;
    if (t === void 0) {
      do
        t = `__LOCALID_${xu()}`;
      while (e.threadIdMap[t]);
      const n = t;
      this._state.update({
        ...e,
        newThreadId: t,
        threadIdMap: {
          ...e.threadIdMap,
          [t]: n
        },
        threadData: {
          ...e.threadData,
          [t]: {
            status: "new",
            threadId: t
          }
        }
      });
    }
    return this.switchToThread(t);
  }
  initialize = async (e) => {
    if (this._state.value.newThreadId !== e) {
      const t = this.getItemById(e);
      if (!t) throw new Error("Thread not found");
      if (t.status === "new") throw new Error("Unexpected new state");
      return t.initializeTask;
    }
    return this._state.optimisticUpdate({
      execute: () => this._options.adapter.initialize(e),
      optimistic: (t) => md(t, e, "regular"),
      loading: (t, n) => {
        const i = e;
        return {
          ...t,
          threadData: {
            ...t.threadData,
            [i]: {
              ...t.threadData[i],
              initializeTask: n
            }
          }
        };
      },
      then: (t, { remoteId: n, externalId: i }) => {
        const r = jd(t, e);
        if (!r) return t;
        const s = e;
        return {
          ...t,
          threadIdMap: {
            ...t.threadIdMap,
            [n]: s
          },
          threadData: {
            ...t.threadData,
            [s]: {
              ...r,
              initializeTask: Promise.resolve({ remoteId: n, externalId: i }),
              remoteId: n,
              externalId: i
            }
          }
        };
      }
    });
  };
  generateTitle = async (e) => {
    const t = this.getItemById(e);
    if (!t) throw new Error("Thread not found");
    if (t.status === "new") throw new Error("Thread is not yet initialized");
    const { remoteId: n } = await t.initializeTask, i = this._hookManager.getThreadRuntimeCore(t.threadId);
    if (!i) return;
    const r = i.messages, s = await this._options.adapter.generateTitle(
      n,
      r
    ), l = oU.fromAssistantStream(s);
    for await (const c of l) {
      const f = c.parts.filter((p) => p.type === "text")[0]?.text, h = this._state.baseValue;
      this._state.update({
        ...h,
        threadData: {
          ...h.threadData,
          [t.threadId]: {
            ...t,
            title: f
          }
        }
      });
    }
  };
  rename(e, t) {
    const n = this.getItemById(e);
    if (!n) throw new Error("Thread not found");
    if (n.status === "new") throw new Error("Thread is not yet initialized");
    return this._state.optimisticUpdate({
      execute: async () => {
        const { remoteId: i } = await n.initializeTask;
        return this._options.adapter.rename(i, t);
      },
      optimistic: (i) => {
        const r = jd(i, e);
        return r ? {
          ...i,
          threadData: {
            ...i.threadData,
            [r.threadId]: {
              ...r,
              title: t
            }
          }
        } : i;
      }
    });
  }
  async _ensureThreadIsNotMain(e) {
    if (e === this.newThreadId)
      throw new Error("Cannot ensure new thread is not main");
    e === this._mainThreadId && await this.switchToNewThread();
  }
  async archive(e) {
    const t = this.getItemById(e);
    if (!t) throw new Error("Thread not found");
    if (t.status !== "regular")
      throw new Error("Thread is not yet initialized or already archived");
    return this._state.optimisticUpdate({
      execute: async () => {
        await this._ensureThreadIsNotMain(t.threadId);
        const { remoteId: n } = await t.initializeTask;
        return this._options.adapter.archive(n);
      },
      optimistic: (n) => md(n, t.threadId, "archived")
    });
  }
  unarchive(e) {
    const t = this.getItemById(e);
    if (!t) throw new Error("Thread not found");
    if (t.status !== "archived") throw new Error("Thread is not archived");
    return this._state.optimisticUpdate({
      execute: async () => {
        try {
          const { remoteId: n } = await t.initializeTask;
          return await this._options.adapter.unarchive(n);
        } catch (n) {
          throw await this._ensureThreadIsNotMain(t.threadId), n;
        }
      },
      optimistic: (n) => md(n, t.threadId, "regular")
    });
  }
  async delete(e) {
    const t = this.getItemById(e);
    if (!t) throw new Error("Thread not found");
    if (t.status !== "regular" && t.status !== "archived")
      throw new Error("Thread is not yet initialized");
    return this._state.optimisticUpdate({
      execute: async () => {
        await this._ensureThreadIsNotMain(t.threadId);
        const { remoteId: n } = await t.initializeTask;
        return await this._options.adapter.delete(n);
      },
      optimistic: (n) => md(n, t.threadId, "deleted")
    });
  }
  async detach(e) {
    const t = this.getItemById(e);
    if (!t) throw new Error("Thread not found");
    if (t.status !== "regular" && t.status !== "archived")
      throw new Error("Thread is not yet initialized");
    await this._ensureThreadIsNotMain(t.threadId), this._hookManager.stopThreadRuntime(t.threadId);
  }
  useBoundIds = gn(() => []);
  __internal_RenderComponent = () => {
    const e = $.useId();
    $.useEffect(() => (this.useBoundIds.setState((r) => [...r, e], !0), () => {
      this.useBoundIds.setState((r) => r.filter((s) => s !== e), !0);
    }), [e]);
    const t = this.useBoundIds(), { Provider: n } = this.useProvider(), i = {
      modelContext: this.contextProvider
    };
    return (t.length === 0 || t[0] === e) && // only render if the component is the first one mounted
    /* @__PURE__ */ C.jsx(_$, { adapters: i, children: /* @__PURE__ */ C.jsx(
      this._hookManager.__internal_RenderThreadRuntimes,
      {
        provider: n
      }
    ) });
  };
}, CL = class extends Bv {
  threads;
  constructor(e) {
    super(), this.threads = new IL(
      e,
      this._contextProvider
    );
  }
  get RenderComponent() {
    return this.threads.__internal_RenderComponent;
  }
}, OL = (e) => {
  const [t] = $.useState(() => new CL(e));
  return $.useEffect(() => {
    t.threads.__internal_setOptions(e), t.threads.__internal_load();
  }, [t, e]), $.useMemo(() => new Gv(t), [t]);
};
function $1(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function F$(...e) {
  return (t) => {
    let n = !1;
    const i = e.map((r) => {
      const s = $1(r, t);
      return !n && typeof s == "function" && (n = !0), s;
    });
    if (n)
      return () => {
        for (let r = 0; r < i.length; r++) {
          const s = i[r];
          typeof s == "function" ? s() : $1(e[r], null);
        }
      };
  };
}
function zr(...e) {
  return $.useCallback(F$(...e), e);
}
var Yv = e$();
const RL = /* @__PURE__ */ la(Yv);
// @__NO_SIDE_EFFECTS__
function H$(e) {
  const t = /* @__PURE__ */ NL(e), n = $.forwardRef((i, r) => {
    const { children: s, ...l } = i, c = $.Children.toArray(s), f = c.find(DL);
    if (f) {
      const h = f.props.children, p = c.map((m) => m === f ? $.Children.count(h) > 1 ? $.Children.only(null) : $.isValidElement(h) ? h.props.children : null : m);
      return /* @__PURE__ */ C.jsx(t, { ...l, ref: r, children: $.isValidElement(h) ? $.cloneElement(h, void 0, p) : null });
    }
    return /* @__PURE__ */ C.jsx(t, { ...l, ref: r, children: s });
  });
  return n.displayName = `${e}.Slot`, n;
}
var q$ = /* @__PURE__ */ H$("Slot");
// @__NO_SIDE_EFFECTS__
function NL(e) {
  const t = $.forwardRef((n, i) => {
    const { children: r, ...s } = n;
    if ($.isValidElement(r)) {
      const l = PL(r), c = jL(s, r.props);
      return r.type !== $.Fragment && (c.ref = i ? F$(i, l) : l), $.cloneElement(r, c);
    }
    return $.Children.count(r) > 1 ? $.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var G$ = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function ML(e) {
  const t = ({ children: n }) => /* @__PURE__ */ C.jsx(C.Fragment, { children: n });
  return t.displayName = `${e}.Slottable`, t.__radixId = G$, t;
}
function DL(e) {
  return $.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === G$;
}
function jL(e, t) {
  const n = { ...t };
  for (const i in t) {
    const r = e[i], s = t[i];
    /^on[A-Z]/.test(i) ? r && s ? n[i] = (...c) => {
      const f = s(...c);
      return r(...c), f;
    } : r && (n[i] = r) : i === "style" ? n[i] = { ...r, ...s } : i === "className" && (n[i] = [r, s].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function PL(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var UL = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Ft = UL.reduce((e, t) => {
  const n = /* @__PURE__ */ H$(`Primitive.${t}`), i = $.forwardRef((r, s) => {
    const { asChild: l, ...c } = r, f = l ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ C.jsx(f, { ...c, ref: s });
  });
  return i.displayName = `Primitive.${t}`, { ...e, [t]: i };
}, {});
function LL(e, t) {
  e && Yv.flushSync(() => e.dispatchEvent(t));
}
var BL = (e) => {
  const t = (n) => {
    const i = e.map((r) => r.subscribe(n));
    return () => {
      for (const r of i)
        r();
    };
  };
  return (n) => {
    const i = () => n(...e.map((r) => r.getState()));
    return $.useSyncExternalStore(t, i, i);
  };
}, Cf = (e, t) => $.useMemo(() => BL(e), e)(t), Mg = /* @__PURE__ */ ((e) => (e.Hidden = "hidden", e.Floating = "floating", e.Normal = "normal", e))(Mg || {}), ZL = ({
  hideWhenRunning: e,
  autohide: t,
  autohideFloat: n
}) => {
  const i = _i(), r = Ar(), s = qv();
  return Cf(
    [i, r, s],
    (l, c, f) => e && l.isRunning ? "hidden" : t === "always" || t === "not-last" && !c.isLast ? f.isHovering ? n === "always" || n === "single-branch" && c.branchCount <= 1 ? "floating" : "normal" : "hidden" : "normal"
  );
}, Jv = $.forwardRef(({ hideWhenRunning: e, autohide: t, autohideFloat: n, ...i }, r) => {
  const s = ZL({
    hideWhenRunning: e,
    autohide: t,
    autohideFloat: n
  });
  return s === Mg.Hidden ? null : /* @__PURE__ */ C.jsx(
    Ft.div,
    {
      ...s === Mg.Floating ? { "data-floating": "true" } : null,
      ...i,
      ref: r
    }
  );
});
Jv.displayName = "ActionBarPrimitive.Root";
function hn(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(r) {
    if (e?.(r), n === !1 || !r.defaultPrevented)
      return t?.(r);
  };
}
var VL = ({
  copiedDuration: e = 3e3
} = {}) => {
  const t = Ar(), n = ku(), i = j$((l) => l.setIsCopied), r = qn((l) => (l.role !== "assistant" || l.status.type !== "running") && l.content.some((c) => c.type === "text" && c.text.length > 0)), s = $.useCallback(() => {
    const { isEditing: l, text: c } = n.getState(), f = l ? c : t.unstable_getCopyText();
    navigator.clipboard.writeText(f).then(() => {
      i(!0), setTimeout(() => i(!1), e);
    });
  }, [t, i, n, e]);
  return r ? s : null;
}, Y$ = $.forwardRef(({ copiedDuration: e, onClick: t, disabled: n, ...i }, r) => {
  const s = j$((c) => c.isCopied), l = VL({ copiedDuration: e });
  return /* @__PURE__ */ C.jsx(
    Ft.button,
    {
      type: "button",
      ...s ? { "data-copied": "true" } : {},
      ...i,
      ref: r,
      disabled: n || !l,
      onClick: hn(t, () => {
        l?.();
      })
    }
  );
});
Y$.displayName = "ActionBarPrimitive.Copy";
var ua = (e, t, n = []) => {
  const i = $.forwardRef((r, s) => {
    const l = {}, c = {};
    Object.keys(r).forEach((h) => {
      n.includes(h) ? l[h] = r[h] : c[h] = r[h];
    });
    const f = t(l) ?? void 0;
    return /* @__PURE__ */ C.jsx(
      Ft.button,
      {
        type: "button",
        ...c,
        ref: s,
        disabled: c.disabled || !f,
        onClick: hn(c.onClick, f)
      }
    );
  });
  return i.displayName = e, i;
}, FL = () => {
  const e = Ar(), t = _i(), n = Cf(
    [t, e],
    (r, s) => r.isRunning || r.isDisabled || s.role !== "assistant"
  ), i = $.useCallback(() => {
    e.reload();
  }, [e]);
  return n ? null : i;
}, HL = ua(
  "ActionBarPrimitive.Reload",
  FL
), qL = () => {
  const e = Ar(), t = D$((i) => i.isEditing), n = $.useCallback(() => {
    e.composer.beginEdit();
  }, [e]);
  return t ? null : n;
}, GL = ua(
  "ActionBarPrimitive.Edit",
  qL
);
function J$(e, t = globalThis?.document) {
  const n = Gr(e);
  $.useEffect(() => {
    const i = (r) => {
      r.key === "Escape" && n(r);
    };
    return t.addEventListener("keydown", i, { capture: !0 }), () => t.removeEventListener("keydown", i, { capture: !0 });
  }, [n, t]);
}
function X$(e, t = []) {
  let n = [];
  function i(s, l) {
    const c = $.createContext(l), f = n.length;
    n = [...n, l];
    const h = (m) => {
      const { scope: y, children: b, ...x } = m, w = y?.[e]?.[f] || c, k = $.useMemo(() => x, Object.values(x));
      return /* @__PURE__ */ C.jsx(w.Provider, { value: k, children: b });
    };
    h.displayName = s + "Provider";
    function p(m, y) {
      const b = y?.[e]?.[f] || c, x = $.useContext(b);
      if (x) return x;
      if (l !== void 0) return l;
      throw new Error(`\`${m}\` must be used within \`${s}\``);
    }
    return [h, p];
  }
  const r = () => {
    const s = n.map((l) => $.createContext(l));
    return function(c) {
      const f = c?.[e] || s;
      return $.useMemo(
        () => ({ [`__scope${e}`]: { ...c, [e]: f } }),
        [c, f]
      );
    };
  };
  return r.scopeName = e, [i, YL(r, ...t)];
}
function YL(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const i = e.map((r) => ({
      useScope: r(),
      scopeName: r.scopeName
    }));
    return function(s) {
      const l = i.reduce((c, { useScope: f, scopeName: h }) => {
        const m = f(s)[`__scope${h}`];
        return { ...c, ...m };
      }, {});
      return $.useMemo(() => ({ [`__scope${t.scopeName}`]: l }), [l]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var JL = "DismissableLayer", Dg = "dismissableLayer.update", XL = "dismissableLayer.pointerDownOutside", KL = "dismissableLayer.focusOutside", A1, K$ = $.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), W$ = $.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: i,
      onPointerDownOutside: r,
      onFocusOutside: s,
      onInteractOutside: l,
      onDismiss: c,
      ...f
    } = e, h = $.useContext(K$), [p, m] = $.useState(null), y = p?.ownerDocument ?? globalThis?.document, [, b] = $.useState({}), x = zr(t, (U) => m(U)), w = Array.from(h.layers), [k] = [...h.layersWithOutsidePointerEventsDisabled].slice(-1), T = w.indexOf(k), A = p ? w.indexOf(p) : -1, z = h.layersWithOutsidePointerEventsDisabled.size > 0, O = A >= T, M = eB((U) => {
      const Z = U.target, re = [...h.branches].some((D) => D.contains(Z));
      !O || re || (r?.(U), l?.(U), U.defaultPrevented || c?.());
    }, y), N = tB((U) => {
      const Z = U.target;
      [...h.branches].some((D) => D.contains(Z)) || (s?.(U), l?.(U), U.defaultPrevented || c?.());
    }, y);
    return J$((U) => {
      A === h.layers.size - 1 && (i?.(U), !U.defaultPrevented && c && (U.preventDefault(), c()));
    }, y), $.useEffect(() => {
      if (p)
        return n && (h.layersWithOutsidePointerEventsDisabled.size === 0 && (A1 = y.body.style.pointerEvents, y.body.style.pointerEvents = "none"), h.layersWithOutsidePointerEventsDisabled.add(p)), h.layers.add(p), z1(), () => {
          n && h.layersWithOutsidePointerEventsDisabled.size === 1 && (y.body.style.pointerEvents = A1);
        };
    }, [p, y, n, h]), $.useEffect(() => () => {
      p && (h.layers.delete(p), h.layersWithOutsidePointerEventsDisabled.delete(p), z1());
    }, [p, h]), $.useEffect(() => {
      const U = () => b({});
      return document.addEventListener(Dg, U), () => document.removeEventListener(Dg, U);
    }, []), /* @__PURE__ */ C.jsx(
      Ft.div,
      {
        ...f,
        ref: x,
        style: {
          pointerEvents: z ? O ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: hn(e.onFocusCapture, N.onFocusCapture),
        onBlurCapture: hn(e.onBlurCapture, N.onBlurCapture),
        onPointerDownCapture: hn(
          e.onPointerDownCapture,
          M.onPointerDownCapture
        )
      }
    );
  }
);
W$.displayName = JL;
var WL = "DismissableLayerBranch", QL = $.forwardRef((e, t) => {
  const n = $.useContext(K$), i = $.useRef(null), r = zr(t, i);
  return $.useEffect(() => {
    const s = i.current;
    if (s)
      return n.branches.add(s), () => {
        n.branches.delete(s);
      };
  }, [n.branches]), /* @__PURE__ */ C.jsx(Ft.div, { ...e, ref: r });
});
QL.displayName = WL;
function eB(e, t = globalThis?.document) {
  const n = Gr(e), i = $.useRef(!1), r = $.useRef(() => {
  });
  return $.useEffect(() => {
    const s = (c) => {
      if (c.target && !i.current) {
        let f = function() {
          Q$(
            XL,
            n,
            h,
            { discrete: !0 }
          );
        };
        const h = { originalEvent: c };
        c.pointerType === "touch" ? (t.removeEventListener("click", r.current), r.current = f, t.addEventListener("click", r.current, { once: !0 })) : f();
      } else
        t.removeEventListener("click", r.current);
      i.current = !1;
    }, l = window.setTimeout(() => {
      t.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(l), t.removeEventListener("pointerdown", s), t.removeEventListener("click", r.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => i.current = !0
  };
}
function tB(e, t = globalThis?.document) {
  const n = Gr(e), i = $.useRef(!1);
  return $.useEffect(() => {
    const r = (s) => {
      s.target && !i.current && Q$(KL, n, { originalEvent: s }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", r), () => t.removeEventListener("focusin", r);
  }, [t, n]), {
    onFocusCapture: () => i.current = !0,
    onBlurCapture: () => i.current = !1
  };
}
function z1() {
  const e = new CustomEvent(Dg);
  document.dispatchEvent(e);
}
function Q$(e, t, n, { discrete: i }) {
  const r = n.originalEvent.target, s = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && r.addEventListener(e, t, { once: !0 }), i ? LL(r, s) : r.dispatchEvent(s);
}
var Qi = globalThis?.document ? $.useLayoutEffect : () => {
}, nB = QE[" useId ".trim().toString()] || (() => {
}), rB = 0;
function iB(e) {
  const [t, n] = $.useState(nB());
  return Qi(() => {
    n((i) => i ?? String(rB++));
  }, [e]), t ? `radix-${t}` : "";
}
const aB = ["top", "right", "bottom", "left"], ea = Math.min, Bn = Math.max, Gd = Math.round, gd = Math.floor, Zr = (e) => ({
  x: e,
  y: e
}), sB = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oB = {
  start: "end",
  end: "start"
};
function jg(e, t, n) {
  return Bn(e, ea(t, n));
}
function vi(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function yi(e) {
  return e.split("-")[0];
}
function _o(e) {
  return e.split("-")[1];
}
function Xv(e) {
  return e === "x" ? "y" : "x";
}
function Kv(e) {
  return e === "y" ? "height" : "width";
}
const lB = /* @__PURE__ */ new Set(["top", "bottom"]);
function Br(e) {
  return lB.has(yi(e)) ? "y" : "x";
}
function Wv(e) {
  return Xv(Br(e));
}
function uB(e, t, n) {
  n === void 0 && (n = !1);
  const i = _o(e), r = Wv(e), s = Kv(r);
  let l = r === "x" ? i === (n ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (l = Yd(l)), [l, Yd(l)];
}
function cB(e) {
  const t = Yd(e);
  return [Pg(e), t, Pg(t)];
}
function Pg(e) {
  return e.replace(/start|end/g, (t) => oB[t]);
}
const I1 = ["left", "right"], C1 = ["right", "left"], dB = ["top", "bottom"], fB = ["bottom", "top"];
function hB(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? C1 : I1 : t ? I1 : C1;
    case "left":
    case "right":
      return t ? dB : fB;
    default:
      return [];
  }
}
function pB(e, t, n, i) {
  const r = _o(e);
  let s = hB(yi(e), n === "start", i);
  return r && (s = s.map((l) => l + "-" + r), t && (s = s.concat(s.map(Pg)))), s;
}
function Yd(e) {
  return e.replace(/left|right|bottom|top/g, (t) => sB[t]);
}
function mB(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function eA(e) {
  return typeof e != "number" ? mB(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Jd(e) {
  const {
    x: t,
    y: n,
    width: i,
    height: r
  } = e;
  return {
    width: i,
    height: r,
    top: n,
    left: t,
    right: t + i,
    bottom: n + r,
    x: t,
    y: n
  };
}
function O1(e, t, n) {
  let {
    reference: i,
    floating: r
  } = e;
  const s = Br(t), l = Wv(t), c = Kv(l), f = yi(t), h = s === "y", p = i.x + i.width / 2 - r.width / 2, m = i.y + i.height / 2 - r.height / 2, y = i[c] / 2 - r[c] / 2;
  let b;
  switch (f) {
    case "top":
      b = {
        x: p,
        y: i.y - r.height
      };
      break;
    case "bottom":
      b = {
        x: p,
        y: i.y + i.height
      };
      break;
    case "right":
      b = {
        x: i.x + i.width,
        y: m
      };
      break;
    case "left":
      b = {
        x: i.x - r.width,
        y: m
      };
      break;
    default:
      b = {
        x: i.x,
        y: i.y
      };
  }
  switch (_o(t)) {
    case "start":
      b[l] -= y * (n && h ? -1 : 1);
      break;
    case "end":
      b[l] += y * (n && h ? -1 : 1);
      break;
  }
  return b;
}
const gB = async (e, t, n) => {
  const {
    placement: i = "bottom",
    strategy: r = "absolute",
    middleware: s = [],
    platform: l
  } = n, c = s.filter(Boolean), f = await (l.isRTL == null ? void 0 : l.isRTL(t));
  let h = await l.getElementRects({
    reference: e,
    floating: t,
    strategy: r
  }), {
    x: p,
    y: m
  } = O1(h, i, f), y = i, b = {}, x = 0;
  for (let w = 0; w < c.length; w++) {
    const {
      name: k,
      fn: T
    } = c[w], {
      x: A,
      y: z,
      data: O,
      reset: M
    } = await T({
      x: p,
      y: m,
      initialPlacement: i,
      placement: y,
      strategy: r,
      middlewareData: b,
      rects: h,
      platform: l,
      elements: {
        reference: e,
        floating: t
      }
    });
    p = A ?? p, m = z ?? m, b = {
      ...b,
      [k]: {
        ...b[k],
        ...O
      }
    }, M && x <= 50 && (x++, typeof M == "object" && (M.placement && (y = M.placement), M.rects && (h = M.rects === !0 ? await l.getElementRects({
      reference: e,
      floating: t,
      strategy: r
    }) : M.rects), {
      x: p,
      y: m
    } = O1(h, y, f)), w = -1);
  }
  return {
    x: p,
    y: m,
    placement: y,
    strategy: r,
    middlewareData: b
  };
};
async function tu(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: i,
    y: r,
    platform: s,
    rects: l,
    elements: c,
    strategy: f
  } = e, {
    boundary: h = "clippingAncestors",
    rootBoundary: p = "viewport",
    elementContext: m = "floating",
    altBoundary: y = !1,
    padding: b = 0
  } = vi(t, e), x = eA(b), k = c[y ? m === "floating" ? "reference" : "floating" : m], T = Jd(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(k))) == null || n ? k : k.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(c.floating)),
    boundary: h,
    rootBoundary: p,
    strategy: f
  })), A = m === "floating" ? {
    x: i,
    y: r,
    width: l.floating.width,
    height: l.floating.height
  } : l.reference, z = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c.floating)), O = await (s.isElement == null ? void 0 : s.isElement(z)) ? await (s.getScale == null ? void 0 : s.getScale(z)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, M = Jd(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: A,
    offsetParent: z,
    strategy: f
  }) : A);
  return {
    top: (T.top - M.top + x.top) / O.y,
    bottom: (M.bottom - T.bottom + x.bottom) / O.y,
    left: (T.left - M.left + x.left) / O.x,
    right: (M.right - T.right + x.right) / O.x
  };
}
const vB = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: i,
      placement: r,
      rects: s,
      platform: l,
      elements: c,
      middlewareData: f
    } = t, {
      element: h,
      padding: p = 0
    } = vi(e, t) || {};
    if (h == null)
      return {};
    const m = eA(p), y = {
      x: n,
      y: i
    }, b = Wv(r), x = Kv(b), w = await l.getDimensions(h), k = b === "y", T = k ? "top" : "left", A = k ? "bottom" : "right", z = k ? "clientHeight" : "clientWidth", O = s.reference[x] + s.reference[b] - y[b] - s.floating[x], M = y[b] - s.reference[b], N = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(h));
    let U = N ? N[z] : 0;
    (!U || !await (l.isElement == null ? void 0 : l.isElement(N))) && (U = c.floating[z] || s.floating[x]);
    const Z = O / 2 - M / 2, re = U / 2 - w[x] / 2 - 1, D = ea(m[T], re), ae = ea(m[A], re), ie = D, le = U - w[x] - ae, se = U / 2 - w[x] / 2 + Z, ce = jg(ie, se, le), L = !f.arrow && _o(r) != null && se !== ce && s.reference[x] / 2 - (se < ie ? D : ae) - w[x] / 2 < 0, Y = L ? se < ie ? se - ie : se - le : 0;
    return {
      [b]: y[b] + Y,
      data: {
        [b]: ce,
        centerOffset: se - ce - Y,
        ...L && {
          alignmentOffset: Y
        }
      },
      reset: L
    };
  }
}), yB = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, i;
      const {
        placement: r,
        middlewareData: s,
        rects: l,
        initialPlacement: c,
        platform: f,
        elements: h
      } = t, {
        mainAxis: p = !0,
        crossAxis: m = !0,
        fallbackPlacements: y,
        fallbackStrategy: b = "bestFit",
        fallbackAxisSideDirection: x = "none",
        flipAlignment: w = !0,
        ...k
      } = vi(e, t);
      if ((n = s.arrow) != null && n.alignmentOffset)
        return {};
      const T = yi(r), A = Br(c), z = yi(c) === c, O = await (f.isRTL == null ? void 0 : f.isRTL(h.floating)), M = y || (z || !w ? [Yd(c)] : cB(c)), N = x !== "none";
      !y && N && M.push(...pB(c, w, x, O));
      const U = [c, ...M], Z = await tu(t, k), re = [];
      let D = ((i = s.flip) == null ? void 0 : i.overflows) || [];
      if (p && re.push(Z[T]), m) {
        const se = uB(r, l, O);
        re.push(Z[se[0]], Z[se[1]]);
      }
      if (D = [...D, {
        placement: r,
        overflows: re
      }], !re.every((se) => se <= 0)) {
        var ae, ie;
        const se = (((ae = s.flip) == null ? void 0 : ae.index) || 0) + 1, ce = U[se];
        if (ce && (!(m === "alignment" ? A !== Br(ce) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        D.every((H) => Br(H.placement) === A ? H.overflows[0] > 0 : !0)))
          return {
            data: {
              index: se,
              overflows: D
            },
            reset: {
              placement: ce
            }
          };
        let L = (ie = D.filter((Y) => Y.overflows[0] <= 0).sort((Y, H) => Y.overflows[1] - H.overflows[1])[0]) == null ? void 0 : ie.placement;
        if (!L)
          switch (b) {
            case "bestFit": {
              var le;
              const Y = (le = D.filter((H) => {
                if (N) {
                  const ge = Br(H.placement);
                  return ge === A || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ge === "y";
                }
                return !0;
              }).map((H) => [H.placement, H.overflows.filter((ge) => ge > 0).reduce((ge, S) => ge + S, 0)]).sort((H, ge) => H[1] - ge[1])[0]) == null ? void 0 : le[0];
              Y && (L = Y);
              break;
            }
            case "initialPlacement":
              L = c;
              break;
          }
        if (r !== L)
          return {
            reset: {
              placement: L
            }
          };
      }
      return {};
    }
  };
};
function R1(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function N1(e) {
  return aB.some((t) => e[t] >= 0);
}
const bB = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: i = "referenceHidden",
        ...r
      } = vi(e, t);
      switch (i) {
        case "referenceHidden": {
          const s = await tu(t, {
            ...r,
            elementContext: "reference"
          }), l = R1(s, n.reference);
          return {
            data: {
              referenceHiddenOffsets: l,
              referenceHidden: N1(l)
            }
          };
        }
        case "escaped": {
          const s = await tu(t, {
            ...r,
            altBoundary: !0
          }), l = R1(s, n.floating);
          return {
            data: {
              escapedOffsets: l,
              escaped: N1(l)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, tA = /* @__PURE__ */ new Set(["left", "top"]);
async function xB(e, t) {
  const {
    placement: n,
    platform: i,
    elements: r
  } = e, s = await (i.isRTL == null ? void 0 : i.isRTL(r.floating)), l = yi(n), c = _o(n), f = Br(n) === "y", h = tA.has(l) ? -1 : 1, p = s && f ? -1 : 1, m = vi(t, e);
  let {
    mainAxis: y,
    crossAxis: b,
    alignmentAxis: x
  } = typeof m == "number" ? {
    mainAxis: m,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: m.mainAxis || 0,
    crossAxis: m.crossAxis || 0,
    alignmentAxis: m.alignmentAxis
  };
  return c && typeof x == "number" && (b = c === "end" ? x * -1 : x), f ? {
    x: b * p,
    y: y * h
  } : {
    x: y * h,
    y: b * p
  };
}
const wB = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, i;
      const {
        x: r,
        y: s,
        placement: l,
        middlewareData: c
      } = t, f = await xB(t, e);
      return l === ((n = c.offset) == null ? void 0 : n.placement) && (i = c.arrow) != null && i.alignmentOffset ? {} : {
        x: r + f.x,
        y: s + f.y,
        data: {
          ...f,
          placement: l
        }
      };
    }
  };
}, _B = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: i,
        placement: r
      } = t, {
        mainAxis: s = !0,
        crossAxis: l = !1,
        limiter: c = {
          fn: (k) => {
            let {
              x: T,
              y: A
            } = k;
            return {
              x: T,
              y: A
            };
          }
        },
        ...f
      } = vi(e, t), h = {
        x: n,
        y: i
      }, p = await tu(t, f), m = Br(yi(r)), y = Xv(m);
      let b = h[y], x = h[m];
      if (s) {
        const k = y === "y" ? "top" : "left", T = y === "y" ? "bottom" : "right", A = b + p[k], z = b - p[T];
        b = jg(A, b, z);
      }
      if (l) {
        const k = m === "y" ? "top" : "left", T = m === "y" ? "bottom" : "right", A = x + p[k], z = x - p[T];
        x = jg(A, x, z);
      }
      const w = c.fn({
        ...t,
        [y]: b,
        [m]: x
      });
      return {
        ...w,
        data: {
          x: w.x - n,
          y: w.y - i,
          enabled: {
            [y]: s,
            [m]: l
          }
        }
      };
    }
  };
}, SB = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: i,
        placement: r,
        rects: s,
        middlewareData: l
      } = t, {
        offset: c = 0,
        mainAxis: f = !0,
        crossAxis: h = !0
      } = vi(e, t), p = {
        x: n,
        y: i
      }, m = Br(r), y = Xv(m);
      let b = p[y], x = p[m];
      const w = vi(c, t), k = typeof w == "number" ? {
        mainAxis: w,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...w
      };
      if (f) {
        const z = y === "y" ? "height" : "width", O = s.reference[y] - s.floating[z] + k.mainAxis, M = s.reference[y] + s.reference[z] - k.mainAxis;
        b < O ? b = O : b > M && (b = M);
      }
      if (h) {
        var T, A;
        const z = y === "y" ? "width" : "height", O = tA.has(yi(r)), M = s.reference[m] - s.floating[z] + (O && ((T = l.offset) == null ? void 0 : T[m]) || 0) + (O ? 0 : k.crossAxis), N = s.reference[m] + s.reference[z] + (O ? 0 : ((A = l.offset) == null ? void 0 : A[m]) || 0) - (O ? k.crossAxis : 0);
        x < M ? x = M : x > N && (x = N);
      }
      return {
        [y]: b,
        [m]: x
      };
    }
  };
}, kB = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, i;
      const {
        placement: r,
        rects: s,
        platform: l,
        elements: c
      } = t, {
        apply: f = () => {
        },
        ...h
      } = vi(e, t), p = await tu(t, h), m = yi(r), y = _o(r), b = Br(r) === "y", {
        width: x,
        height: w
      } = s.floating;
      let k, T;
      m === "top" || m === "bottom" ? (k = m, T = y === (await (l.isRTL == null ? void 0 : l.isRTL(c.floating)) ? "start" : "end") ? "left" : "right") : (T = m, k = y === "end" ? "top" : "bottom");
      const A = w - p.top - p.bottom, z = x - p.left - p.right, O = ea(w - p[k], A), M = ea(x - p[T], z), N = !t.middlewareData.shift;
      let U = O, Z = M;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (Z = z), (i = t.middlewareData.shift) != null && i.enabled.y && (U = A), N && !y) {
        const D = Bn(p.left, 0), ae = Bn(p.right, 0), ie = Bn(p.top, 0), le = Bn(p.bottom, 0);
        b ? Z = x - 2 * (D !== 0 || ae !== 0 ? D + ae : Bn(p.left, p.right)) : U = w - 2 * (ie !== 0 || le !== 0 ? ie + le : Bn(p.top, p.bottom));
      }
      await f({
        ...t,
        availableWidth: Z,
        availableHeight: U
      });
      const re = await l.getDimensions(c.floating);
      return x !== re.width || w !== re.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Of() {
  return typeof window < "u";
}
function So(e) {
  return nA(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Fn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Jr(e) {
  var t;
  return (t = (nA(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function nA(e) {
  return Of() ? e instanceof Node || e instanceof Fn(e).Node : !1;
}
function Tr(e) {
  return Of() ? e instanceof Element || e instanceof Fn(e).Element : !1;
}
function Yr(e) {
  return Of() ? e instanceof HTMLElement || e instanceof Fn(e).HTMLElement : !1;
}
function M1(e) {
  return !Of() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Fn(e).ShadowRoot;
}
const TB = /* @__PURE__ */ new Set(["inline", "contents"]);
function Tu(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: i,
    display: r
  } = Er(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + n) && !TB.has(r);
}
const EB = /* @__PURE__ */ new Set(["table", "td", "th"]);
function $B(e) {
  return EB.has(So(e));
}
const AB = [":popover-open", ":modal"];
function Rf(e) {
  return AB.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const zB = ["transform", "translate", "scale", "rotate", "perspective"], IB = ["transform", "translate", "scale", "rotate", "perspective", "filter"], CB = ["paint", "layout", "strict", "content"];
function Qv(e) {
  const t = ey(), n = Tr(e) ? Er(e) : e;
  return zB.some((i) => n[i] ? n[i] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || IB.some((i) => (n.willChange || "").includes(i)) || CB.some((i) => (n.contain || "").includes(i));
}
function OB(e) {
  let t = ta(e);
  for (; Yr(t) && !lo(t); ) {
    if (Qv(t))
      return t;
    if (Rf(t))
      return null;
    t = ta(t);
  }
  return null;
}
function ey() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const RB = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function lo(e) {
  return RB.has(So(e));
}
function Er(e) {
  return Fn(e).getComputedStyle(e);
}
function Nf(e) {
  return Tr(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function ta(e) {
  if (So(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    M1(e) && e.host || // Fallback.
    Jr(e)
  );
  return M1(t) ? t.host : t;
}
function rA(e) {
  const t = ta(e);
  return lo(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Yr(t) && Tu(t) ? t : rA(t);
}
function nu(e, t, n) {
  var i;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const r = rA(e), s = r === ((i = e.ownerDocument) == null ? void 0 : i.body), l = Fn(r);
  if (s) {
    const c = Ug(l);
    return t.concat(l, l.visualViewport || [], Tu(r) ? r : [], c && n ? nu(c) : []);
  }
  return t.concat(r, nu(r, [], n));
}
function Ug(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function iA(e) {
  const t = Er(e);
  let n = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  const r = Yr(e), s = r ? e.offsetWidth : n, l = r ? e.offsetHeight : i, c = Gd(n) !== s || Gd(i) !== l;
  return c && (n = s, i = l), {
    width: n,
    height: i,
    $: c
  };
}
function ty(e) {
  return Tr(e) ? e : e.contextElement;
}
function io(e) {
  const t = ty(e);
  if (!Yr(t))
    return Zr(1);
  const n = t.getBoundingClientRect(), {
    width: i,
    height: r,
    $: s
  } = iA(t);
  let l = (s ? Gd(n.width) : n.width) / i, c = (s ? Gd(n.height) : n.height) / r;
  return (!l || !Number.isFinite(l)) && (l = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: l,
    y: c
  };
}
const NB = /* @__PURE__ */ Zr(0);
function aA(e) {
  const t = Fn(e);
  return !ey() || !t.visualViewport ? NB : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function MB(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Fn(e) ? !1 : t;
}
function qa(e, t, n, i) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), s = ty(e);
  let l = Zr(1);
  t && (i ? Tr(i) && (l = io(i)) : l = io(e));
  const c = MB(s, n, i) ? aA(s) : Zr(0);
  let f = (r.left + c.x) / l.x, h = (r.top + c.y) / l.y, p = r.width / l.x, m = r.height / l.y;
  if (s) {
    const y = Fn(s), b = i && Tr(i) ? Fn(i) : i;
    let x = y, w = Ug(x);
    for (; w && i && b !== x; ) {
      const k = io(w), T = w.getBoundingClientRect(), A = Er(w), z = T.left + (w.clientLeft + parseFloat(A.paddingLeft)) * k.x, O = T.top + (w.clientTop + parseFloat(A.paddingTop)) * k.y;
      f *= k.x, h *= k.y, p *= k.x, m *= k.y, f += z, h += O, x = Fn(w), w = Ug(x);
    }
  }
  return Jd({
    width: p,
    height: m,
    x: f,
    y: h
  });
}
function Mf(e, t) {
  const n = Nf(e).scrollLeft;
  return t ? t.left + n : qa(Jr(e)).left + n;
}
function sA(e, t) {
  const n = e.getBoundingClientRect(), i = n.left + t.scrollLeft - Mf(e, n), r = n.top + t.scrollTop;
  return {
    x: i,
    y: r
  };
}
function DB(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: i,
    strategy: r
  } = e;
  const s = r === "fixed", l = Jr(i), c = t ? Rf(t.floating) : !1;
  if (i === l || c && s)
    return n;
  let f = {
    scrollLeft: 0,
    scrollTop: 0
  }, h = Zr(1);
  const p = Zr(0), m = Yr(i);
  if ((m || !m && !s) && ((So(i) !== "body" || Tu(l)) && (f = Nf(i)), Yr(i))) {
    const b = qa(i);
    h = io(i), p.x = b.x + i.clientLeft, p.y = b.y + i.clientTop;
  }
  const y = l && !m && !s ? sA(l, f) : Zr(0);
  return {
    width: n.width * h.x,
    height: n.height * h.y,
    x: n.x * h.x - f.scrollLeft * h.x + p.x + y.x,
    y: n.y * h.y - f.scrollTop * h.y + p.y + y.y
  };
}
function jB(e) {
  return Array.from(e.getClientRects());
}
function PB(e) {
  const t = Jr(e), n = Nf(e), i = e.ownerDocument.body, r = Bn(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), s = Bn(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight);
  let l = -n.scrollLeft + Mf(e);
  const c = -n.scrollTop;
  return Er(i).direction === "rtl" && (l += Bn(t.clientWidth, i.clientWidth) - r), {
    width: r,
    height: s,
    x: l,
    y: c
  };
}
const D1 = 25;
function UB(e, t) {
  const n = Fn(e), i = Jr(e), r = n.visualViewport;
  let s = i.clientWidth, l = i.clientHeight, c = 0, f = 0;
  if (r) {
    s = r.width, l = r.height;
    const p = ey();
    (!p || p && t === "fixed") && (c = r.offsetLeft, f = r.offsetTop);
  }
  const h = Mf(i);
  if (h <= 0) {
    const p = i.ownerDocument, m = p.body, y = getComputedStyle(m), b = p.compatMode === "CSS1Compat" && parseFloat(y.marginLeft) + parseFloat(y.marginRight) || 0, x = Math.abs(i.clientWidth - m.clientWidth - b);
    x <= D1 && (s -= x);
  } else h <= D1 && (s += h);
  return {
    width: s,
    height: l,
    x: c,
    y: f
  };
}
const LB = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function BB(e, t) {
  const n = qa(e, !0, t === "fixed"), i = n.top + e.clientTop, r = n.left + e.clientLeft, s = Yr(e) ? io(e) : Zr(1), l = e.clientWidth * s.x, c = e.clientHeight * s.y, f = r * s.x, h = i * s.y;
  return {
    width: l,
    height: c,
    x: f,
    y: h
  };
}
function j1(e, t, n) {
  let i;
  if (t === "viewport")
    i = UB(e, n);
  else if (t === "document")
    i = PB(Jr(e));
  else if (Tr(t))
    i = BB(t, n);
  else {
    const r = aA(e);
    i = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height
    };
  }
  return Jd(i);
}
function oA(e, t) {
  const n = ta(e);
  return n === t || !Tr(n) || lo(n) ? !1 : Er(n).position === "fixed" || oA(n, t);
}
function ZB(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let i = nu(e, [], !1).filter((c) => Tr(c) && So(c) !== "body"), r = null;
  const s = Er(e).position === "fixed";
  let l = s ? ta(e) : e;
  for (; Tr(l) && !lo(l); ) {
    const c = Er(l), f = Qv(l);
    !f && c.position === "fixed" && (r = null), (s ? !f && !r : !f && c.position === "static" && !!r && LB.has(r.position) || Tu(l) && !f && oA(e, l)) ? i = i.filter((p) => p !== l) : r = c, l = ta(l);
  }
  return t.set(e, i), i;
}
function VB(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: i,
    strategy: r
  } = e;
  const l = [...n === "clippingAncestors" ? Rf(t) ? [] : ZB(t, this._c) : [].concat(n), i], c = l[0], f = l.reduce((h, p) => {
    const m = j1(t, p, r);
    return h.top = Bn(m.top, h.top), h.right = ea(m.right, h.right), h.bottom = ea(m.bottom, h.bottom), h.left = Bn(m.left, h.left), h;
  }, j1(t, c, r));
  return {
    width: f.right - f.left,
    height: f.bottom - f.top,
    x: f.left,
    y: f.top
  };
}
function FB(e) {
  const {
    width: t,
    height: n
  } = iA(e);
  return {
    width: t,
    height: n
  };
}
function HB(e, t, n) {
  const i = Yr(t), r = Jr(t), s = n === "fixed", l = qa(e, !0, s, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const f = Zr(0);
  function h() {
    f.x = Mf(r);
  }
  if (i || !i && !s)
    if ((So(t) !== "body" || Tu(r)) && (c = Nf(t)), i) {
      const b = qa(t, !0, s, t);
      f.x = b.x + t.clientLeft, f.y = b.y + t.clientTop;
    } else r && h();
  s && !i && r && h();
  const p = r && !i && !s ? sA(r, c) : Zr(0), m = l.left + c.scrollLeft - f.x - p.x, y = l.top + c.scrollTop - f.y - p.y;
  return {
    x: m,
    y,
    width: l.width,
    height: l.height
  };
}
function Um(e) {
  return Er(e).position === "static";
}
function P1(e, t) {
  if (!Yr(e) || Er(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Jr(e) === n && (n = n.ownerDocument.body), n;
}
function lA(e, t) {
  const n = Fn(e);
  if (Rf(e))
    return n;
  if (!Yr(e)) {
    let r = ta(e);
    for (; r && !lo(r); ) {
      if (Tr(r) && !Um(r))
        return r;
      r = ta(r);
    }
    return n;
  }
  let i = P1(e, t);
  for (; i && $B(i) && Um(i); )
    i = P1(i, t);
  return i && lo(i) && Um(i) && !Qv(i) ? n : i || OB(e) || n;
}
const qB = async function(e) {
  const t = this.getOffsetParent || lA, n = this.getDimensions, i = await n(e.floating);
  return {
    reference: HB(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
};
function GB(e) {
  return Er(e).direction === "rtl";
}
const YB = {
  convertOffsetParentRelativeRectToViewportRelativeRect: DB,
  getDocumentElement: Jr,
  getClippingRect: VB,
  getOffsetParent: lA,
  getElementRects: qB,
  getClientRects: jB,
  getDimensions: FB,
  getScale: io,
  isElement: Tr,
  isRTL: GB
};
function uA(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function JB(e, t) {
  let n = null, i;
  const r = Jr(e);
  function s() {
    var c;
    clearTimeout(i), (c = n) == null || c.disconnect(), n = null;
  }
  function l(c, f) {
    c === void 0 && (c = !1), f === void 0 && (f = 1), s();
    const h = e.getBoundingClientRect(), {
      left: p,
      top: m,
      width: y,
      height: b
    } = h;
    if (c || t(), !y || !b)
      return;
    const x = gd(m), w = gd(r.clientWidth - (p + y)), k = gd(r.clientHeight - (m + b)), T = gd(p), z = {
      rootMargin: -x + "px " + -w + "px " + -k + "px " + -T + "px",
      threshold: Bn(0, ea(1, f)) || 1
    };
    let O = !0;
    function M(N) {
      const U = N[0].intersectionRatio;
      if (U !== f) {
        if (!O)
          return l();
        U ? l(!1, U) : i = setTimeout(() => {
          l(!1, 1e-7);
        }, 1e3);
      }
      U === 1 && !uA(h, e.getBoundingClientRect()) && l(), O = !1;
    }
    try {
      n = new IntersectionObserver(M, {
        ...z,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(M, z);
    }
    n.observe(e);
  }
  return l(!0), s;
}
function XB(e, t, n, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: s = !0,
    elementResize: l = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: f = !1
  } = i, h = ty(e), p = r || s ? [...h ? nu(h) : [], ...nu(t)] : [];
  p.forEach((T) => {
    r && T.addEventListener("scroll", n, {
      passive: !0
    }), s && T.addEventListener("resize", n);
  });
  const m = h && c ? JB(h, n) : null;
  let y = -1, b = null;
  l && (b = new ResizeObserver((T) => {
    let [A] = T;
    A && A.target === h && b && (b.unobserve(t), cancelAnimationFrame(y), y = requestAnimationFrame(() => {
      var z;
      (z = b) == null || z.observe(t);
    })), n();
  }), h && !f && b.observe(h), b.observe(t));
  let x, w = f ? qa(e) : null;
  f && k();
  function k() {
    const T = qa(e);
    w && !uA(w, T) && n(), w = T, x = requestAnimationFrame(k);
  }
  return n(), () => {
    var T;
    p.forEach((A) => {
      r && A.removeEventListener("scroll", n), s && A.removeEventListener("resize", n);
    }), m?.(), (T = b) == null || T.disconnect(), b = null, f && cancelAnimationFrame(x);
  };
}
const KB = wB, WB = _B, QB = yB, e3 = kB, t3 = bB, U1 = vB, n3 = SB, r3 = (e, t, n) => {
  const i = /* @__PURE__ */ new Map(), r = {
    platform: YB,
    ...n
  }, s = {
    ...r.platform,
    _c: i
  };
  return gB(e, t, {
    ...r,
    platform: s
  });
};
var i3 = typeof document < "u", a3 = function() {
}, Pd = i3 ? $.useLayoutEffect : a3;
function Xd(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, i, r;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (i = n; i-- !== 0; )
        if (!Xd(e[i], t[i]))
          return !1;
      return !0;
    }
    if (r = Object.keys(e), n = r.length, n !== Object.keys(t).length)
      return !1;
    for (i = n; i-- !== 0; )
      if (!{}.hasOwnProperty.call(t, r[i]))
        return !1;
    for (i = n; i-- !== 0; ) {
      const s = r[i];
      if (!(s === "_owner" && e.$$typeof) && !Xd(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function cA(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function L1(e, t) {
  const n = cA(e);
  return Math.round(t * n) / n;
}
function Lm(e) {
  const t = $.useRef(e);
  return Pd(() => {
    t.current = e;
  }), t;
}
function s3(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: i = [],
    platform: r,
    elements: {
      reference: s,
      floating: l
    } = {},
    transform: c = !0,
    whileElementsMounted: f,
    open: h
  } = e, [p, m] = $.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [y, b] = $.useState(i);
  Xd(y, i) || b(i);
  const [x, w] = $.useState(null), [k, T] = $.useState(null), A = $.useCallback((H) => {
    H !== N.current && (N.current = H, w(H));
  }, []), z = $.useCallback((H) => {
    H !== U.current && (U.current = H, T(H));
  }, []), O = s || x, M = l || k, N = $.useRef(null), U = $.useRef(null), Z = $.useRef(p), re = f != null, D = Lm(f), ae = Lm(r), ie = Lm(h), le = $.useCallback(() => {
    if (!N.current || !U.current)
      return;
    const H = {
      placement: t,
      strategy: n,
      middleware: y
    };
    ae.current && (H.platform = ae.current), r3(N.current, U.current, H).then((ge) => {
      const S = {
        ...ge,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: ie.current !== !1
      };
      se.current && !Xd(Z.current, S) && (Z.current = S, Yv.flushSync(() => {
        m(S);
      }));
    });
  }, [y, t, n, ae, ie]);
  Pd(() => {
    h === !1 && Z.current.isPositioned && (Z.current.isPositioned = !1, m((H) => ({
      ...H,
      isPositioned: !1
    })));
  }, [h]);
  const se = $.useRef(!1);
  Pd(() => (se.current = !0, () => {
    se.current = !1;
  }), []), Pd(() => {
    if (O && (N.current = O), M && (U.current = M), O && M) {
      if (D.current)
        return D.current(O, M, le);
      le();
    }
  }, [O, M, le, D, re]);
  const ce = $.useMemo(() => ({
    reference: N,
    floating: U,
    setReference: A,
    setFloating: z
  }), [A, z]), L = $.useMemo(() => ({
    reference: O,
    floating: M
  }), [O, M]), Y = $.useMemo(() => {
    const H = {
      position: n,
      left: 0,
      top: 0
    };
    if (!L.floating)
      return H;
    const ge = L1(L.floating, p.x), S = L1(L.floating, p.y);
    return c ? {
      ...H,
      transform: "translate(" + ge + "px, " + S + "px)",
      ...cA(L.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: ge,
      top: S
    };
  }, [n, c, L.floating, p.x, p.y]);
  return $.useMemo(() => ({
    ...p,
    update: le,
    refs: ce,
    elements: L,
    floatingStyles: Y
  }), [p, le, ce, L, Y]);
}
const o3 = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: i,
        padding: r
      } = typeof e == "function" ? e(n) : e;
      return i && t(i) ? i.current != null ? U1({
        element: i.current,
        padding: r
      }).fn(n) : {} : i ? U1({
        element: i,
        padding: r
      }).fn(n) : {};
    }
  };
}, l3 = (e, t) => ({
  ...KB(e),
  options: [e, t]
}), u3 = (e, t) => ({
  ...WB(e),
  options: [e, t]
}), c3 = (e, t) => ({
  ...n3(e),
  options: [e, t]
}), d3 = (e, t) => ({
  ...QB(e),
  options: [e, t]
}), f3 = (e, t) => ({
  ...e3(e),
  options: [e, t]
}), h3 = (e, t) => ({
  ...t3(e),
  options: [e, t]
}), p3 = (e, t) => ({
  ...o3(e),
  options: [e, t]
});
var m3 = "Arrow", dA = $.forwardRef((e, t) => {
  const { children: n, width: i = 10, height: r = 5, ...s } = e;
  return /* @__PURE__ */ C.jsx(
    Ft.svg,
    {
      ...s,
      ref: t,
      width: i,
      height: r,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ C.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
dA.displayName = m3;
var g3 = dA;
function v3(e) {
  const [t, n] = $.useState(void 0);
  return Qi(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const i = new ResizeObserver((r) => {
        if (!Array.isArray(r) || !r.length)
          return;
        const s = r[0];
        let l, c;
        if ("borderBoxSize" in s) {
          const f = s.borderBoxSize, h = Array.isArray(f) ? f[0] : f;
          l = h.inlineSize, c = h.blockSize;
        } else
          l = e.offsetWidth, c = e.offsetHeight;
        n({ width: l, height: c });
      });
      return i.observe(e, { box: "border-box" }), () => i.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var ny = "Popper", [fA, hA] = X$(ny), [y3, pA] = fA(ny), mA = (e) => {
  const { __scopePopper: t, children: n } = e, [i, r] = $.useState(null);
  return /* @__PURE__ */ C.jsx(y3, { scope: t, anchor: i, onAnchorChange: r, children: n });
};
mA.displayName = ny;
var gA = "PopperAnchor", vA = $.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: i, ...r } = e, s = pA(gA, n), l = $.useRef(null), c = zr(t, l), f = $.useRef(null);
    return $.useEffect(() => {
      const h = f.current;
      f.current = i?.current || l.current, h !== f.current && s.onAnchorChange(f.current);
    }), i ? null : /* @__PURE__ */ C.jsx(Ft.div, { ...r, ref: c });
  }
);
vA.displayName = gA;
var ry = "PopperContent", [b3, x3] = fA(ry), yA = $.forwardRef(
  (e, t) => {
    const {
      __scopePopper: n,
      side: i = "bottom",
      sideOffset: r = 0,
      align: s = "center",
      alignOffset: l = 0,
      arrowPadding: c = 0,
      avoidCollisions: f = !0,
      collisionBoundary: h = [],
      collisionPadding: p = 0,
      sticky: m = "partial",
      hideWhenDetached: y = !1,
      updatePositionStrategy: b = "optimized",
      onPlaced: x,
      ...w
    } = e, k = pA(ry, n), [T, A] = $.useState(null), z = zr(t, (Ce) => A(Ce)), [O, M] = $.useState(null), N = v3(O), U = N?.width ?? 0, Z = N?.height ?? 0, re = i + (s !== "center" ? "-" + s : ""), D = typeof p == "number" ? p : { top: 0, right: 0, bottom: 0, left: 0, ...p }, ae = Array.isArray(h) ? h : [h], ie = ae.length > 0, le = {
      padding: D,
      boundary: ae.filter(_3),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: ie
    }, { refs: se, floatingStyles: ce, placement: L, isPositioned: Y, middlewareData: H } = s3({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: re,
      whileElementsMounted: (...Ce) => XB(...Ce, {
        animationFrame: b === "always"
      }),
      elements: {
        reference: k.anchor
      },
      middleware: [
        l3({ mainAxis: r + Z, alignmentAxis: l }),
        f && u3({
          mainAxis: !0,
          crossAxis: !1,
          limiter: m === "partial" ? c3() : void 0,
          ...le
        }),
        f && d3({ ...le }),
        f3({
          ...le,
          apply: ({ elements: Ce, rects: Pe, availableWidth: kt, availableHeight: Kt }) => {
            const { width: un, height: Jn } = Pe.reference, Cr = Ce.floating.style;
            Cr.setProperty("--radix-popper-available-width", `${kt}px`), Cr.setProperty("--radix-popper-available-height", `${Kt}px`), Cr.setProperty("--radix-popper-anchor-width", `${un}px`), Cr.setProperty("--radix-popper-anchor-height", `${Jn}px`);
          }
        }),
        O && p3({ element: O, padding: c }),
        S3({ arrowWidth: U, arrowHeight: Z }),
        y && h3({ strategy: "referenceHidden", ...le })
      ]
    }), [ge, S] = wA(L), X = Gr(x);
    Qi(() => {
      Y && X?.();
    }, [Y, X]);
    const fe = H.arrow?.x, I = H.arrow?.y, he = H.arrow?.centerOffset !== 0, [Ie, pe] = $.useState();
    return Qi(() => {
      T && pe(window.getComputedStyle(T).zIndex);
    }, [T]), /* @__PURE__ */ C.jsx(
      "div",
      {
        ref: se.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...ce,
          transform: Y ? ce.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: Ie,
          "--radix-popper-transform-origin": [
            H.transformOrigin?.x,
            H.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...H.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ C.jsx(
          b3,
          {
            scope: n,
            placedSide: ge,
            onArrowChange: M,
            arrowX: fe,
            arrowY: I,
            shouldHideArrow: he,
            children: /* @__PURE__ */ C.jsx(
              Ft.div,
              {
                "data-side": ge,
                "data-align": S,
                ...w,
                ref: z,
                style: {
                  ...w.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: Y ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
yA.displayName = ry;
var bA = "PopperArrow", w3 = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, xA = $.forwardRef(function(t, n) {
  const { __scopePopper: i, ...r } = t, s = x3(bA, i), l = w3[s.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ C.jsx(
      "span",
      {
        ref: s.onArrowChange,
        style: {
          position: "absolute",
          left: s.arrowX,
          top: s.arrowY,
          [l]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[s.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[s.placedSide],
          visibility: s.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ C.jsx(
          g3,
          {
            ...r,
            ref: n,
            style: {
              ...r.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
xA.displayName = bA;
function _3(e) {
  return e !== null;
}
var S3 = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    const { placement: n, rects: i, middlewareData: r } = t, l = r.arrow?.centerOffset !== 0, c = l ? 0 : e.arrowWidth, f = l ? 0 : e.arrowHeight, [h, p] = wA(n), m = { start: "0%", center: "50%", end: "100%" }[p], y = (r.arrow?.x ?? 0) + c / 2, b = (r.arrow?.y ?? 0) + f / 2;
    let x = "", w = "";
    return h === "bottom" ? (x = l ? m : `${y}px`, w = `${-f}px`) : h === "top" ? (x = l ? m : `${y}px`, w = `${i.floating.height + f}px`) : h === "right" ? (x = `${-f}px`, w = l ? m : `${b}px`) : h === "left" && (x = `${i.floating.width + f}px`, w = l ? m : `${b}px`), { data: { x, y: w } };
  }
});
function wA(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var k3 = mA, T3 = vA, E3 = yA, $3 = xA, A3 = "Portal", _A = $.forwardRef((e, t) => {
  const { container: n, ...i } = e, [r, s] = $.useState(!1);
  Qi(() => s(!0), []);
  const l = n || r && globalThis?.document?.body;
  return l ? RL.createPortal(/* @__PURE__ */ C.jsx(Ft.div, { ...i, ref: t }), l) : null;
});
_A.displayName = A3;
function z3(e, t) {
  return $.useReducer((n, i) => t[n][i] ?? n, e);
}
var iy = (e) => {
  const { present: t, children: n } = e, i = I3(t), r = typeof n == "function" ? n({ present: i.isPresent }) : $.Children.only(n), s = zr(i.ref, C3(r));
  return typeof n == "function" || i.isPresent ? $.cloneElement(r, { ref: s }) : null;
};
iy.displayName = "Presence";
function I3(e) {
  const [t, n] = $.useState(), i = $.useRef(null), r = $.useRef(e), s = $.useRef("none"), l = e ? "mounted" : "unmounted", [c, f] = z3(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return $.useEffect(() => {
    const h = vd(i.current);
    s.current = c === "mounted" ? h : "none";
  }, [c]), Qi(() => {
    const h = i.current, p = r.current;
    if (p !== e) {
      const y = s.current, b = vd(h);
      e ? f("MOUNT") : b === "none" || h?.display === "none" ? f("UNMOUNT") : f(p && y !== b ? "ANIMATION_OUT" : "UNMOUNT"), r.current = e;
    }
  }, [e, f]), Qi(() => {
    if (t) {
      let h;
      const p = t.ownerDocument.defaultView ?? window, m = (b) => {
        const w = vd(i.current).includes(CSS.escape(b.animationName));
        if (b.target === t && w && (f("ANIMATION_END"), !r.current)) {
          const k = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", h = p.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = k);
          });
        }
      }, y = (b) => {
        b.target === t && (s.current = vd(i.current));
      };
      return t.addEventListener("animationstart", y), t.addEventListener("animationcancel", m), t.addEventListener("animationend", m), () => {
        p.clearTimeout(h), t.removeEventListener("animationstart", y), t.removeEventListener("animationcancel", m), t.removeEventListener("animationend", m);
      };
    } else
      f("ANIMATION_END");
  }, [t, f]), {
    isPresent: ["mounted", "unmountSuspended"].includes(c),
    ref: $.useCallback((h) => {
      i.current = h ? getComputedStyle(h) : null, n(h);
    }, [])
  };
}
function vd(e) {
  return e?.animationName || "none";
}
function C3(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var O3 = QE[" useInsertionEffect ".trim().toString()] || Qi;
function R3({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: i
}) {
  const [r, s, l] = N3({
    defaultProp: t,
    onChange: n
  }), c = e !== void 0, f = c ? e : r;
  {
    const p = $.useRef(e !== void 0);
    $.useEffect(() => {
      const m = p.current;
      m !== c && console.warn(
        `${i} is changing from ${m ? "controlled" : "uncontrolled"} to ${c ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), p.current = c;
    }, [c, i]);
  }
  const h = $.useCallback(
    (p) => {
      if (c) {
        const m = M3(p) ? p(e) : p;
        m !== e && l.current?.(m);
      } else
        s(p);
    },
    [c, e, s, l]
  );
  return [f, h];
}
function N3({
  defaultProp: e,
  onChange: t
}) {
  const [n, i] = $.useState(e), r = $.useRef(n), s = $.useRef(t);
  return O3(() => {
    s.current = t;
  }, [t]), $.useEffect(() => {
    r.current !== n && (s.current?.(n), r.current = n);
  }, [n, r]), [n, i, s];
}
function M3(e) {
  return typeof e == "function";
}
var D3 = () => {
  const e = Ar(), t = qn((i) => i.branchNumber >= i.branchCount), n = $.useCallback(() => {
    e.switchToBranch({ position: "next" });
  }, [e]);
  return t ? null : n;
}, j3 = ua(
  "BranchPickerPrimitive.Next",
  D3
), P3 = () => {
  const e = Ar(), t = qn((i) => i.branchNumber <= 1), n = $.useCallback(() => {
    e.switchToBranch({ position: "previous" });
  }, [e]);
  return t ? null : n;
}, U3 = ua(
  "BranchPickerPrimitive.Previous",
  P3
), L3 = () => qn((t) => t.branchCount), SA = () => {
  const e = L3();
  return /* @__PURE__ */ C.jsx(C.Fragment, { children: e });
};
SA.displayName = "BranchPickerPrimitive.Count";
var B3 = () => qn((t) => t.branchNumber), kA = () => {
  const e = B3();
  return /* @__PURE__ */ C.jsx(C.Fragment, { children: e });
};
kA.displayName = "BranchPickerPrimitive.Number";
var ay = (e) => {
  const t = $.useRef(void 0);
  return $.useCallback(
    (i) => {
      t.current && t.current(), i && (t.current = e(i));
    },
    [e]
  );
}, Z3 = () => {
  const e = qv(), t = $.useCallback(
    (n) => {
      const i = e.getState().setIsHovering, r = () => {
        i(!0);
      }, s = () => {
        i(!1);
      };
      return n.addEventListener("mouseenter", r), n.addEventListener("mouseleave", s), () => {
        n.removeEventListener("mouseenter", r), n.removeEventListener("mouseleave", s), i(!1);
      };
    },
    [e]
  );
  return ay(t);
}, sy = $.forwardRef((e, t) => {
  const n = Z3(), i = zr(t, n);
  return /* @__PURE__ */ C.jsx(Ft.div, { ...e, ref: i });
});
sy.displayName = "MessagePrimitive.Root";
var V3 = (e) => {
  const [t] = $.useState(() => gn(() => e));
  return $.useEffect(() => {
    gi(e), qr(t).setState(e, !0);
  }, [e, t]), t;
}, F3 = ({ runtime: e, children: t }) => {
  const n = V3(e), [i] = $.useState(() => ({ useMessagePartRuntime: n }));
  return /* @__PURE__ */ C.jsx(Fv.Provider, { value: i, children: t });
}, TA = () => Su((t) => {
  if (t.type !== "text" && t.type !== "reasoning")
    throw new Error(
      "MessagePartText can only be used inside text or reasoning message parts."
    );
  return t;
}), EA = $.forwardRef(({ smooth: e = !0, component: t = "span", ...n }, i) => {
  const { text: r, status: s } = Z$(TA(), e);
  return /* @__PURE__ */ C.jsx(t, { "data-status": s.type, ...n, ref: i, children: r });
});
EA.displayName = "MessagePartPrimitive.Text";
var H3 = () => Su((t) => {
  if (t.type !== "image")
    throw new Error(
      "MessagePartImage can only be used inside image message parts."
    );
  return t;
}), $A = $.forwardRef((e, t) => {
  const { image: n } = H3();
  return /* @__PURE__ */ C.jsx(Ft.img, { src: n, ...e, ref: t });
});
$A.displayName = "MessagePartPrimitive.Image";
var AA = ({ children: e }) => Su((n) => n.status.type === "running") ? e : null;
AA.displayName = "MessagePartPrimitive.InProgress";
const B1 = (e) => Symbol.iterator in e, Z1 = (e) => (
  // HACK: avoid checking entries type
  "entries" in e
), V1 = (e, t) => {
  const n = e instanceof Map ? e : new Map(e.entries()), i = t instanceof Map ? t : new Map(t.entries());
  if (n.size !== i.size)
    return !1;
  for (const [r, s] of n)
    if (!i.has(r) || !Object.is(s, i.get(r)))
      return !1;
  return !0;
}, q3 = (e, t) => {
  const n = e[Symbol.iterator](), i = t[Symbol.iterator]();
  let r = n.next(), s = i.next();
  for (; !r.done && !s.done; ) {
    if (!Object.is(r.value, s.value))
      return !1;
    r = n.next(), s = i.next();
  }
  return !!r.done && !!s.done;
};
function G3(e, t) {
  return Object.is(e, t) ? !0 : typeof e != "object" || e === null || typeof t != "object" || t === null || Object.getPrototypeOf(e) !== Object.getPrototypeOf(t) ? !1 : B1(e) && B1(t) ? Z1(e) && Z1(t) ? V1(e, t) : q3(e, t) : V1(
    { entries: () => Object.entries(e) },
    { entries: () => Object.entries(t) }
  );
}
function Y3(e) {
  const t = Lr.useRef(void 0);
  return (n) => {
    const i = e(n);
    return G3(t.current, i) ? t.current : t.current = i;
  };
}
var J3 = (e) => {
  const t = [];
  let n = -1;
  for (let i = 0; i < e.length; i++)
    e[i] === "tool-call" ? n === -1 && (n = i) : (n !== -1 && (t.push({
      type: "toolGroup",
      startIndex: n,
      endIndex: i - 1
    }), n = -1), t.push({ type: "single", index: i }));
  return n !== -1 && t.push({
    type: "toolGroup",
    startIndex: n,
    endIndex: e.length - 1
  }), t;
}, X3 = () => {
  const e = qn(
    Y3((t) => t.content.map((n) => n.type))
  );
  return $.useMemo(() => e.length === 0 ? [] : J3(e), [e]);
}, K3 = ({
  Fallback: e,
  ...t
}) => {
  const n = RU((i) => i.getToolUI(t.toolName)) ?? e;
  return n ? /* @__PURE__ */ C.jsx(n, { ...t }) : null;
}, Wi = {
  Text: () => /* @__PURE__ */ C.jsxs("p", { style: { whiteSpace: "pre-line" }, children: [
    /* @__PURE__ */ C.jsx(EA, {}),
    /* @__PURE__ */ C.jsx(AA, { children: /* @__PURE__ */ C.jsx("span", { style: { fontFamily: "revert" }, children: " " }) })
  ] }),
  Reasoning: () => null,
  Source: () => null,
  Image: () => /* @__PURE__ */ C.jsx($A, {}),
  File: () => null,
  Unstable_Audio: () => null,
  ToolGroup: ({ children: e }) => e
}, W3 = ({
  components: {
    Text: e = Wi.Text,
    Reasoning: t = Wi.Reasoning,
    Image: n = Wi.Image,
    Source: i = Wi.Source,
    File: r = Wi.File,
    Unstable_Audio: s = Wi.Unstable_Audio,
    tools: l = {}
  } = {}
}) => {
  const c = Hv(), f = Su(), h = f.type;
  if (h === "tool-call") {
    const p = (y) => c.addToolResult(y);
    if ("Override" in l)
      return /* @__PURE__ */ C.jsx(l.Override, { ...f, addResult: p });
    const m = l.by_name?.[f.toolName] ?? l.Fallback;
    return /* @__PURE__ */ C.jsx(K3, { ...f, Fallback: m, addResult: p });
  }
  if (f.status.type === "requires-action")
    throw new Error("Encountered unexpected requires-action status");
  switch (h) {
    case "text":
      return /* @__PURE__ */ C.jsx(e, { ...f });
    case "reasoning":
      return /* @__PURE__ */ C.jsx(t, { ...f });
    case "source":
      return /* @__PURE__ */ C.jsx(i, { ...f });
    case "image":
      return /* @__PURE__ */ C.jsx(n, { ...f });
    case "file":
      return /* @__PURE__ */ C.jsx(r, { ...f });
    case "audio":
      return /* @__PURE__ */ C.jsx(s, { ...f });
    default:
      const p = h;
      throw new Error(`Unknown message part type: ${p}`);
  }
}, Lg = $.memo(
  ({ index: e, components: t }) => {
    const n = Ar(), i = $.useMemo(
      () => n.getMessagePartByIndex(e),
      [n, e]
    );
    return /* @__PURE__ */ C.jsx(F3, { runtime: i, children: /* @__PURE__ */ C.jsx(W3, { components: t }) });
  },
  (e, t) => e.index === t.index && e.components?.Text === t.components?.Text && e.components?.Reasoning === t.components?.Reasoning && e.components?.Source === t.components?.Source && e.components?.Image === t.components?.Image && e.components?.File === t.components?.File && e.components?.Unstable_Audio === t.components?.Unstable_Audio && e.components?.tools === t.components?.tools && e.components?.ToolGroup === t.components?.ToolGroup
);
Lg.displayName = "MessagePrimitive.PartByIndex";
var Q3 = Object.freeze({
  type: "complete"
}), eZ = ({ status: e, component: t }) => /* @__PURE__ */ C.jsx(QU, { text: "", isRunning: e.type === "running", children: /* @__PURE__ */ C.jsx(t, { type: "text", text: "", status: e }) }), tZ = ({ components: e }) => {
  const t = qn((n) => n.status) ?? Q3;
  return e?.Empty ? /* @__PURE__ */ C.jsx(e.Empty, { status: t }) : /* @__PURE__ */ C.jsx(
    eZ,
    {
      status: t,
      component: e?.Text ?? Wi.Text
    }
  );
}, nZ = $.memo(
  tZ,
  (e, t) => e.components?.Empty === t.components?.Empty && e.components?.Text === t.components?.Text
), oy = ({
  components: e
}) => {
  const t = qn((r) => r.content.length), n = X3(), i = $.useMemo(() => t === 0 ? /* @__PURE__ */ C.jsx(nZ, { components: e }) : n.map((r) => {
    if (r.type === "single")
      return /* @__PURE__ */ C.jsx(
        Lg,
        {
          index: r.index,
          components: e
        },
        r.index
      );
    {
      const s = e.ToolGroup ?? Wi.ToolGroup;
      return /* @__PURE__ */ C.jsx(
        s,
        {
          startIndex: r.startIndex,
          endIndex: r.endIndex,
          children: Array.from(
            { length: r.endIndex - r.startIndex + 1 },
            (l, c) => /* @__PURE__ */ C.jsx(
              Lg,
              {
                index: r.startIndex + c,
                components: e
              },
              c
            )
          )
        },
        r.startIndex
      );
    }
  }), [n, e, t]);
  return /* @__PURE__ */ C.jsx(C.Fragment, { children: i });
};
oy.displayName = "MessagePrimitive.Parts";
var rZ = (e) => {
  const t = Ar(), n = qv();
  return Cf(
    [t, n],
    ({
      role: i,
      attachments: r,
      content: s,
      branchCount: l,
      isLast: c,
      speech: f,
      submittedFeedback: h
    }, { isCopied: p, isHovering: m }) => !(e.hasBranches === !0 && l < 2 || e.user && i !== "user" || e.assistant && i !== "assistant" || e.system && i !== "system" || e.lastOrHover === !0 && !m && !c || e.last !== void 0 && e.last !== c || e.copied === !0 && !p || e.copied === !1 && p || e.speaking === !0 && f == null || e.speaking === !1 && f != null || e.hasAttachments === !0 && (i !== "user" || !r.length) || e.hasAttachments === !1 && i === "user" && r.length || e.hasContent === !0 && s.length === 0 || e.hasContent === !1 && s.length > 0 || e.submittedFeedback !== void 0 && (h?.type ?? null) !== e.submittedFeedback)
  );
}, Kd = ({
  children: e,
  ...t
}) => rZ(t) ? e : null;
Kd.displayName = "MessagePrimitive.If";
var zA = ({ children: e }) => qn(
  (n) => n.status?.type === "incomplete" && n.status.reason === "error"
) ? /* @__PURE__ */ C.jsx(C.Fragment, { children: e }) : null;
zA.displayName = "MessagePrimitive.Error";
var IA = $.forwardRef(({ hideWhenSingleBranch: e, ...t }, n) => /* @__PURE__ */ C.jsx(Kd, { hasBranches: e ? !0 : void 0, children: /* @__PURE__ */ C.jsx(Ft.div, { ...t, ref: n }) }));
IA.displayName = "BranchPickerPrimitive.Root";
var CA = () => {
  const e = ku(), t = _i(), n = Cf(
    [t, e],
    (r, s) => r.isRunning || !s.isEditing || s.isEmpty
  ), i = $.useCallback(() => {
    e.send();
  }, [e]);
  return n ? null : i;
}, OA = ua(
  "ComposerPrimitive.Send",
  CA
), ly = $.forwardRef(({ onSubmit: e, ...t }, n) => {
  const i = CA(), r = (s) => {
    s.preventDefault(), i && i();
  };
  return /* @__PURE__ */ C.jsx(
    Ft.form,
    {
      ...t,
      ref: n,
      onSubmit: hn(e, r)
    }
  );
});
ly.displayName = "ComposerPrimitive.Root";
function Bg() {
  return Bg = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n) ({}).hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, Bg.apply(null, arguments);
}
function iZ(e, t) {
  if (e == null) return {};
  var n = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    n[i] = e[i];
  }
  return n;
}
var aZ = $.useLayoutEffect, sZ = function(t) {
  var n = Lr.useRef(t);
  return aZ(function() {
    n.current = t;
  }), n;
}, F1 = function(t, n) {
  if (typeof t == "function") {
    t(n);
    return;
  }
  t.current = n;
}, oZ = function(t, n) {
  var i = Lr.useRef();
  return Lr.useCallback(function(r) {
    t.current = r, i.current && F1(i.current, null), i.current = n, n && F1(n, r);
  }, [n]);
}, H1 = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0",
  display: "block"
}, lZ = function(t) {
  Object.keys(H1).forEach(function(n) {
    t.style.setProperty(n, H1[n], "important");
  });
}, q1 = lZ, dn = null, G1 = function(t, n) {
  var i = t.scrollHeight;
  return n.sizingStyle.boxSizing === "border-box" ? i + n.borderSize : i - n.paddingSize;
};
function uZ(e, t, n, i) {
  n === void 0 && (n = 1), i === void 0 && (i = 1 / 0), dn || (dn = document.createElement("textarea"), dn.setAttribute("tabindex", "-1"), dn.setAttribute("aria-hidden", "true"), q1(dn)), dn.parentNode === null && document.body.appendChild(dn);
  var r = e.paddingSize, s = e.borderSize, l = e.sizingStyle, c = l.boxSizing;
  Object.keys(l).forEach(function(y) {
    var b = y;
    dn.style[b] = l[b];
  }), q1(dn), dn.value = t;
  var f = G1(dn, e);
  dn.value = t, f = G1(dn, e), dn.value = "x";
  var h = dn.scrollHeight - r, p = h * n;
  c === "border-box" && (p = p + r + s), f = Math.max(p, f);
  var m = h * i;
  return c === "border-box" && (m = m + r + s), f = Math.min(m, f), [f, h];
}
var Y1 = function() {
}, cZ = function(t, n) {
  return t.reduce(function(i, r) {
    return i[r] = n[r], i;
  }, {});
}, dZ = [
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRightWidth",
  "borderTopWidth",
  "boxSizing",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "paddingBottom",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  // non-standard
  "tabSize",
  "textIndent",
  // non-standard
  "textRendering",
  "textTransform",
  "width",
  "wordBreak",
  "wordSpacing",
  "scrollbarGutter"
], fZ = !!document.documentElement.currentStyle, hZ = function(t) {
  var n = window.getComputedStyle(t);
  if (n === null)
    return null;
  var i = cZ(dZ, n), r = i.boxSizing;
  if (r === "")
    return null;
  fZ && r === "border-box" && (i.width = parseFloat(i.width) + parseFloat(i.borderRightWidth) + parseFloat(i.borderLeftWidth) + parseFloat(i.paddingRight) + parseFloat(i.paddingLeft) + "px");
  var s = parseFloat(i.paddingBottom) + parseFloat(i.paddingTop), l = parseFloat(i.borderBottomWidth) + parseFloat(i.borderTopWidth);
  return {
    sizingStyle: i,
    paddingSize: s,
    borderSize: l
  };
}, pZ = hZ;
function uy(e, t, n) {
  var i = sZ(n);
  $.useLayoutEffect(function() {
    var r = function(l) {
      return i.current(l);
    };
    if (e)
      return e.addEventListener(t, r), function() {
        return e.removeEventListener(t, r);
      };
  }, []);
}
var mZ = function(t, n) {
  uy(document.body, "reset", function(i) {
    t.current.form === i.target && n(i);
  });
}, gZ = function(t) {
  uy(window, "resize", t);
}, vZ = function(t) {
  uy(document.fonts, "loadingdone", t);
}, yZ = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"], bZ = function(t, n) {
  var i = t.cacheMeasurements, r = t.maxRows, s = t.minRows, l = t.onChange, c = l === void 0 ? Y1 : l, f = t.onHeightChange, h = f === void 0 ? Y1 : f, p = iZ(t, yZ), m = p.value !== void 0, y = $.useRef(null), b = oZ(y, n), x = $.useRef(0), w = $.useRef(), k = function() {
    var z = y.current, O = i && w.current ? w.current : pZ(z);
    if (O) {
      w.current = O;
      var M = uZ(O, z.value || z.placeholder || "x", s, r), N = M[0], U = M[1];
      x.current !== N && (x.current = N, z.style.setProperty("height", N + "px", "important"), h(N, {
        rowHeight: U
      }));
    }
  }, T = function(z) {
    m || k(), c(z);
  };
  return $.useLayoutEffect(k), mZ(y, function() {
    if (!m) {
      var A = y.current.value;
      requestAnimationFrame(function() {
        var z = y.current;
        z && A !== z.value && k();
      });
    }
  }), gZ(k), vZ(k), /* @__PURE__ */ $.createElement("textarea", Bg({}, p, {
    onChange: T,
    ref: b
  }));
}, xZ = /* @__PURE__ */ $.forwardRef(bZ), RA = (e) => {
  const t = Gr(e), n = O$((i) => i.onScrollToBottom);
  $.useEffect(() => n(t), [n, t]);
}, cy = $.forwardRef(
  ({
    autoFocus: e = !1,
    asChild: t,
    disabled: n,
    onChange: i,
    onKeyDown: r,
    onPaste: s,
    submitOnEnter: l = !0,
    cancelOnEscape: c = !0,
    unstable_focusOnRunStart: f = !0,
    unstable_focusOnScrollToBottom: h = !0,
    unstable_focusOnThreadSwitched: p = !0,
    addAttachmentOnPaste: m = !0,
    ...y
  }, b) => {
    const x = If(), w = _i(), k = ku(), T = P$((D) => D.isEditing ? D.text : ""), A = t ? q$ : xZ, z = !!(_u((D) => D.isDisabled) || n), O = $.useRef(null), M = zr(b, O);
    J$((D) => {
      c && k.getState().canCancel && (k.cancel(), D.preventDefault());
    });
    const N = (D) => {
      if (!(z || !l) && !D.nativeEvent.isComposing && D.key === "Enter" && D.shiftKey === !1) {
        const { isRunning: ae } = w.getState();
        ae || (D.preventDefault(), O.current?.closest("form")?.requestSubmit());
      }
    }, U = async (D) => {
      if (!m) return;
      const ae = w.getState().capabilities, ie = Array.from(D.clipboardData?.files || []);
      if (ae.attachments && ie.length > 0)
        try {
          D.preventDefault(), await Promise.all(
            ie.map((le) => k.addAttachment(le))
          );
        } catch (le) {
          console.error("Error adding attachment:", le);
        }
    }, Z = e && !z, re = $.useCallback(() => {
      const D = O.current;
      !D || !Z || (D.focus({ preventScroll: !0 }), D.setSelectionRange(D.value.length, D.value.length));
    }, [Z]);
    return $.useEffect(() => re(), [re]), RA(() => {
      k.type === "thread" && h && re();
    }), $.useEffect(() => {
      if (!(k.type !== "thread" || !f))
        return w.unstable_on("run-start", re);
    }, [f, re, k, w]), $.useEffect(() => {
      if (!(k.type !== "thread" || !p))
        return x.unstable_on("switched-to", re);
    }, [
      p,
      re,
      k,
      x
    ]), /* @__PURE__ */ C.jsx(
      A,
      {
        name: "input",
        value: T,
        ...y,
        ref: M,
        disabled: z,
        onChange: hn(i, (D) => {
          if (k.getState().isEditing)
            return k.setText(D.target.value);
        }),
        onKeyDown: hn(r, N),
        onPaste: hn(s, U)
      }
    );
  }
);
cy.displayName = "ComposerPrimitive.Input";
var wZ = () => {
  const e = ku(), t = P$((i) => !i.canCancel), n = $.useCallback(() => {
    e.cancel();
  }, [e]);
  return t ? null : n;
}, NA = ua(
  "ComposerPrimitive.Cancel",
  wZ
), MA = $.forwardRef((e, t) => /* @__PURE__ */ C.jsx(Ft.div, { role: "alert", ...e, ref: t }));
MA.displayName = "ErrorPrimitive.Root";
var DA = $.forwardRef(({ children: e, ...t }, n) => {
  const i = qn((r) => r.status?.type === "incomplete" && r.status.reason === "error" ? r.status.error : void 0);
  return i === void 0 ? null : /* @__PURE__ */ C.jsx(Ft.span, { ...t, ref: n, children: e ?? String(i) });
});
DA.displayName = "ErrorPrimitive.Message";
var jA = $.forwardRef((e, t) => /* @__PURE__ */ C.jsx(Ft.div, { ...e, ref: t }));
jA.displayName = "ThreadPrimitive.Root";
var dy = ({
  children: e
}) => _u((n) => n.messages.length === 0) ? e : null;
dy.displayName = "ThreadPrimitive.Empty";
var _Z = (e) => _u((t) => !(e.empty === !0 && t.messages.length !== 0 || e.empty === !1 && t.messages.length === 0 || e.running === !0 && !t.isRunning || e.running === !1 && t.isRunning || e.disabled === !0 && !t.isDisabled || e.disabled === !1 && t.isDisabled)), Wd = ({
  children: e,
  ...t
}) => _Z(t) ? e : null;
Wd.displayName = "ThreadPrimitive.If";
var SZ = (e) => {
  const t = Gr(e), n = $.useCallback(
    (i) => {
      const r = new ResizeObserver(() => {
        t();
      }), s = new MutationObserver(() => {
        t();
      });
      return r.observe(i), s.observe(i, {
        childList: !0,
        subtree: !0,
        attributes: !0,
        characterData: !0
      }), () => {
        r.disconnect(), s.disconnect();
      };
    },
    [t]
  );
  return ay(n);
}, kZ = ({
  autoScroll: e = !0
}) => {
  const t = $.useRef(null), n = Vv(), i = $.useRef(0), r = $.useRef(!1), s = $.useCallback(
    (m) => {
      const y = t.current;
      !y || !e || (r.current = !0, y.scrollTo({ top: y.scrollHeight, behavior: m }));
    },
    [e]
  ), l = () => {
    const m = t.current;
    if (!m) return;
    const y = n.getState().isAtBottom, b = m.scrollHeight - m.scrollTop <= m.clientHeight + 1;
    !b && i.current < m.scrollTop || (b && (r.current = !1), b !== y && qr(n).setState({
      isAtBottom: b
    })), i.current = m.scrollTop;
  }, c = SZ(() => {
    (r.current || n.getState().isAtBottom) && s("instant"), l();
  }), f = ay((m) => (m.addEventListener("scroll", l), () => {
    m.removeEventListener("scroll", l);
  }));
  RA(() => {
    s("auto");
  });
  const h = _i();
  return $.useEffect(() => h.unstable_on("run-start", () => s("auto")), [s, h]), zr(c, f, t);
}, PA = $.forwardRef(({ autoScroll: e, children: t, ...n }, i) => {
  const r = kZ({
    autoScroll: e
  }), s = zr(i, r);
  return /* @__PURE__ */ C.jsx(Ft.div, { ...n, ref: s, children: t });
});
PA.displayName = "ThreadPrimitive.ViewportScrollable";
var UA = $.forwardRef((e, t) => /* @__PURE__ */ C.jsx(R$, { children: /* @__PURE__ */ C.jsx(PA, { ...e, ref: t }) }));
UA.displayName = "ThreadPrimitive.Viewport";
var TZ = () => gn((e) => ({
  isCopied: !1,
  setIsCopied: (t) => {
    e({ isCopied: t });
  },
  isHovering: !1,
  setIsHovering: (t) => {
    e({ isHovering: t });
  }
})), EZ = (e) => {
  const [t] = $.useState(() => gn(() => e));
  return $.useEffect(() => {
    gi(e), qr(t).setState(e, !0);
  }, [e, t]), t;
}, $Z = () => {
  const [e] = $.useState(() => TZ());
  return e;
}, AZ = ({
  runtime: e,
  children: t
}) => {
  const n = EZ(e), i = $Z(), [r] = $.useState(() => ({ useMessageRuntime: n, useMessageUtils: i }));
  return /* @__PURE__ */ C.jsx(N$.Provider, { value: r, children: t });
}, LA = (e, t) => e.Message === t.Message && e.EditComposer === t.EditComposer && e.UserEditComposer === t.UserEditComposer && e.AssistantEditComposer === t.AssistantEditComposer && e.SystemEditComposer === t.SystemEditComposer && e.UserMessage === t.UserMessage && e.AssistantMessage === t.AssistantMessage && e.SystemMessage === t.SystemMessage, zZ = () => null, IZ = (e, t, n) => {
  switch (t) {
    case "user":
      return n ? e.UserEditComposer ?? e.EditComposer ?? e.UserMessage ?? e.Message : e.UserMessage ?? e.Message;
    case "assistant":
      return n ? e.AssistantEditComposer ?? e.EditComposer ?? e.AssistantMessage ?? e.Message : e.AssistantMessage ?? e.Message;
    case "system":
      return n ? e.SystemEditComposer ?? e.EditComposer ?? e.SystemMessage ?? e.Message : e.SystemMessage ?? zZ;
    default:
      const i = t;
      throw new Error(`Unknown message role: ${i}`);
  }
}, CZ = ({
  components: e
}) => {
  const t = qn((r) => r.role), n = D$((r) => r.isEditing), i = IZ(e, t, n);
  return /* @__PURE__ */ C.jsx(i, {});
}, BA = $.memo(
  ({ index: e, components: t }) => {
    const n = _i(), i = $.useMemo(
      () => n.getMesssageByIndex(e),
      [n, e]
    );
    return /* @__PURE__ */ C.jsx(AZ, { runtime: i, children: /* @__PURE__ */ C.jsx(CZ, { components: t }) });
  },
  (e, t) => e.index === t.index && LA(e.components, t.components)
);
BA.displayName = "ThreadPrimitive.MessageByIndex";
var ZA = ({
  components: e
}) => {
  const t = _u((i) => i.messages.length);
  return $.useMemo(() => t === 0 ? null : Array.from({ length: t }, (i, r) => /* @__PURE__ */ C.jsx(
    BA,
    {
      index: r,
      components: e
    },
    r
  )), [t, e]);
};
ZA.displayName = "ThreadPrimitive.Messages";
var OZ = $.memo(
  ZA,
  (e, t) => LA(e.components, t.components)
), RZ = () => {
  const e = O$((i) => i.isAtBottom), t = Vv(), n = $.useCallback(() => {
    t.getState().scrollToBottom();
  }, [t]);
  return e ? null : n;
}, NZ = ua(
  "ThreadPrimitive.ScrollToBottom",
  RZ
), MZ = ({
  prompt: e,
  autoSend: t
}) => {
  const n = _i(), i = _u((s) => s.isDisabled), r = $.useCallback(() => {
    t && !n.getState().isRunning ? n.append(e) : n.composer.setText(e);
  }, [n, t, e]);
  return i ? null : r;
}, DZ = ua(
  "ThreadPrimitive.Suggestion",
  MZ,
  ["prompt", "autoSend", "method"]
), J1 = (e, t) => {
  if (t == null) return [];
  let n = e.findIndex((i) => i.id === t);
  if (n === -1)
    throw new Error(
      "useVercelAIThreadState: Message not found. This is likely an internal bug in assistant-ui."
    );
  for (; e[n + 1]?.role === "assistant"; )
    n++;
  return e.slice(0, n + 1);
}, VA = "vercel.ai.error", jZ = Symbol.for(VA), FA, PZ = class HA extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: t,
    message: n,
    cause: i
  }) {
    super(n), this[FA] = !0, this.name = t, this.cause = i;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(t) {
    return HA.hasMarker(t, VA);
  }
  static hasMarker(t, n) {
    const i = Symbol.for(n);
    return t != null && typeof t == "object" && i in t && typeof t[i] == "boolean" && t[i] === !0;
  }
};
FA = jZ;
var na = PZ;
function qA(e) {
  return e == null ? "unknown error" : typeof e == "string" ? e : e instanceof Error ? e.message : JSON.stringify(e);
}
var GA = "AI_InvalidArgumentError", YA = `vercel.ai.error.${GA}`, UZ = Symbol.for(YA), JA, LZ = class extends na {
  constructor({
    message: e,
    cause: t,
    argument: n
  }) {
    super({ name: GA, message: e, cause: t }), this[JA] = !0, this.argument = n;
  }
  static isInstance(e) {
    return na.hasMarker(e, YA);
  }
};
JA = UZ;
var XA = "AI_JSONParseError", KA = `vercel.ai.error.${XA}`, BZ = Symbol.for(KA), WA, X1 = class extends na {
  constructor({ text: e, cause: t }) {
    super({
      name: XA,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${qA(t)}`,
      cause: t
    }), this[WA] = !0, this.text = e;
  }
  static isInstance(e) {
    return na.hasMarker(e, KA);
  }
};
WA = BZ;
var QA = "AI_TypeValidationError", ez = `vercel.ai.error.${QA}`, ZZ = Symbol.for(ez), tz, VZ = class Zg extends na {
  constructor({ value: t, cause: n }) {
    super({
      name: QA,
      message: `Type validation failed: Value: ${JSON.stringify(t)}.
Error message: ${qA(n)}`,
      cause: n
    }), this[tz] = !0, this.value = t;
  }
  static isInstance(t) {
    return na.hasMarker(t, ez);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: t,
    cause: n
  }) {
    return Zg.isInstance(n) && n.value === t ? n : new Zg({ value: t, cause: n });
  }
};
tz = ZZ;
var Qd = VZ;
class K1 extends Error {
  constructor(t, n) {
    super(t), this.name = "ParseError", this.type = n.type, this.field = n.field, this.value = n.value, this.line = n.line;
  }
}
function Bm(e) {
}
function FZ(e) {
  if (typeof e == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent: t = Bm, onError: n = Bm, onRetry: i = Bm, onComment: r } = e;
  let s = "", l = !0, c, f = "", h = "";
  function p(w) {
    const k = l ? w.replace(/^\xEF\xBB\xBF/, "") : w, [T, A] = HZ(`${s}${k}`);
    for (const z of T)
      m(z);
    s = A, l = !1;
  }
  function m(w) {
    if (w === "") {
      b();
      return;
    }
    if (w.startsWith(":")) {
      r && r(w.slice(w.startsWith(": ") ? 2 : 1));
      return;
    }
    const k = w.indexOf(":");
    if (k !== -1) {
      const T = w.slice(0, k), A = w[k + 1] === " " ? 2 : 1, z = w.slice(k + A);
      y(T, z, w);
      return;
    }
    y(w, "", w);
  }
  function y(w, k, T) {
    switch (w) {
      case "event":
        h = k;
        break;
      case "data":
        f = `${f}${k}
`;
        break;
      case "id":
        c = k.includes("\0") ? void 0 : k;
        break;
      case "retry":
        /^\d+$/.test(k) ? i(parseInt(k, 10)) : n(
          new K1(`Invalid \`retry\` value: "${k}"`, {
            type: "invalid-retry",
            value: k,
            line: T
          })
        );
        break;
      default:
        n(
          new K1(
            `Unknown field "${w.length > 20 ? `${w.slice(0, 20)}` : w}"`,
            { type: "unknown-field", field: w, value: k, line: T }
          )
        );
        break;
    }
  }
  function b() {
    f.length > 0 && t({
      id: c,
      event: h || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: f.endsWith(`
`) ? f.slice(0, -1) : f
    }), c = void 0, f = "", h = "";
  }
  function x(w = {}) {
    s && w.consume && m(s), l = !0, c = void 0, f = "", h = "", s = "";
  }
  return { feed: p, reset: x };
}
function HZ(e) {
  const t = [];
  let n = "", i = 0;
  for (; i < e.length; ) {
    const r = e.indexOf("\r", i), s = e.indexOf(`
`, i);
    let l = -1;
    if (r !== -1 && s !== -1 ? l = Math.min(r, s) : r !== -1 ? r === e.length - 1 ? l = -1 : l = r : s !== -1 && (l = s), l === -1) {
      n = e.slice(i);
      break;
    } else {
      const c = e.slice(i, l);
      t.push(c), i = l + 1, e[i - 1] === "\r" && e[i] === `
` && i++;
    }
  }
  return [t, n];
}
class qZ extends TransformStream {
  constructor({ onError: t, onRetry: n, onComment: i } = {}) {
    let r;
    super({
      start(s) {
        r = FZ({
          onEvent: (l) => {
            s.enqueue(l);
          },
          onError(l) {
            t === "terminate" ? s.error(l) : typeof t == "function" && t(l);
          },
          onRetry: n,
          onComment: i
        });
      },
      transform(s) {
        r.feed(s);
      }
    });
  }
}
// @__NO_SIDE_EFFECTS__
function W(e, t, n) {
  function i(c, f) {
    var h;
    Object.defineProperty(c, "_zod", {
      value: c._zod ?? {},
      enumerable: !1
    }), (h = c._zod).traits ?? (h.traits = /* @__PURE__ */ new Set()), c._zod.traits.add(e), t(c, f);
    for (const p in l.prototype)
      p in c || Object.defineProperty(c, p, { value: l.prototype[p].bind(c) });
    c._zod.constr = l, c._zod.def = f;
  }
  const r = n?.Parent ?? Object;
  class s extends r {
  }
  Object.defineProperty(s, "name", { value: e });
  function l(c) {
    var f;
    const h = n?.Parent ? new s() : this;
    i(h, c), (f = h._zod).deferred ?? (f.deferred = []);
    for (const p of h._zod.deferred)
      p();
    return h;
  }
  return Object.defineProperty(l, "init", { value: i }), Object.defineProperty(l, Symbol.hasInstance, {
    value: (c) => n?.Parent && c instanceof n.Parent ? !0 : c?._zod?.traits?.has(e)
  }), Object.defineProperty(l, "name", { value: e }), l;
}
let ru = class extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
};
const nz = {};
function ra(e) {
  return nz;
}
function rz(e) {
  const t = Object.values(e).filter((i) => typeof i == "number");
  return Object.entries(e).filter(([i, r]) => t.indexOf(+i) === -1).map(([i, r]) => r);
}
function GZ(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function fy(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function hy(e) {
  return e == null;
}
function py(e) {
  const t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
function YZ(e, t) {
  const n = (e.toString().split(".")[1] || "").length, i = (t.toString().split(".")[1] || "").length, r = n > i ? n : i, s = Number.parseInt(e.toFixed(r).replace(".", "")), l = Number.parseInt(t.toFixed(r).replace(".", ""));
  return s % l / 10 ** r;
}
function We(e, t, n) {
  Object.defineProperty(e, t, {
    get() {
      {
        const i = n();
        return e[t] = i, i;
      }
    },
    set(i) {
      Object.defineProperty(e, t, {
        value: i
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function Eu(e, t, n) {
  Object.defineProperty(e, t, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function Ol(e) {
  return JSON.stringify(e);
}
const iz = Error.captureStackTrace ? Error.captureStackTrace : (...e) => {
};
function ef(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const JZ = fy(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function tf(e) {
  if (ef(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const n = t.prototype;
  return !(ef(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1);
}
const XZ = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function $u(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Qa(e, t, n) {
  const i = new e._zod.constr(t ?? e._zod.def);
  return (!t || n?.parent) && (i._zod.parent = e), i;
}
function xe(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function KZ(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const WZ = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function QZ(e, t) {
  const n = {}, i = e._zod.def;
  for (const r in t) {
    if (!(r in i.shape))
      throw new Error(`Unrecognized key: "${r}"`);
    t[r] && (n[r] = i.shape[r]);
  }
  return Qa(e, {
    ...e._zod.def,
    shape: n,
    checks: []
  });
}
function e9(e, t) {
  const n = { ...e._zod.def.shape }, i = e._zod.def;
  for (const r in t) {
    if (!(r in i.shape))
      throw new Error(`Unrecognized key: "${r}"`);
    t[r] && delete n[r];
  }
  return Qa(e, {
    ...e._zod.def,
    shape: n,
    checks: []
  });
}
function t9(e, t) {
  if (!tf(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const n = {
    ...e._zod.def,
    get shape() {
      const i = { ...e._zod.def.shape, ...t };
      return Eu(this, "shape", i), i;
    },
    checks: []
    // delete existing checks
  };
  return Qa(e, n);
}
function n9(e, t) {
  return Qa(e, {
    ...e._zod.def,
    get shape() {
      const n = { ...e._zod.def.shape, ...t._zod.def.shape };
      return Eu(this, "shape", n), n;
    },
    catchall: t._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function r9(e, t, n) {
  const i = t._zod.def.shape, r = { ...i };
  if (n)
    for (const s in n) {
      if (!(s in i))
        throw new Error(`Unrecognized key: "${s}"`);
      n[s] && (r[s] = e ? new e({
        type: "optional",
        innerType: i[s]
      }) : i[s]);
    }
  else
    for (const s in i)
      r[s] = e ? new e({
        type: "optional",
        innerType: i[s]
      }) : i[s];
  return Qa(t, {
    ...t._zod.def,
    shape: r,
    checks: []
  });
}
function i9(e, t, n) {
  const i = t._zod.def.shape, r = { ...i };
  if (n)
    for (const s in n) {
      if (!(s in r))
        throw new Error(`Unrecognized key: "${s}"`);
      n[s] && (r[s] = new e({
        type: "nonoptional",
        innerType: i[s]
      }));
    }
  else
    for (const s in i)
      r[s] = new e({
        type: "nonoptional",
        innerType: i[s]
      });
  return Qa(t, {
    ...t._zod.def,
    shape: r,
    // optional: [],
    checks: []
  });
}
function Hl(e, t = 0) {
  for (let n = t; n < e.issues.length; n++)
    if (e.issues[n]?.continue !== !0)
      return !0;
  return !1;
}
function ja(e, t) {
  return t.map((n) => {
    var i;
    return (i = n).path ?? (i.path = []), n.path.unshift(e), n;
  });
}
function yd(e) {
  return typeof e == "string" ? e : e?.message;
}
function ia(e, t, n) {
  const i = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const r = yd(e.inst?._zod.def?.error?.(e)) ?? yd(t?.error?.(e)) ?? yd(n.customError?.(e)) ?? yd(n.localeError?.(e)) ?? "Invalid input";
    i.message = r;
  }
  return delete i.inst, delete i.continue, t?.reportInput || delete i.input, i;
}
function my(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function iu(...e) {
  const [t, n, i] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: n,
    inst: i
  } : { ...t };
}
const az = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), Object.defineProperty(e, "message", {
    get() {
      return JSON.stringify(t, GZ, 2);
    },
    enumerable: !0
    // configurable: false,
  }), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, sz = /* @__PURE__ */ W("$ZodError", az), oz = /* @__PURE__ */ W("$ZodError", az, { Parent: Error });
function a9(e, t = (n) => n.message) {
  const n = {}, i = [];
  for (const r of e.issues)
    r.path.length > 0 ? (n[r.path[0]] = n[r.path[0]] || [], n[r.path[0]].push(t(r))) : i.push(t(r));
  return { formErrors: i, fieldErrors: n };
}
function s9(e, t) {
  const n = t || function(s) {
    return s.message;
  }, i = { _errors: [] }, r = (s) => {
    for (const l of s.issues)
      if (l.code === "invalid_union" && l.errors.length)
        l.errors.map((c) => r({ issues: c }));
      else if (l.code === "invalid_key")
        r({ issues: l.issues });
      else if (l.code === "invalid_element")
        r({ issues: l.issues });
      else if (l.path.length === 0)
        i._errors.push(n(l));
      else {
        let c = i, f = 0;
        for (; f < l.path.length; ) {
          const h = l.path[f];
          f === l.path.length - 1 ? (c[h] = c[h] || { _errors: [] }, c[h]._errors.push(n(l))) : c[h] = c[h] || { _errors: [] }, c = c[h], f++;
        }
      }
  };
  return r(e), i;
}
const o9 = (e) => (t, n, i, r) => {
  const s = i ? Object.assign(i, { async: !1 }) : { async: !1 }, l = t._zod.run({ value: n, issues: [] }, s);
  if (l instanceof Promise)
    throw new ru();
  if (l.issues.length) {
    const c = new (r?.Err ?? e)(l.issues.map((f) => ia(f, s, ra())));
    throw iz(c, r?.callee), c;
  }
  return l.value;
}, l9 = (e) => async (t, n, i, r) => {
  const s = i ? Object.assign(i, { async: !0 }) : { async: !0 };
  let l = t._zod.run({ value: n, issues: [] }, s);
  if (l instanceof Promise && (l = await l), l.issues.length) {
    const c = new (r?.Err ?? e)(l.issues.map((f) => ia(f, s, ra())));
    throw iz(c, r?.callee), c;
  }
  return l.value;
}, lz = (e) => (t, n, i) => {
  const r = i ? { ...i, async: !1 } : { async: !1 }, s = t._zod.run({ value: n, issues: [] }, r);
  if (s instanceof Promise)
    throw new ru();
  return s.issues.length ? {
    success: !1,
    error: new (e ?? sz)(s.issues.map((l) => ia(l, r, ra())))
  } : { success: !0, data: s.value };
}, u9 = /* @__PURE__ */ lz(oz), uz = (e) => async (t, n, i) => {
  const r = i ? Object.assign(i, { async: !0 }) : { async: !0 };
  let s = t._zod.run({ value: n, issues: [] }, r);
  return s instanceof Promise && (s = await s), s.issues.length ? {
    success: !1,
    error: new e(s.issues.map((l) => ia(l, r, ra())))
  } : { success: !0, data: s.value };
}, c9 = /* @__PURE__ */ uz(oz), d9 = /^[cC][^\s-]{8,}$/, f9 = /^[0-9a-z]+$/, h9 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, p9 = /^[0-9a-vA-V]{20}$/, m9 = /^[A-Za-z0-9]{27}$/, g9 = /^[a-zA-Z0-9_-]{21}$/, v9 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, y9 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, W1 = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/, b9 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, x9 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function w9() {
  return new RegExp(x9, "u");
}
const _9 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, S9 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/, k9 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, T9 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, E9 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, cz = /^[A-Za-z0-9_-]*$/, $9 = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/, A9 = /^\+(?:[0-9]){6,14}[0-9]$/, dz = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", z9 = /* @__PURE__ */ new RegExp(`^${dz}$`);
function fz(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function I9(e) {
  return new RegExp(`^${fz(e)}$`);
}
function C9(e) {
  const t = fz({ precision: e.precision }), n = ["Z"];
  e.local && n.push(""), e.offset && n.push("([+-]\\d{2}:\\d{2})");
  const i = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${dz}T(?:${i})$`);
}
const O9 = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, R9 = /^\d+$/, N9 = /^-?\d+(?:\.\d+)?/i, M9 = /true|false/i, D9 = /null/i, j9 = /^[^A-Z]*$/, P9 = /^[^a-z]*$/, An = /* @__PURE__ */ W("$ZodCheck", (e, t) => {
  var n;
  e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []);
}), hz = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, pz = /* @__PURE__ */ W("$ZodCheckLessThan", (e, t) => {
  An.init(e, t);
  const n = hz[typeof t.value];
  e._zod.onattach.push((i) => {
    const r = i._zod.bag, s = (t.inclusive ? r.maximum : r.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < s && (t.inclusive ? r.maximum = t.value : r.exclusiveMaximum = t.value);
  }), e._zod.check = (i) => {
    (t.inclusive ? i.value <= t.value : i.value < t.value) || i.issues.push({
      origin: n,
      code: "too_big",
      maximum: t.value,
      input: i.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), mz = /* @__PURE__ */ W("$ZodCheckGreaterThan", (e, t) => {
  An.init(e, t);
  const n = hz[typeof t.value];
  e._zod.onattach.push((i) => {
    const r = i._zod.bag, s = (t.inclusive ? r.minimum : r.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > s && (t.inclusive ? r.minimum = t.value : r.exclusiveMinimum = t.value);
  }), e._zod.check = (i) => {
    (t.inclusive ? i.value >= t.value : i.value > t.value) || i.issues.push({
      origin: n,
      code: "too_small",
      minimum: t.value,
      input: i.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), U9 = /* @__PURE__ */ W("$ZodCheckMultipleOf", (e, t) => {
  An.init(e, t), e._zod.onattach.push((n) => {
    var i;
    (i = n._zod.bag).multipleOf ?? (i.multipleOf = t.value);
  }), e._zod.check = (n) => {
    if (typeof n.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof n.value == "bigint" ? n.value % t.value === BigInt(0) : YZ(n.value, t.value) === 0) || n.issues.push({
      origin: typeof n.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), L9 = /* @__PURE__ */ W("$ZodCheckNumberFormat", (e, t) => {
  An.init(e, t), t.format = t.format || "float64";
  const n = t.format?.includes("int"), i = n ? "int" : "number", [r, s] = WZ[t.format];
  e._zod.onattach.push((l) => {
    const c = l._zod.bag;
    c.format = t.format, c.minimum = r, c.maximum = s, n && (c.pattern = R9);
  }), e._zod.check = (l) => {
    const c = l.value;
    if (n) {
      if (!Number.isInteger(c)) {
        l.issues.push({
          expected: i,
          format: t.format,
          code: "invalid_type",
          input: c,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(c)) {
        c > 0 ? l.issues.push({
          input: c,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: i,
          continue: !t.abort
        }) : l.issues.push({
          input: c,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: i,
          continue: !t.abort
        });
        return;
      }
    }
    c < r && l.issues.push({
      origin: "number",
      input: c,
      code: "too_small",
      minimum: r,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), c > s && l.issues.push({
      origin: "number",
      input: c,
      code: "too_big",
      maximum: s,
      inst: e
    });
  };
}), B9 = /* @__PURE__ */ W("$ZodCheckMaxLength", (e, t) => {
  var n;
  An.init(e, t), (n = e._zod.def).when ?? (n.when = (i) => {
    const r = i.value;
    return !hy(r) && r.length !== void 0;
  }), e._zod.onattach.push((i) => {
    const r = i._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < r && (i._zod.bag.maximum = t.maximum);
  }), e._zod.check = (i) => {
    const r = i.value;
    if (r.length <= t.maximum)
      return;
    const l = my(r);
    i.issues.push({
      origin: l,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: r,
      inst: e,
      continue: !t.abort
    });
  };
}), Z9 = /* @__PURE__ */ W("$ZodCheckMinLength", (e, t) => {
  var n;
  An.init(e, t), (n = e._zod.def).when ?? (n.when = (i) => {
    const r = i.value;
    return !hy(r) && r.length !== void 0;
  }), e._zod.onattach.push((i) => {
    const r = i._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > r && (i._zod.bag.minimum = t.minimum);
  }), e._zod.check = (i) => {
    const r = i.value;
    if (r.length >= t.minimum)
      return;
    const l = my(r);
    i.issues.push({
      origin: l,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: r,
      inst: e,
      continue: !t.abort
    });
  };
}), V9 = /* @__PURE__ */ W("$ZodCheckLengthEquals", (e, t) => {
  var n;
  An.init(e, t), (n = e._zod.def).when ?? (n.when = (i) => {
    const r = i.value;
    return !hy(r) && r.length !== void 0;
  }), e._zod.onattach.push((i) => {
    const r = i._zod.bag;
    r.minimum = t.length, r.maximum = t.length, r.length = t.length;
  }), e._zod.check = (i) => {
    const r = i.value, s = r.length;
    if (s === t.length)
      return;
    const l = my(r), c = s > t.length;
    i.issues.push({
      origin: l,
      ...c ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Df = /* @__PURE__ */ W("$ZodCheckStringFormat", (e, t) => {
  var n, i;
  An.init(e, t), e._zod.onattach.push((r) => {
    const s = r._zod.bag;
    s.format = t.format, t.pattern && (s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(t.pattern));
  }), t.pattern ? (n = e._zod).check ?? (n.check = (r) => {
    t.pattern.lastIndex = 0, !t.pattern.test(r.value) && r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: r.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (i = e._zod).check ?? (i.check = () => {
  });
}), F9 = /* @__PURE__ */ W("$ZodCheckRegex", (e, t) => {
  Df.init(e, t), e._zod.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: n.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), H9 = /* @__PURE__ */ W("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = j9), Df.init(e, t);
}), q9 = /* @__PURE__ */ W("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = P9), Df.init(e, t);
}), G9 = /* @__PURE__ */ W("$ZodCheckIncludes", (e, t) => {
  An.init(e, t);
  const n = $u(t.includes), i = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
  t.pattern = i, e._zod.onattach.push((r) => {
    const s = r._zod.bag;
    s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(i);
  }), e._zod.check = (r) => {
    r.value.includes(t.includes, t.position) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Y9 = /* @__PURE__ */ W("$ZodCheckStartsWith", (e, t) => {
  An.init(e, t);
  const n = new RegExp(`^${$u(t.prefix)}.*`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((i) => {
    const r = i._zod.bag;
    r.patterns ?? (r.patterns = /* @__PURE__ */ new Set()), r.patterns.add(n);
  }), e._zod.check = (i) => {
    i.value.startsWith(t.prefix) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), J9 = /* @__PURE__ */ W("$ZodCheckEndsWith", (e, t) => {
  An.init(e, t);
  const n = new RegExp(`.*${$u(t.suffix)}$`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((i) => {
    const r = i._zod.bag;
    r.patterns ?? (r.patterns = /* @__PURE__ */ new Set()), r.patterns.add(n);
  }), e._zod.check = (i) => {
    i.value.endsWith(t.suffix) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), X9 = /* @__PURE__ */ W("$ZodCheckOverwrite", (e, t) => {
  An.init(e, t), e._zod.check = (n) => {
    n.value = t.tx(n.value);
  };
});
let K9 = class {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const i = t.split(`
`).filter((l) => l), r = Math.min(...i.map((l) => l.length - l.trimStart().length)), s = i.map((l) => l.slice(r)).map((l) => " ".repeat(this.indent * 2) + l);
    for (const l of s)
      this.content.push(l);
  }
  compile() {
    const t = Function, n = this?.args, r = [...(this?.content ?? [""]).map((s) => `  ${s}`)];
    return new t(...n, r.join(`
`));
  }
};
const W9 = {
  major: 4,
  minor: 0,
  patch: 0
}, ct = /* @__PURE__ */ W("$ZodType", (e, t) => {
  var n;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = W9;
  const i = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && i.unshift(e);
  for (const r of i)
    for (const s of r._zod.onattach)
      s(e);
  if (i.length === 0)
    (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const r = (s, l, c) => {
      let f = Hl(s), h;
      for (const p of l) {
        if (p._zod.def.when) {
          if (!p._zod.def.when(s))
            continue;
        } else if (f)
          continue;
        const m = s.issues.length, y = p._zod.check(s);
        if (y instanceof Promise && c?.async === !1)
          throw new ru();
        if (h || y instanceof Promise)
          h = (h ?? Promise.resolve()).then(async () => {
            await y, s.issues.length !== m && (f || (f = Hl(s, m)));
          });
        else {
          if (s.issues.length === m)
            continue;
          f || (f = Hl(s, m));
        }
      }
      return h ? h.then(() => s) : s;
    };
    e._zod.run = (s, l) => {
      const c = e._zod.parse(s, l);
      if (c instanceof Promise) {
        if (l.async === !1)
          throw new ru();
        return c.then((f) => r(f, i, l));
      }
      return r(c, i, l);
    };
  }
  e["~standard"] = {
    validate: (r) => {
      try {
        const s = u9(e, r);
        return s.success ? { value: s.data } : { issues: s.error?.issues };
      } catch {
        return c9(e, r).then((l) => l.success ? { value: l.data } : { issues: l.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
}), gy = /* @__PURE__ */ W("$ZodString", (e, t) => {
  ct.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? O9(e._zod.bag), e._zod.parse = (n, i) => {
    if (t.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: e
    }), n;
  };
}), yt = /* @__PURE__ */ W("$ZodStringFormat", (e, t) => {
  Df.init(e, t), gy.init(e, t);
}), Q9 = /* @__PURE__ */ W("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = y9), yt.init(e, t);
}), e5 = /* @__PURE__ */ W("$ZodUUID", (e, t) => {
  if (t.version) {
    const i = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (i === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = W1(i));
  } else
    t.pattern ?? (t.pattern = W1());
  yt.init(e, t);
}), t5 = /* @__PURE__ */ W("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = b9), yt.init(e, t);
}), n5 = /* @__PURE__ */ W("$ZodURL", (e, t) => {
  yt.init(e, t), e._zod.check = (n) => {
    try {
      const i = n.value, r = new URL(i), s = r.href;
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(r.hostname) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: $9.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(r.protocol.endsWith(":") ? r.protocol.slice(0, -1) : r.protocol) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), !i.endsWith("/") && s.endsWith("/") ? n.value = s.slice(0, -1) : n.value = s;
      return;
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "url",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), r5 = /* @__PURE__ */ W("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = w9()), yt.init(e, t);
}), i5 = /* @__PURE__ */ W("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = g9), yt.init(e, t);
}), a5 = /* @__PURE__ */ W("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = d9), yt.init(e, t);
}), s5 = /* @__PURE__ */ W("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = f9), yt.init(e, t);
}), o5 = /* @__PURE__ */ W("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = h9), yt.init(e, t);
}), l5 = /* @__PURE__ */ W("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = p9), yt.init(e, t);
}), u5 = /* @__PURE__ */ W("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = m9), yt.init(e, t);
}), c5 = /* @__PURE__ */ W("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = C9(t)), yt.init(e, t);
}), d5 = /* @__PURE__ */ W("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = z9), yt.init(e, t);
}), f5 = /* @__PURE__ */ W("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = I9(t)), yt.init(e, t);
}), h5 = /* @__PURE__ */ W("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = v9), yt.init(e, t);
}), p5 = /* @__PURE__ */ W("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = _9), yt.init(e, t), e._zod.onattach.push((n) => {
    const i = n._zod.bag;
    i.format = "ipv4";
  });
}), m5 = /* @__PURE__ */ W("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = S9), yt.init(e, t), e._zod.onattach.push((n) => {
    const i = n._zod.bag;
    i.format = "ipv6";
  }), e._zod.check = (n) => {
    try {
      new URL(`http://[${n.value}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), g5 = /* @__PURE__ */ W("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = k9), yt.init(e, t);
}), v5 = /* @__PURE__ */ W("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = T9), yt.init(e, t), e._zod.check = (n) => {
    const [i, r] = n.value.split("/");
    try {
      if (!r)
        throw new Error();
      const s = Number(r);
      if (`${s}` !== r)
        throw new Error();
      if (s < 0 || s > 128)
        throw new Error();
      new URL(`http://[${i}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function gz(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const y5 = /* @__PURE__ */ W("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = E9), yt.init(e, t), e._zod.onattach.push((n) => {
    n._zod.bag.contentEncoding = "base64";
  }), e._zod.check = (n) => {
    gz(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function b5(e) {
  if (!cz.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (i) => i === "-" ? "+" : "/"), n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return gz(n);
}
const x5 = /* @__PURE__ */ W("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = cz), yt.init(e, t), e._zod.onattach.push((n) => {
    n._zod.bag.contentEncoding = "base64url";
  }), e._zod.check = (n) => {
    b5(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), w5 = /* @__PURE__ */ W("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = A9), yt.init(e, t);
});
function _5(e, t = null) {
  try {
    const n = e.split(".");
    if (n.length !== 3)
      return !1;
    const [i] = n;
    if (!i)
      return !1;
    const r = JSON.parse(atob(i));
    return !("typ" in r && r?.typ !== "JWT" || !r.alg || t && (!("alg" in r) || r.alg !== t));
  } catch {
    return !1;
  }
}
const S5 = /* @__PURE__ */ W("$ZodJWT", (e, t) => {
  yt.init(e, t), e._zod.check = (n) => {
    _5(n.value, t.alg) || n.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), vz = /* @__PURE__ */ W("$ZodNumber", (e, t) => {
  ct.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? N9, e._zod.parse = (n, i) => {
    if (t.coerce)
      try {
        n.value = Number(n.value);
      } catch {
      }
    const r = n.value;
    if (typeof r == "number" && !Number.isNaN(r) && Number.isFinite(r))
      return n;
    const s = typeof r == "number" ? Number.isNaN(r) ? "NaN" : Number.isFinite(r) ? void 0 : "Infinity" : void 0;
    return n.issues.push({
      expected: "number",
      code: "invalid_type",
      input: r,
      inst: e,
      ...s ? { received: s } : {}
    }), n;
  };
}), k5 = /* @__PURE__ */ W("$ZodNumber", (e, t) => {
  L9.init(e, t), vz.init(e, t);
}), T5 = /* @__PURE__ */ W("$ZodBoolean", (e, t) => {
  ct.init(e, t), e._zod.pattern = M9, e._zod.parse = (n, i) => {
    if (t.coerce)
      try {
        n.value = !!n.value;
      } catch {
      }
    const r = n.value;
    return typeof r == "boolean" || n.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: r,
      inst: e
    }), n;
  };
}), E5 = /* @__PURE__ */ W("$ZodNull", (e, t) => {
  ct.init(e, t), e._zod.pattern = D9, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (n, i) => {
    const r = n.value;
    return r === null || n.issues.push({
      expected: "null",
      code: "invalid_type",
      input: r,
      inst: e
    }), n;
  };
}), $5 = /* @__PURE__ */ W("$ZodUnknown", (e, t) => {
  ct.init(e, t), e._zod.parse = (n) => n;
}), A5 = /* @__PURE__ */ W("$ZodNever", (e, t) => {
  ct.init(e, t), e._zod.parse = (n, i) => (n.issues.push({
    expected: "never",
    code: "invalid_type",
    input: n.value,
    inst: e
  }), n);
});
function Q1(e, t, n) {
  e.issues.length && t.issues.push(...ja(n, e.issues)), t.value[n] = e.value;
}
const z5 = /* @__PURE__ */ W("$ZodArray", (e, t) => {
  ct.init(e, t), e._zod.parse = (n, i) => {
    const r = n.value;
    if (!Array.isArray(r))
      return n.issues.push({
        expected: "array",
        code: "invalid_type",
        input: r,
        inst: e
      }), n;
    n.value = Array(r.length);
    const s = [];
    for (let l = 0; l < r.length; l++) {
      const c = r[l], f = t.element._zod.run({
        value: c,
        issues: []
      }, i);
      f instanceof Promise ? s.push(f.then((h) => Q1(h, n, l))) : Q1(f, n, l);
    }
    return s.length ? Promise.all(s).then(() => n) : n;
  };
});
function bd(e, t, n) {
  e.issues.length && t.issues.push(...ja(n, e.issues)), t.value[n] = e.value;
}
function ek(e, t, n, i) {
  e.issues.length ? i[n] === void 0 ? n in i ? t.value[n] = void 0 : t.value[n] = e.value : t.issues.push(...ja(n, e.issues)) : e.value === void 0 ? n in i && (t.value[n] = void 0) : t.value[n] = e.value;
}
const I5 = /* @__PURE__ */ W("$ZodObject", (e, t) => {
  ct.init(e, t);
  const n = fy(() => {
    const m = Object.keys(t.shape);
    for (const b of m)
      if (!(t.shape[b] instanceof ct))
        throw new Error(`Invalid element at key "${b}": expected a Zod schema`);
    const y = KZ(t.shape);
    return {
      shape: t.shape,
      keys: m,
      keySet: new Set(m),
      numKeys: m.length,
      optionalKeys: new Set(y)
    };
  });
  We(e._zod, "propValues", () => {
    const m = t.shape, y = {};
    for (const b in m) {
      const x = m[b]._zod;
      if (x.values) {
        y[b] ?? (y[b] = /* @__PURE__ */ new Set());
        for (const w of x.values)
          y[b].add(w);
      }
    }
    return y;
  });
  const i = (m) => {
    const y = new K9(["shape", "payload", "ctx"]), b = n.value, x = (A) => {
      const z = Ol(A);
      return `shape[${z}]._zod.run({ value: input[${z}], issues: [] }, ctx)`;
    };
    y.write("const input = payload.value;");
    const w = /* @__PURE__ */ Object.create(null);
    let k = 0;
    for (const A of b.keys)
      w[A] = `key_${k++}`;
    y.write("const newResult = {}");
    for (const A of b.keys)
      if (b.optionalKeys.has(A)) {
        const z = w[A];
        y.write(`const ${z} = ${x(A)};`);
        const O = Ol(A);
        y.write(`
        if (${z}.issues.length) {
          if (input[${O}] === undefined) {
            if (${O} in input) {
              newResult[${O}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${z}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${O}, ...iss.path] : [${O}],
              }))
            );
          }
        } else if (${z}.value === undefined) {
          if (${O} in input) newResult[${O}] = undefined;
        } else {
          newResult[${O}] = ${z}.value;
        }
        `);
      } else {
        const z = w[A];
        y.write(`const ${z} = ${x(A)};`), y.write(`
          if (${z}.issues.length) payload.issues = payload.issues.concat(${z}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${Ol(A)}, ...iss.path] : [${Ol(A)}]
          })));`), y.write(`newResult[${Ol(A)}] = ${z}.value`);
      }
    y.write("payload.value = newResult;"), y.write("return payload;");
    const T = y.compile();
    return (A, z) => T(m, A, z);
  };
  let r;
  const s = ef, l = !nz.jitless, f = l && JZ.value, h = t.catchall;
  let p;
  e._zod.parse = (m, y) => {
    p ?? (p = n.value);
    const b = m.value;
    if (!s(b))
      return m.issues.push({
        expected: "object",
        code: "invalid_type",
        input: b,
        inst: e
      }), m;
    const x = [];
    if (l && f && y?.async === !1 && y.jitless !== !0)
      r || (r = i(t.shape)), m = r(m, y);
    else {
      m.value = {};
      const z = p.shape;
      for (const O of p.keys) {
        const M = z[O], N = M._zod.run({ value: b[O], issues: [] }, y), U = M._zod.optin === "optional" && M._zod.optout === "optional";
        N instanceof Promise ? x.push(N.then((Z) => U ? ek(Z, m, O, b) : bd(Z, m, O))) : U ? ek(N, m, O, b) : bd(N, m, O);
      }
    }
    if (!h)
      return x.length ? Promise.all(x).then(() => m) : m;
    const w = [], k = p.keySet, T = h._zod, A = T.def.type;
    for (const z of Object.keys(b)) {
      if (k.has(z))
        continue;
      if (A === "never") {
        w.push(z);
        continue;
      }
      const O = T.run({ value: b[z], issues: [] }, y);
      O instanceof Promise ? x.push(O.then((M) => bd(M, m, z))) : bd(O, m, z);
    }
    return w.length && m.issues.push({
      code: "unrecognized_keys",
      keys: w,
      input: b,
      inst: e
    }), x.length ? Promise.all(x).then(() => m) : m;
  };
});
function tk(e, t, n, i) {
  for (const r of e)
    if (r.issues.length === 0)
      return t.value = r.value, t;
  return t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: n,
    errors: e.map((r) => r.issues.map((s) => ia(s, i, ra())))
  }), t;
}
const yz = /* @__PURE__ */ W("$ZodUnion", (e, t) => {
  ct.init(e, t), We(e._zod, "optin", () => t.options.some((n) => n._zod.optin === "optional") ? "optional" : void 0), We(e._zod, "optout", () => t.options.some((n) => n._zod.optout === "optional") ? "optional" : void 0), We(e._zod, "values", () => {
    if (t.options.every((n) => n._zod.values))
      return new Set(t.options.flatMap((n) => Array.from(n._zod.values)));
  }), We(e._zod, "pattern", () => {
    if (t.options.every((n) => n._zod.pattern)) {
      const n = t.options.map((i) => i._zod.pattern);
      return new RegExp(`^(${n.map((i) => py(i.source)).join("|")})$`);
    }
  }), e._zod.parse = (n, i) => {
    let r = !1;
    const s = [];
    for (const l of t.options) {
      const c = l._zod.run({
        value: n.value,
        issues: []
      }, i);
      if (c instanceof Promise)
        s.push(c), r = !0;
      else {
        if (c.issues.length === 0)
          return c;
        s.push(c);
      }
    }
    return r ? Promise.all(s).then((l) => tk(l, n, e, i)) : tk(s, n, e, i);
  };
}), C5 = /* @__PURE__ */ W("$ZodDiscriminatedUnion", (e, t) => {
  yz.init(e, t);
  const n = e._zod.parse;
  We(e._zod, "propValues", () => {
    const r = {};
    for (const s of t.options) {
      const l = s._zod.propValues;
      if (!l || Object.keys(l).length === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(s)}"`);
      for (const [c, f] of Object.entries(l)) {
        r[c] || (r[c] = /* @__PURE__ */ new Set());
        for (const h of f)
          r[c].add(h);
      }
    }
    return r;
  });
  const i = fy(() => {
    const r = t.options, s = /* @__PURE__ */ new Map();
    for (const l of r) {
      const c = l._zod.propValues[t.discriminator];
      if (!c || c.size === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(l)}"`);
      for (const f of c) {
        if (s.has(f))
          throw new Error(`Duplicate discriminator value "${String(f)}"`);
        s.set(f, l);
      }
    }
    return s;
  });
  e._zod.parse = (r, s) => {
    const l = r.value;
    if (!ef(l))
      return r.issues.push({
        code: "invalid_type",
        expected: "object",
        input: l,
        inst: e
      }), r;
    const c = i.value.get(l?.[t.discriminator]);
    return c ? c._zod.run(r, s) : t.unionFallback ? n(r, s) : (r.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input: l,
      path: [t.discriminator],
      inst: e
    }), r);
  };
}), O5 = /* @__PURE__ */ W("$ZodIntersection", (e, t) => {
  ct.init(e, t), e._zod.parse = (n, i) => {
    const r = n.value, s = t.left._zod.run({ value: r, issues: [] }, i), l = t.right._zod.run({ value: r, issues: [] }, i);
    return s instanceof Promise || l instanceof Promise ? Promise.all([s, l]).then(([f, h]) => nk(n, f, h)) : nk(n, s, l);
  };
});
function Vg(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (tf(e) && tf(t)) {
    const n = Object.keys(t), i = Object.keys(e).filter((s) => n.indexOf(s) !== -1), r = { ...e, ...t };
    for (const s of i) {
      const l = Vg(e[s], t[s]);
      if (!l.valid)
        return {
          valid: !1,
          mergeErrorPath: [s, ...l.mergeErrorPath]
        };
      r[s] = l.data;
    }
    return { valid: !0, data: r };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const n = [];
    for (let i = 0; i < e.length; i++) {
      const r = e[i], s = t[i], l = Vg(r, s);
      if (!l.valid)
        return {
          valid: !1,
          mergeErrorPath: [i, ...l.mergeErrorPath]
        };
      n.push(l.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function nk(e, t, n) {
  if (t.issues.length && e.issues.push(...t.issues), n.issues.length && e.issues.push(...n.issues), Hl(e))
    return e;
  const i = Vg(t.value, n.value);
  if (!i.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(i.mergeErrorPath)}`);
  return e.value = i.data, e;
}
const R5 = /* @__PURE__ */ W("$ZodRecord", (e, t) => {
  ct.init(e, t), e._zod.parse = (n, i) => {
    const r = n.value;
    if (!tf(r))
      return n.issues.push({
        expected: "record",
        code: "invalid_type",
        input: r,
        inst: e
      }), n;
    const s = [];
    if (t.keyType._zod.values) {
      const l = t.keyType._zod.values;
      n.value = {};
      for (const f of l)
        if (typeof f == "string" || typeof f == "number" || typeof f == "symbol") {
          const h = t.valueType._zod.run({ value: r[f], issues: [] }, i);
          h instanceof Promise ? s.push(h.then((p) => {
            p.issues.length && n.issues.push(...ja(f, p.issues)), n.value[f] = p.value;
          })) : (h.issues.length && n.issues.push(...ja(f, h.issues)), n.value[f] = h.value);
        }
      let c;
      for (const f in r)
        l.has(f) || (c = c ?? [], c.push(f));
      c && c.length > 0 && n.issues.push({
        code: "unrecognized_keys",
        input: r,
        inst: e,
        keys: c
      });
    } else {
      n.value = {};
      for (const l of Reflect.ownKeys(r)) {
        if (l === "__proto__")
          continue;
        const c = t.keyType._zod.run({ value: l, issues: [] }, i);
        if (c instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (c.issues.length) {
          n.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: c.issues.map((h) => ia(h, i, ra())),
            input: l,
            path: [l],
            inst: e
          }), n.value[c.value] = c.value;
          continue;
        }
        const f = t.valueType._zod.run({ value: r[l], issues: [] }, i);
        f instanceof Promise ? s.push(f.then((h) => {
          h.issues.length && n.issues.push(...ja(l, h.issues)), n.value[c.value] = h.value;
        })) : (f.issues.length && n.issues.push(...ja(l, f.issues)), n.value[c.value] = f.value);
      }
    }
    return s.length ? Promise.all(s).then(() => n) : n;
  };
}), N5 = /* @__PURE__ */ W("$ZodEnum", (e, t) => {
  ct.init(e, t);
  const n = rz(t.entries);
  e._zod.values = new Set(n), e._zod.pattern = new RegExp(`^(${n.filter((i) => XZ.has(typeof i)).map((i) => typeof i == "string" ? $u(i) : i.toString()).join("|")})$`), e._zod.parse = (i, r) => {
    const s = i.value;
    return e._zod.values.has(s) || i.issues.push({
      code: "invalid_value",
      values: n,
      input: s,
      inst: e
    }), i;
  };
}), M5 = /* @__PURE__ */ W("$ZodLiteral", (e, t) => {
  ct.init(e, t), e._zod.values = new Set(t.values), e._zod.pattern = new RegExp(`^(${t.values.map((n) => typeof n == "string" ? $u(n) : n ? n.toString() : String(n)).join("|")})$`), e._zod.parse = (n, i) => {
    const r = n.value;
    return e._zod.values.has(r) || n.issues.push({
      code: "invalid_value",
      values: t.values,
      input: r,
      inst: e
    }), n;
  };
}), D5 = /* @__PURE__ */ W("$ZodTransform", (e, t) => {
  ct.init(e, t), e._zod.parse = (n, i) => {
    const r = t.transform(n.value, n);
    if (i.async)
      return (r instanceof Promise ? r : Promise.resolve(r)).then((l) => (n.value = l, n));
    if (r instanceof Promise)
      throw new ru();
    return n.value = r, n;
  };
}), j5 = /* @__PURE__ */ W("$ZodOptional", (e, t) => {
  ct.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", We(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), We(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${py(n.source)})?$`) : void 0;
  }), e._zod.parse = (n, i) => t.innerType._zod.optin === "optional" ? t.innerType._zod.run(n, i) : n.value === void 0 ? n : t.innerType._zod.run(n, i);
}), P5 = /* @__PURE__ */ W("$ZodNullable", (e, t) => {
  ct.init(e, t), We(e._zod, "optin", () => t.innerType._zod.optin), We(e._zod, "optout", () => t.innerType._zod.optout), We(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${py(n.source)}|null)$`) : void 0;
  }), We(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (n, i) => n.value === null ? n : t.innerType._zod.run(n, i);
}), U5 = /* @__PURE__ */ W("$ZodDefault", (e, t) => {
  ct.init(e, t), e._zod.optin = "optional", We(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, i) => {
    if (n.value === void 0)
      return n.value = t.defaultValue, n;
    const r = t.innerType._zod.run(n, i);
    return r instanceof Promise ? r.then((s) => rk(s, t)) : rk(r, t);
  };
});
function rk(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const L5 = /* @__PURE__ */ W("$ZodPrefault", (e, t) => {
  ct.init(e, t), e._zod.optin = "optional", We(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, i) => (n.value === void 0 && (n.value = t.defaultValue), t.innerType._zod.run(n, i));
}), B5 = /* @__PURE__ */ W("$ZodNonOptional", (e, t) => {
  ct.init(e, t), We(e._zod, "values", () => {
    const n = t.innerType._zod.values;
    return n ? new Set([...n].filter((i) => i !== void 0)) : void 0;
  }), e._zod.parse = (n, i) => {
    const r = t.innerType._zod.run(n, i);
    return r instanceof Promise ? r.then((s) => ik(s, e)) : ik(r, e);
  };
});
function ik(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const Z5 = /* @__PURE__ */ W("$ZodCatch", (e, t) => {
  ct.init(e, t), e._zod.optin = "optional", We(e._zod, "optout", () => t.innerType._zod.optout), We(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, i) => {
    const r = t.innerType._zod.run(n, i);
    return r instanceof Promise ? r.then((s) => (n.value = s.value, s.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: s.issues.map((l) => ia(l, i, ra()))
      },
      input: n.value
    }), n.issues = []), n)) : (n.value = r.value, r.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: r.issues.map((s) => ia(s, i, ra()))
      },
      input: n.value
    }), n.issues = []), n);
  };
}), V5 = /* @__PURE__ */ W("$ZodPipe", (e, t) => {
  ct.init(e, t), We(e._zod, "values", () => t.in._zod.values), We(e._zod, "optin", () => t.in._zod.optin), We(e._zod, "optout", () => t.out._zod.optout), e._zod.parse = (n, i) => {
    const r = t.in._zod.run(n, i);
    return r instanceof Promise ? r.then((s) => ak(s, t, i)) : ak(r, t, i);
  };
});
function ak(e, t, n) {
  return Hl(e) ? e : t.out._zod.run({ value: e.value, issues: e.issues }, n);
}
const F5 = /* @__PURE__ */ W("$ZodReadonly", (e, t) => {
  ct.init(e, t), We(e._zod, "propValues", () => t.innerType._zod.propValues), We(e._zod, "values", () => t.innerType._zod.values), We(e._zod, "optin", () => t.innerType._zod.optin), We(e._zod, "optout", () => t.innerType._zod.optout), e._zod.parse = (n, i) => {
    const r = t.innerType._zod.run(n, i);
    return r instanceof Promise ? r.then(sk) : sk(r);
  };
});
function sk(e) {
  return e.value = Object.freeze(e.value), e;
}
const H5 = /* @__PURE__ */ W("$ZodLazy", (e, t) => {
  ct.init(e, t), We(e._zod, "innerType", () => t.getter()), We(e._zod, "pattern", () => e._zod.innerType._zod.pattern), We(e._zod, "propValues", () => e._zod.innerType._zod.propValues), We(e._zod, "optin", () => e._zod.innerType._zod.optin), We(e._zod, "optout", () => e._zod.innerType._zod.optout), e._zod.parse = (n, i) => e._zod.innerType._zod.run(n, i);
}), q5 = /* @__PURE__ */ W("$ZodCustom", (e, t) => {
  An.init(e, t), ct.init(e, t), e._zod.parse = (n, i) => n, e._zod.check = (n) => {
    const i = n.value, r = t.fn(i);
    if (r instanceof Promise)
      return r.then((s) => ok(s, n, i, e));
    ok(r, n, i, e);
  };
});
function ok(e, t, n, i) {
  if (!e) {
    const r = {
      code: "custom",
      input: n,
      inst: i,
      // incorporates params.error into issue reporting
      path: [...i._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !i._zod.def.abort
      // params: inst._zod.def.params,
    };
    i._zod.def.params && (r.params = i._zod.def.params), t.issues.push(iu(r));
  }
}
let bz = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...n) {
    const i = n[0];
    if (this._map.set(t, i), i && typeof i == "object" && "id" in i) {
      if (this._idmap.has(i.id))
        throw new Error(`ID ${i.id} already exists in the registry`);
      this._idmap.set(i.id, t);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const n = this._map.get(t);
    return n && typeof n == "object" && "id" in n && this._idmap.delete(n.id), this._map.delete(t), this;
  }
  get(t) {
    const n = t._zod.parent;
    if (n) {
      const i = { ...this.get(n) ?? {} };
      return delete i.id, { ...i, ...this._map.get(t) };
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
};
function G5() {
  return new bz();
}
const Ul = /* @__PURE__ */ G5();
function Y5(e, t) {
  return new e({
    type: "string",
    ...xe(t)
  });
}
function J5(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function lk(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function X5(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function K5(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...xe(t)
  });
}
function W5(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...xe(t)
  });
}
function Q5(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...xe(t)
  });
}
function eV(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function tV(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function nV(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function rV(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function iV(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function aV(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function sV(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function oV(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function lV(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function uV(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function cV(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function dV(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function xz(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function fV(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function hV(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function pV(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
function mV(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...xe(t)
  });
}
function gV(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...xe(t)
  });
}
function vV(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...xe(t)
  });
}
function yV(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...xe(t)
  });
}
function bV(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...xe(t)
  });
}
function xV(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...xe(t)
  });
}
function wV(e, t) {
  return new e({
    type: "boolean",
    ...xe(t)
  });
}
function _V(e, t) {
  return new e({
    type: "null",
    ...xe(t)
  });
}
function SV(e) {
  return new e({
    type: "unknown"
  });
}
function kV(e, t) {
  return new e({
    type: "never",
    ...xe(t)
  });
}
function uk(e, t) {
  return new pz({
    check: "less_than",
    ...xe(t),
    value: e,
    inclusive: !1
  });
}
function Zm(e, t) {
  return new pz({
    check: "less_than",
    ...xe(t),
    value: e,
    inclusive: !0
  });
}
function ck(e, t) {
  return new mz({
    check: "greater_than",
    ...xe(t),
    value: e,
    inclusive: !1
  });
}
function Vm(e, t) {
  return new mz({
    check: "greater_than",
    ...xe(t),
    value: e,
    inclusive: !0
  });
}
function dk(e, t) {
  return new U9({
    check: "multiple_of",
    ...xe(t),
    value: e
  });
}
function wz(e, t) {
  return new B9({
    check: "max_length",
    ...xe(t),
    maximum: e
  });
}
function nf(e, t) {
  return new Z9({
    check: "min_length",
    ...xe(t),
    minimum: e
  });
}
function _z(e, t) {
  return new V9({
    check: "length_equals",
    ...xe(t),
    length: e
  });
}
function TV(e, t) {
  return new F9({
    check: "string_format",
    format: "regex",
    ...xe(t),
    pattern: e
  });
}
function EV(e) {
  return new H9({
    check: "string_format",
    format: "lowercase",
    ...xe(e)
  });
}
function $V(e) {
  return new q9({
    check: "string_format",
    format: "uppercase",
    ...xe(e)
  });
}
function AV(e, t) {
  return new G9({
    check: "string_format",
    format: "includes",
    ...xe(t),
    includes: e
  });
}
function zV(e, t) {
  return new Y9({
    check: "string_format",
    format: "starts_with",
    ...xe(t),
    prefix: e
  });
}
function IV(e, t) {
  return new J9({
    check: "string_format",
    format: "ends_with",
    ...xe(t),
    suffix: e
  });
}
function Au(e) {
  return new X9({
    check: "overwrite",
    tx: e
  });
}
function CV(e) {
  return Au((t) => t.normalize(e));
}
function OV() {
  return Au((e) => e.trim());
}
function RV() {
  return Au((e) => e.toLowerCase());
}
function NV() {
  return Au((e) => e.toUpperCase());
}
function MV(e, t, n) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...xe(n)
  });
}
function DV(e, t, n) {
  const i = xe(n);
  return i.abort ?? (i.abort = !0), new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...i
  });
}
function jV(e, t, n) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...xe(n)
  });
}
let fk = class {
  constructor(t) {
    this.counter = 0, this.metadataRegistry = t?.metadata ?? Ul, this.target = t?.target ?? "draft-2020-12", this.unrepresentable = t?.unrepresentable ?? "throw", this.override = t?.override ?? (() => {
    }), this.io = t?.io ?? "output", this.seen = /* @__PURE__ */ new Map();
  }
  process(t, n = { path: [], schemaPath: [] }) {
    var i;
    const r = t._zod.def, s = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    }, l = this.seen.get(t);
    if (l)
      return l.count++, n.schemaPath.includes(t) && (l.cycle = n.path), l.schema;
    const c = { schema: {}, count: 1, cycle: void 0, path: n.path };
    this.seen.set(t, c);
    const f = t._zod.toJSONSchema?.();
    if (f)
      c.schema = f;
    else {
      const m = {
        ...n,
        schemaPath: [...n.schemaPath, t],
        path: n.path
      }, y = t._zod.parent;
      if (y)
        c.ref = y, this.process(y, m), this.seen.get(y).isParent = !0;
      else {
        const b = c.schema;
        switch (r.type) {
          case "string": {
            const x = b;
            x.type = "string";
            const { minimum: w, maximum: k, format: T, patterns: A, contentEncoding: z } = t._zod.bag;
            if (typeof w == "number" && (x.minLength = w), typeof k == "number" && (x.maxLength = k), T && (x.format = s[T] ?? T, x.format === "" && delete x.format), z && (x.contentEncoding = z), A && A.size > 0) {
              const O = [...A];
              O.length === 1 ? x.pattern = O[0].source : O.length > 1 && (c.schema.allOf = [
                ...O.map((M) => ({
                  ...this.target === "draft-7" ? { type: "string" } : {},
                  pattern: M.source
                }))
              ]);
            }
            break;
          }
          case "number": {
            const x = b, { minimum: w, maximum: k, format: T, multipleOf: A, exclusiveMaximum: z, exclusiveMinimum: O } = t._zod.bag;
            typeof T == "string" && T.includes("int") ? x.type = "integer" : x.type = "number", typeof O == "number" && (x.exclusiveMinimum = O), typeof w == "number" && (x.minimum = w, typeof O == "number" && (O >= w ? delete x.minimum : delete x.exclusiveMinimum)), typeof z == "number" && (x.exclusiveMaximum = z), typeof k == "number" && (x.maximum = k, typeof z == "number" && (z <= k ? delete x.maximum : delete x.exclusiveMaximum)), typeof A == "number" && (x.multipleOf = A);
            break;
          }
          case "boolean": {
            const x = b;
            x.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw")
              throw new Error("BigInt cannot be represented in JSON Schema");
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw")
              throw new Error("Symbols cannot be represented in JSON Schema");
            break;
          }
          case "null": {
            b.type = "null";
            break;
          }
          case "any":
            break;
          case "unknown":
            break;
          case "undefined": {
            if (this.unrepresentable === "throw")
              throw new Error("Undefined cannot be represented in JSON Schema");
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw")
              throw new Error("Void cannot be represented in JSON Schema");
            break;
          }
          case "never": {
            b.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw")
              throw new Error("Date cannot be represented in JSON Schema");
            break;
          }
          case "array": {
            const x = b, { minimum: w, maximum: k } = t._zod.bag;
            typeof w == "number" && (x.minItems = w), typeof k == "number" && (x.maxItems = k), x.type = "array", x.items = this.process(r.element, { ...m, path: [...m.path, "items"] });
            break;
          }
          case "object": {
            const x = b;
            x.type = "object", x.properties = {};
            const w = r.shape;
            for (const A in w)
              x.properties[A] = this.process(w[A], {
                ...m,
                path: [...m.path, "properties", A]
              });
            const k = new Set(Object.keys(w)), T = new Set([...k].filter((A) => {
              const z = r.shape[A]._zod;
              return this.io === "input" ? z.optin === void 0 : z.optout === void 0;
            }));
            T.size > 0 && (x.required = Array.from(T)), r.catchall?._zod.def.type === "never" ? x.additionalProperties = !1 : r.catchall ? r.catchall && (x.additionalProperties = this.process(r.catchall, {
              ...m,
              path: [...m.path, "additionalProperties"]
            })) : this.io === "output" && (x.additionalProperties = !1);
            break;
          }
          case "union": {
            const x = b;
            x.anyOf = r.options.map((w, k) => this.process(w, {
              ...m,
              path: [...m.path, "anyOf", k]
            }));
            break;
          }
          case "intersection": {
            const x = b, w = this.process(r.left, {
              ...m,
              path: [...m.path, "allOf", 0]
            }), k = this.process(r.right, {
              ...m,
              path: [...m.path, "allOf", 1]
            }), T = (z) => "allOf" in z && Object.keys(z).length === 1, A = [
              ...T(w) ? w.allOf : [w],
              ...T(k) ? k.allOf : [k]
            ];
            x.allOf = A;
            break;
          }
          case "tuple": {
            const x = b;
            x.type = "array";
            const w = r.items.map((A, z) => this.process(A, { ...m, path: [...m.path, "prefixItems", z] }));
            if (this.target === "draft-2020-12" ? x.prefixItems = w : x.items = w, r.rest) {
              const A = this.process(r.rest, {
                ...m,
                path: [...m.path, "items"]
              });
              this.target === "draft-2020-12" ? x.items = A : x.additionalItems = A;
            }
            r.rest && (x.items = this.process(r.rest, {
              ...m,
              path: [...m.path, "items"]
            }));
            const { minimum: k, maximum: T } = t._zod.bag;
            typeof k == "number" && (x.minItems = k), typeof T == "number" && (x.maxItems = T);
            break;
          }
          case "record": {
            const x = b;
            x.type = "object", x.propertyNames = this.process(r.keyType, { ...m, path: [...m.path, "propertyNames"] }), x.additionalProperties = this.process(r.valueType, {
              ...m,
              path: [...m.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw")
              throw new Error("Map cannot be represented in JSON Schema");
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw")
              throw new Error("Set cannot be represented in JSON Schema");
            break;
          }
          case "enum": {
            const x = b, w = rz(r.entries);
            w.every((k) => typeof k == "number") && (x.type = "number"), w.every((k) => typeof k == "string") && (x.type = "string"), x.enum = w;
            break;
          }
          case "literal": {
            const x = b, w = [];
            for (const k of r.values)
              if (k === void 0) {
                if (this.unrepresentable === "throw")
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
              } else if (typeof k == "bigint") {
                if (this.unrepresentable === "throw")
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                w.push(Number(k));
              } else
                w.push(k);
            if (w.length !== 0) if (w.length === 1) {
              const k = w[0];
              x.type = k === null ? "null" : typeof k, x.const = k;
            } else
              w.every((k) => typeof k == "number") && (x.type = "number"), w.every((k) => typeof k == "string") && (x.type = "string"), w.every((k) => typeof k == "boolean") && (x.type = "string"), w.every((k) => k === null) && (x.type = "null"), x.enum = w;
            break;
          }
          case "file": {
            const x = b, w = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            }, { minimum: k, maximum: T, mime: A } = t._zod.bag;
            k !== void 0 && (w.minLength = k), T !== void 0 && (w.maxLength = T), A ? A.length === 1 ? (w.contentMediaType = A[0], Object.assign(x, w)) : x.anyOf = A.map((z) => ({ ...w, contentMediaType: z })) : Object.assign(x, w);
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw")
              throw new Error("Transforms cannot be represented in JSON Schema");
            break;
          }
          case "nullable": {
            const x = this.process(r.innerType, m);
            b.anyOf = [x, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(r.innerType, m), c.ref = r.innerType;
            break;
          }
          case "success": {
            const x = b;
            x.type = "boolean";
            break;
          }
          case "default": {
            this.process(r.innerType, m), c.ref = r.innerType, b.default = JSON.parse(JSON.stringify(r.defaultValue));
            break;
          }
          case "prefault": {
            this.process(r.innerType, m), c.ref = r.innerType, this.io === "input" && (b._prefault = JSON.parse(JSON.stringify(r.defaultValue)));
            break;
          }
          case "catch": {
            this.process(r.innerType, m), c.ref = r.innerType;
            let x;
            try {
              x = r.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            b.default = x;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw")
              throw new Error("NaN cannot be represented in JSON Schema");
            break;
          }
          case "template_literal": {
            const x = b, w = t._zod.pattern;
            if (!w)
              throw new Error("Pattern not found in template literal");
            x.type = "string", x.pattern = w.source;
            break;
          }
          case "pipe": {
            const x = this.io === "input" ? r.in._zod.def.type === "transform" ? r.out : r.in : r.out;
            this.process(x, m), c.ref = x;
            break;
          }
          case "readonly": {
            this.process(r.innerType, m), c.ref = r.innerType, b.readOnly = !0;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(r.innerType, m), c.ref = r.innerType;
            break;
          }
          case "optional": {
            this.process(r.innerType, m), c.ref = r.innerType;
            break;
          }
          case "lazy": {
            const x = t._zod.innerType;
            this.process(x, m), c.ref = x;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw")
              throw new Error("Custom types cannot be represented in JSON Schema");
            break;
          }
        }
      }
    }
    const h = this.metadataRegistry.get(t);
    return h && Object.assign(c.schema, h), this.io === "input" && Bt(t) && (delete c.schema.examples, delete c.schema.default), this.io === "input" && c.schema._prefault && ((i = c.schema).default ?? (i.default = c.schema._prefault)), delete c.schema._prefault, this.seen.get(t).schema;
  }
  emit(t, n) {
    const i = {
      cycles: n?.cycles ?? "ref",
      reused: n?.reused ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: n?.external ?? void 0
    }, r = this.seen.get(t);
    if (!r)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const s = (p) => {
      const m = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (i.external) {
        const w = i.external.registry.get(p[0])?.id, k = i.external.uri ?? ((A) => A);
        if (w)
          return { ref: k(w) };
        const T = p[1].defId ?? p[1].schema.id ?? `schema${this.counter++}`;
        return p[1].defId = T, { defId: T, ref: `${k("__shared")}#/${m}/${T}` };
      }
      if (p[1] === r)
        return { ref: "#" };
      const b = `#/${m}/`, x = p[1].schema.id ?? `__schema${this.counter++}`;
      return { defId: x, ref: b + x };
    }, l = (p) => {
      if (p[1].schema.$ref)
        return;
      const m = p[1], { ref: y, defId: b } = s(p);
      m.def = { ...m.schema }, b && (m.defId = b);
      const x = m.schema;
      for (const w in x)
        delete x[w];
      x.$ref = y;
    };
    if (i.cycles === "throw")
      for (const p of this.seen.entries()) {
        const m = p[1];
        if (m.cycle)
          throw new Error(`Cycle detected: #/${m.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    for (const p of this.seen.entries()) {
      const m = p[1];
      if (t === p[0]) {
        l(p);
        continue;
      }
      if (i.external) {
        const b = i.external.registry.get(p[0])?.id;
        if (t !== p[0] && b) {
          l(p);
          continue;
        }
      }
      if (this.metadataRegistry.get(p[0])?.id) {
        l(p);
        continue;
      }
      if (m.cycle) {
        l(p);
        continue;
      }
      if (m.count > 1 && i.reused === "ref") {
        l(p);
        continue;
      }
    }
    const c = (p, m) => {
      const y = this.seen.get(p), b = y.def ?? y.schema, x = { ...b };
      if (y.ref === null)
        return;
      const w = y.ref;
      if (y.ref = null, w) {
        c(w, m);
        const k = this.seen.get(w).schema;
        k.$ref && m.target === "draft-7" ? (b.allOf = b.allOf ?? [], b.allOf.push(k)) : (Object.assign(b, k), Object.assign(b, x));
      }
      y.isParent || this.override({
        zodSchema: p,
        jsonSchema: b,
        path: y.path ?? []
      });
    };
    for (const p of [...this.seen.entries()].reverse())
      c(p[0], { target: this.target });
    const f = {};
    if (this.target === "draft-2020-12" ? f.$schema = "https://json-schema.org/draft/2020-12/schema" : this.target === "draft-7" ? f.$schema = "http://json-schema.org/draft-07/schema#" : console.warn(`Invalid target: ${this.target}`), i.external?.uri) {
      const p = i.external.registry.get(t)?.id;
      if (!p)
        throw new Error("Schema is missing an `id` property");
      f.$id = i.external.uri(p);
    }
    Object.assign(f, r.def);
    const h = i.external?.defs ?? {};
    for (const p of this.seen.entries()) {
      const m = p[1];
      m.def && m.defId && (h[m.defId] = m.def);
    }
    i.external || Object.keys(h).length > 0 && (this.target === "draft-2020-12" ? f.$defs = h : f.definitions = h);
    try {
      return JSON.parse(JSON.stringify(f));
    } catch {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function PV(e, t) {
  if (e instanceof bz) {
    const i = new fk(t), r = {};
    for (const c of e._idmap.entries()) {
      const [f, h] = c;
      i.process(h);
    }
    const s = {}, l = {
      registry: e,
      uri: t?.uri,
      defs: r
    };
    for (const c of e._idmap.entries()) {
      const [f, h] = c;
      s[f] = i.emit(h, {
        ...t,
        external: l
      });
    }
    if (Object.keys(r).length > 0) {
      const c = i.target === "draft-2020-12" ? "$defs" : "definitions";
      s.__shared = {
        [c]: r
      };
    }
    return { schemas: s };
  }
  const n = new fk(t);
  return n.process(e), n.emit(e, t);
}
function Bt(e, t) {
  const n = t ?? { seen: /* @__PURE__ */ new Set() };
  if (n.seen.has(e))
    return !1;
  n.seen.add(e);
  const r = e._zod.def;
  switch (r.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return !1;
    case "array":
      return Bt(r.element, n);
    case "object": {
      for (const s in r.shape)
        if (Bt(r.shape[s], n))
          return !0;
      return !1;
    }
    case "union": {
      for (const s of r.options)
        if (Bt(s, n))
          return !0;
      return !1;
    }
    case "intersection":
      return Bt(r.left, n) || Bt(r.right, n);
    case "tuple": {
      for (const s of r.items)
        if (Bt(s, n))
          return !0;
      return !!(r.rest && Bt(r.rest, n));
    }
    case "record":
      return Bt(r.keyType, n) || Bt(r.valueType, n);
    case "map":
      return Bt(r.keyType, n) || Bt(r.valueType, n);
    case "set":
      return Bt(r.valueType, n);
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return Bt(r.innerType, n);
    case "lazy":
      return Bt(r.getter(), n);
    case "default":
      return Bt(r.innerType, n);
    case "prefault":
      return Bt(r.innerType, n);
    case "custom":
      return !1;
    case "transform":
      return !0;
    case "pipe":
      return Bt(r.in, n) || Bt(r.out, n);
    case "success":
      return !1;
    case "catch":
      return !1;
  }
  throw new Error(`Unknown schema type: ${r.type}`);
}
const UV = /* @__PURE__ */ W("ZodISODateTime", (e, t) => {
  c5.init(e, t), St.init(e, t);
});
function LV(e) {
  return mV(UV, e);
}
const BV = /* @__PURE__ */ W("ZodISODate", (e, t) => {
  d5.init(e, t), St.init(e, t);
});
function ZV(e) {
  return gV(BV, e);
}
const VV = /* @__PURE__ */ W("ZodISOTime", (e, t) => {
  f5.init(e, t), St.init(e, t);
});
function FV(e) {
  return vV(VV, e);
}
const HV = /* @__PURE__ */ W("ZodISODuration", (e, t) => {
  h5.init(e, t), St.init(e, t);
});
function qV(e) {
  return yV(HV, e);
}
const GV = (e, t) => {
  sz.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (n) => s9(e, n)
      // enumerable: false,
    },
    flatten: {
      value: (n) => a9(e, n)
      // enumerable: false,
    },
    addIssue: {
      value: (n) => e.issues.push(n)
      // enumerable: false,
    },
    addIssues: {
      value: (n) => e.issues.push(...n)
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, jf = /* @__PURE__ */ W("ZodError", GV, {
  Parent: Error
}), YV = /* @__PURE__ */ o9(jf), JV = /* @__PURE__ */ l9(jf), XV = /* @__PURE__ */ lz(jf), Sz = /* @__PURE__ */ uz(jf), bt = /* @__PURE__ */ W("ZodType", (e, t) => (ct.init(e, t), e.def = t, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone(
  {
    ...t,
    checks: [
      ...t.checks ?? [],
      ...n.map((i) => typeof i == "function" ? { _zod: { check: i, def: { check: "custom" }, onattach: [] } } : i)
    ]
  }
  // { parent: true }
), e.clone = (n, i) => Qa(e, n, i), e.brand = () => e, e.register = ((n, i) => (n.add(e, i), e)), e.parse = (n, i) => YV(e, n, i, { callee: e.parse }), e.safeParse = (n, i) => XV(e, n, i), e.parseAsync = async (n, i) => JV(e, n, i, { callee: e.parseAsync }), e.safeParseAsync = async (n, i) => Sz(e, n, i), e.spa = e.safeParseAsync, e.refine = (n, i) => e.check(FF(n, i)), e.superRefine = (n) => e.check(HF(n)), e.overwrite = (n) => e.check(Au(n)), e.optional = () => jt(e), e.nullable = () => mk(e), e.nullish = () => jt(mk(e)), e.nonoptional = (n) => NF(e, n), e.array = () => Si(e), e.or = (n) => Vt([e, n]), e.and = (n) => kF(e, n), e.transform = (n) => gk(e, AF(n)), e.default = (n) => CF(e, n), e.prefault = (n) => RF(e, n), e.catch = (n) => DF(e, n), e.pipe = (n) => gk(e, n), e.readonly = () => UF(e), e.describe = (n) => {
  const i = e.clone();
  return Ul.add(i, { description: n }), i;
}, Object.defineProperty(e, "description", {
  get() {
    return Ul.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...n) => {
  if (n.length === 0)
    return Ul.get(e);
  const i = e.clone();
  return Ul.add(i, n[0]), i;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e)), kz = /* @__PURE__ */ W("_ZodString", (e, t) => {
  gy.init(e, t), bt.init(e, t);
  const n = e._zod.bag;
  e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...i) => e.check(TV(...i)), e.includes = (...i) => e.check(AV(...i)), e.startsWith = (...i) => e.check(zV(...i)), e.endsWith = (...i) => e.check(IV(...i)), e.min = (...i) => e.check(nf(...i)), e.max = (...i) => e.check(wz(...i)), e.length = (...i) => e.check(_z(...i)), e.nonempty = (...i) => e.check(nf(1, ...i)), e.lowercase = (i) => e.check(EV(i)), e.uppercase = (i) => e.check($V(i)), e.trim = () => e.check(OV()), e.normalize = (...i) => e.check(CV(...i)), e.toLowerCase = () => e.check(RV()), e.toUpperCase = () => e.check(NV());
}), KV = /* @__PURE__ */ W("ZodString", (e, t) => {
  gy.init(e, t), kz.init(e, t), e.email = (n) => e.check(J5(WV, n)), e.url = (n) => e.check(eV(QV, n)), e.jwt = (n) => e.check(pV(hF, n)), e.emoji = (n) => e.check(tV(eF, n)), e.guid = (n) => e.check(lk(hk, n)), e.uuid = (n) => e.check(X5(xd, n)), e.uuidv4 = (n) => e.check(K5(xd, n)), e.uuidv6 = (n) => e.check(W5(xd, n)), e.uuidv7 = (n) => e.check(Q5(xd, n)), e.nanoid = (n) => e.check(nV(tF, n)), e.guid = (n) => e.check(lk(hk, n)), e.cuid = (n) => e.check(rV(nF, n)), e.cuid2 = (n) => e.check(iV(rF, n)), e.ulid = (n) => e.check(aV(iF, n)), e.base64 = (n) => e.check(xz(Tz, n)), e.base64url = (n) => e.check(fV(dF, n)), e.xid = (n) => e.check(sV(aF, n)), e.ksuid = (n) => e.check(oV(sF, n)), e.ipv4 = (n) => e.check(lV(oF, n)), e.ipv6 = (n) => e.check(uV(lF, n)), e.cidrv4 = (n) => e.check(cV(uF, n)), e.cidrv6 = (n) => e.check(dV(cF, n)), e.e164 = (n) => e.check(hV(fF, n)), e.datetime = (n) => e.check(LV(n)), e.date = (n) => e.check(ZV(n)), e.time = (n) => e.check(FV(n)), e.duration = (n) => e.check(qV(n));
});
function te(e) {
  return Y5(KV, e);
}
const St = /* @__PURE__ */ W("ZodStringFormat", (e, t) => {
  yt.init(e, t), kz.init(e, t);
}), WV = /* @__PURE__ */ W("ZodEmail", (e, t) => {
  t5.init(e, t), St.init(e, t);
}), hk = /* @__PURE__ */ W("ZodGUID", (e, t) => {
  Q9.init(e, t), St.init(e, t);
}), xd = /* @__PURE__ */ W("ZodUUID", (e, t) => {
  e5.init(e, t), St.init(e, t);
}), QV = /* @__PURE__ */ W("ZodURL", (e, t) => {
  n5.init(e, t), St.init(e, t);
}), eF = /* @__PURE__ */ W("ZodEmoji", (e, t) => {
  r5.init(e, t), St.init(e, t);
}), tF = /* @__PURE__ */ W("ZodNanoID", (e, t) => {
  i5.init(e, t), St.init(e, t);
}), nF = /* @__PURE__ */ W("ZodCUID", (e, t) => {
  a5.init(e, t), St.init(e, t);
}), rF = /* @__PURE__ */ W("ZodCUID2", (e, t) => {
  s5.init(e, t), St.init(e, t);
}), iF = /* @__PURE__ */ W("ZodULID", (e, t) => {
  o5.init(e, t), St.init(e, t);
}), aF = /* @__PURE__ */ W("ZodXID", (e, t) => {
  l5.init(e, t), St.init(e, t);
}), sF = /* @__PURE__ */ W("ZodKSUID", (e, t) => {
  u5.init(e, t), St.init(e, t);
}), oF = /* @__PURE__ */ W("ZodIPv4", (e, t) => {
  p5.init(e, t), St.init(e, t);
}), lF = /* @__PURE__ */ W("ZodIPv6", (e, t) => {
  m5.init(e, t), St.init(e, t);
}), uF = /* @__PURE__ */ W("ZodCIDRv4", (e, t) => {
  g5.init(e, t), St.init(e, t);
}), cF = /* @__PURE__ */ W("ZodCIDRv6", (e, t) => {
  v5.init(e, t), St.init(e, t);
}), Tz = /* @__PURE__ */ W("ZodBase64", (e, t) => {
  y5.init(e, t), St.init(e, t);
});
function Ez(e) {
  return xz(Tz, e);
}
const dF = /* @__PURE__ */ W("ZodBase64URL", (e, t) => {
  x5.init(e, t), St.init(e, t);
}), fF = /* @__PURE__ */ W("ZodE164", (e, t) => {
  w5.init(e, t), St.init(e, t);
}), hF = /* @__PURE__ */ W("ZodJWT", (e, t) => {
  S5.init(e, t), St.init(e, t);
}), $z = /* @__PURE__ */ W("ZodNumber", (e, t) => {
  vz.init(e, t), bt.init(e, t), e.gt = (i, r) => e.check(ck(i, r)), e.gte = (i, r) => e.check(Vm(i, r)), e.min = (i, r) => e.check(Vm(i, r)), e.lt = (i, r) => e.check(uk(i, r)), e.lte = (i, r) => e.check(Zm(i, r)), e.max = (i, r) => e.check(Zm(i, r)), e.int = (i) => e.check(pk(i)), e.safe = (i) => e.check(pk(i)), e.positive = (i) => e.check(ck(0, i)), e.nonnegative = (i) => e.check(Vm(0, i)), e.negative = (i) => e.check(uk(0, i)), e.nonpositive = (i) => e.check(Zm(0, i)), e.multipleOf = (i, r) => e.check(dk(i, r)), e.step = (i, r) => e.check(dk(i, r)), e.finite = () => e;
  const n = e._zod.bag;
  e.minValue = Math.max(n.minimum ?? Number.NEGATIVE_INFINITY, n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(n.maximum ?? Number.POSITIVE_INFINITY, n.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (n.format ?? "").includes("int") || Number.isSafeInteger(n.multipleOf ?? 0.5), e.isFinite = !0, e.format = n.format ?? null;
});
function au(e) {
  return bV($z, e);
}
const pF = /* @__PURE__ */ W("ZodNumberFormat", (e, t) => {
  k5.init(e, t), $z.init(e, t);
});
function pk(e) {
  return xV(pF, e);
}
const mF = /* @__PURE__ */ W("ZodBoolean", (e, t) => {
  T5.init(e, t), bt.init(e, t);
});
function Ot(e) {
  return wV(mF, e);
}
const gF = /* @__PURE__ */ W("ZodNull", (e, t) => {
  E5.init(e, t), bt.init(e, t);
});
function vF(e) {
  return _V(gF, e);
}
const yF = /* @__PURE__ */ W("ZodUnknown", (e, t) => {
  $5.init(e, t), bt.init(e, t);
});
function pt() {
  return SV(yF);
}
const bF = /* @__PURE__ */ W("ZodNever", (e, t) => {
  A5.init(e, t), bt.init(e, t);
});
function Tn(e) {
  return kV(bF, e);
}
const xF = /* @__PURE__ */ W("ZodArray", (e, t) => {
  z5.init(e, t), bt.init(e, t), e.element = t.element, e.min = (n, i) => e.check(nf(n, i)), e.nonempty = (n) => e.check(nf(1, n)), e.max = (n, i) => e.check(wz(n, i)), e.length = (n, i) => e.check(_z(n, i)), e.unwrap = () => e.element;
});
function Si(e, t) {
  return MV(xF, e, t);
}
const vy = /* @__PURE__ */ W("ZodObject", (e, t) => {
  I5.init(e, t), bt.init(e, t), We(e, "shape", () => t.shape), e.keyof = () => Pf(Object.keys(e._zod.def.shape)), e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: pt() }), e.loose = () => e.clone({ ...e._zod.def, catchall: pt() }), e.strict = () => e.clone({ ...e._zod.def, catchall: Tn() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (n) => t9(e, n), e.merge = (n) => n9(e, n), e.pick = (n) => QZ(e, n), e.omit = (n) => e9(e, n), e.partial = (...n) => r9(zz, e, n[0]), e.required = (...n) => i9(Iz, e, n[0]);
});
function Ee(e, t) {
  const n = {
    type: "object",
    get shape() {
      return Eu(this, "shape", { ...e }), this.shape;
    },
    ...xe(t)
  };
  return new vy(n);
}
function ft(e, t) {
  return new vy({
    type: "object",
    get shape() {
      return Eu(this, "shape", { ...e }), this.shape;
    },
    catchall: Tn(),
    ...xe(t)
  });
}
function Ks(e, t) {
  return new vy({
    type: "object",
    get shape() {
      return Eu(this, "shape", { ...e }), this.shape;
    },
    catchall: pt(),
    ...xe(t)
  });
}
const Az = /* @__PURE__ */ W("ZodUnion", (e, t) => {
  yz.init(e, t), bt.init(e, t), e.options = t.options;
});
function Vt(e, t) {
  return new Az({
    type: "union",
    options: e,
    ...xe(t)
  });
}
const wF = /* @__PURE__ */ W("ZodDiscriminatedUnion", (e, t) => {
  Az.init(e, t), C5.init(e, t);
});
function _F(e, t, n) {
  return new wF({
    type: "union",
    options: t,
    discriminator: e,
    ...xe(n)
  });
}
const SF = /* @__PURE__ */ W("ZodIntersection", (e, t) => {
  O5.init(e, t), bt.init(e, t);
});
function kF(e, t) {
  return new SF({
    type: "intersection",
    left: e,
    right: t
  });
}
const TF = /* @__PURE__ */ W("ZodRecord", (e, t) => {
  R5.init(e, t), bt.init(e, t), e.keyType = t.keyType, e.valueType = t.valueType;
});
function Fg(e, t, n) {
  return new TF({
    type: "record",
    keyType: e,
    valueType: t,
    ...xe(n)
  });
}
const Hg = /* @__PURE__ */ W("ZodEnum", (e, t) => {
  N5.init(e, t), bt.init(e, t), e.enum = t.entries, e.options = Object.values(t.entries);
  const n = new Set(Object.keys(t.entries));
  e.extract = (i, r) => {
    const s = {};
    for (const l of i)
      if (n.has(l))
        s[l] = t.entries[l];
      else
        throw new Error(`Key ${l} not found in enum`);
    return new Hg({
      ...t,
      checks: [],
      ...xe(r),
      entries: s
    });
  }, e.exclude = (i, r) => {
    const s = { ...t.entries };
    for (const l of i)
      if (n.has(l))
        delete s[l];
      else
        throw new Error(`Key ${l} not found in enum`);
    return new Hg({
      ...t,
      checks: [],
      ...xe(r),
      entries: s
    });
  };
});
function Pf(e, t) {
  const n = Array.isArray(e) ? Object.fromEntries(e.map((i) => [i, i])) : e;
  return new Hg({
    type: "enum",
    entries: n,
    ...xe(t)
  });
}
const EF = /* @__PURE__ */ W("ZodLiteral", (e, t) => {
  M5.init(e, t), bt.init(e, t), e.values = new Set(t.values), Object.defineProperty(e, "value", {
    get() {
      if (t.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return t.values[0];
    }
  });
});
function me(e, t) {
  return new EF({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...xe(t)
  });
}
const $F = /* @__PURE__ */ W("ZodTransform", (e, t) => {
  D5.init(e, t), bt.init(e, t), e._zod.parse = (n, i) => {
    n.addIssue = (s) => {
      if (typeof s == "string")
        n.issues.push(iu(s, n.value, t));
      else {
        const l = s;
        l.fatal && (l.continue = !1), l.code ?? (l.code = "custom"), l.input ?? (l.input = n.value), l.inst ?? (l.inst = e), l.continue ?? (l.continue = !0), n.issues.push(iu(l));
      }
    };
    const r = t.transform(n.value, n);
    return r instanceof Promise ? r.then((s) => (n.value = s, n)) : (n.value = r, n);
  };
});
function AF(e) {
  return new $F({
    type: "transform",
    transform: e
  });
}
const zz = /* @__PURE__ */ W("ZodOptional", (e, t) => {
  j5.init(e, t), bt.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function jt(e) {
  return new zz({
    type: "optional",
    innerType: e
  });
}
const zF = /* @__PURE__ */ W("ZodNullable", (e, t) => {
  P5.init(e, t), bt.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function mk(e) {
  return new zF({
    type: "nullable",
    innerType: e
  });
}
const IF = /* @__PURE__ */ W("ZodDefault", (e, t) => {
  U5.init(e, t), bt.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function CF(e, t) {
  return new IF({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : t;
    }
  });
}
const OF = /* @__PURE__ */ W("ZodPrefault", (e, t) => {
  L5.init(e, t), bt.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function RF(e, t) {
  return new OF({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : t;
    }
  });
}
const Iz = /* @__PURE__ */ W("ZodNonOptional", (e, t) => {
  B5.init(e, t), bt.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function NF(e, t) {
  return new Iz({
    type: "nonoptional",
    innerType: e,
    ...xe(t)
  });
}
const MF = /* @__PURE__ */ W("ZodCatch", (e, t) => {
  Z5.init(e, t), bt.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function DF(e, t) {
  return new MF({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const jF = /* @__PURE__ */ W("ZodPipe", (e, t) => {
  V5.init(e, t), bt.init(e, t), e.in = t.in, e.out = t.out;
});
function gk(e, t) {
  return new jF({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const PF = /* @__PURE__ */ W("ZodReadonly", (e, t) => {
  F5.init(e, t), bt.init(e, t);
});
function UF(e) {
  return new PF({
    type: "readonly",
    innerType: e
  });
}
const LF = /* @__PURE__ */ W("ZodLazy", (e, t) => {
  H5.init(e, t), bt.init(e, t), e.unwrap = () => e._zod.def.getter();
});
function BF(e) {
  return new LF({
    type: "lazy",
    getter: e
  });
}
const yy = /* @__PURE__ */ W("ZodCustom", (e, t) => {
  q5.init(e, t), bt.init(e, t);
});
function ZF(e) {
  const t = new An({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  return t._zod.check = e, t;
}
function VF(e, t) {
  return DV(yy, e ?? (() => !0), t);
}
function FF(e, t = {}) {
  return jV(yy, e, t);
}
function HF(e) {
  const t = ZF((n) => (n.addIssue = (i) => {
    if (typeof i == "string")
      n.issues.push(iu(i, n.value, t._zod.def));
    else {
      const r = i;
      r.fatal && (r.continue = !1), r.code ?? (r.code = "custom"), r.input ?? (r.input = n.value), r.inst ?? (r.inst = t), r.continue ?? (r.continue = !t._zod.def.abort), n.issues.push(iu(r));
    }
  }, e(n.value, n)));
  return t;
}
function rf(e, t = {
  error: `Input not instance of ${e.name}`
}) {
  const n = new yy({
    type: "custom",
    check: "custom",
    fn: (i) => i instanceof e,
    abort: !0,
    ...xe(t)
  });
  return n._zod.bag.Class = e, n;
}
const qF = Symbol("Let zodToJsonSchema decide on which parser to use"), vk = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: !0,
  rejectedAdditionalProperties: !1,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
}, GF = (e) => typeof e == "string" ? {
  ...vk,
  name: e
} : {
  ...vk,
  ...e
}, YF = (e) => {
  const t = GF(e), n = t.name !== void 0 ? [...t.basePath, t.definitionPath, t.name] : t.basePath;
  return {
    ...t,
    flags: { hasReferencedOpenAiAnyType: !1 },
    currentPath: n,
    propertyPath: void 0,
    seen: new Map(Object.entries(t.definitions).map(([i, r]) => [
      r._def,
      {
        def: r._def,
        path: [...t.basePath, t.definitionPath, i],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function Cz(e, t, n, i) {
  i?.errorMessages && n && (e.errorMessage = {
    ...e.errorMessage,
    [t]: n
  });
}
function nt(e, t, n, i, r) {
  e[t] = n, Cz(e, t, i, r);
}
const Oz = (e, t) => {
  let n = 0;
  for (; n < e.length && n < t.length && e[n] === t[n]; n++)
    ;
  return [(e.length - n).toString(), ...t.slice(n)].join("/");
};
var Oe;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Oe || (Oe = {}));
function $n(e) {
  if (e.target !== "openAi")
    return {};
  const t = [
    ...e.basePath,
    e.definitionPath,
    e.openAiAnyTypeName
  ];
  return e.flags.hasReferencedOpenAiAnyType = !0, {
    $ref: e.$refStrategy === "relative" ? Oz(t, e.currentPath) : t.join("/")
  };
}
function JF(e, t) {
  const n = {
    type: "array"
  };
  return e.type?._def && e.type?._def?.typeName !== Oe.ZodAny && (n.items = Ke(e.type._def, {
    ...t,
    currentPath: [...t.currentPath, "items"]
  })), e.minLength && nt(n, "minItems", e.minLength.value, e.minLength.message, t), e.maxLength && nt(n, "maxItems", e.maxLength.value, e.maxLength.message, t), e.exactLength && (nt(n, "minItems", e.exactLength.value, e.exactLength.message, t), nt(n, "maxItems", e.exactLength.value, e.exactLength.message, t)), n;
}
function XF(e, t) {
  const n = {
    type: "integer",
    format: "int64"
  };
  if (!e.checks)
    return n;
  for (const i of e.checks)
    switch (i.kind) {
      case "min":
        t.target === "jsonSchema7" ? i.inclusive ? nt(n, "minimum", i.value, i.message, t) : nt(n, "exclusiveMinimum", i.value, i.message, t) : (i.inclusive || (n.exclusiveMinimum = !0), nt(n, "minimum", i.value, i.message, t));
        break;
      case "max":
        t.target === "jsonSchema7" ? i.inclusive ? nt(n, "maximum", i.value, i.message, t) : nt(n, "exclusiveMaximum", i.value, i.message, t) : (i.inclusive || (n.exclusiveMaximum = !0), nt(n, "maximum", i.value, i.message, t));
        break;
      case "multipleOf":
        nt(n, "multipleOf", i.value, i.message, t);
        break;
    }
  return n;
}
function KF() {
  return {
    type: "boolean"
  };
}
function Rz(e, t) {
  return Ke(e.type._def, t);
}
const WF = (e, t) => Ke(e.innerType._def, t);
function Nz(e, t, n) {
  const i = n ?? t.dateStrategy;
  if (Array.isArray(i))
    return {
      anyOf: i.map((r, s) => Nz(e, t, r))
    };
  switch (i) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return QF(e, t);
  }
}
const QF = (e, t) => {
  const n = {
    type: "integer",
    format: "unix-time"
  };
  if (t.target === "openApi3")
    return n;
  for (const i of e.checks)
    switch (i.kind) {
      case "min":
        nt(
          n,
          "minimum",
          i.value,
          // This is in milliseconds
          i.message,
          t
        );
        break;
      case "max":
        nt(
          n,
          "maximum",
          i.value,
          // This is in milliseconds
          i.message,
          t
        );
        break;
    }
  return n;
};
function e8(e, t) {
  return {
    ...Ke(e.innerType._def, t),
    default: e.defaultValue()
  };
}
function t8(e, t) {
  return t.effectStrategy === "input" ? Ke(e.schema._def, t) : $n(t);
}
function n8(e) {
  return {
    type: "string",
    enum: Array.from(e.values)
  };
}
const r8 = (e) => "type" in e && e.type === "string" ? !1 : "allOf" in e;
function i8(e, t) {
  const n = [
    Ke(e.left._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "0"]
    }),
    Ke(e.right._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "1"]
    })
  ].filter((s) => !!s);
  let i = t.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const r = [];
  return n.forEach((s) => {
    if (r8(s))
      r.push(...s.allOf), s.unevaluatedProperties === void 0 && (i = void 0);
    else {
      let l = s;
      if ("additionalProperties" in s && s.additionalProperties === !1) {
        const { additionalProperties: c, ...f } = s;
        l = f;
      } else
        i = void 0;
      r.push(l);
    }
  }), r.length ? {
    allOf: r,
    ...i
  } : void 0;
}
function a8(e, t) {
  const n = typeof e.value;
  return n !== "bigint" && n !== "number" && n !== "boolean" && n !== "string" ? {
    type: Array.isArray(e.value) ? "array" : "object"
  } : t.target === "openApi3" ? {
    type: n === "bigint" ? "integer" : n,
    enum: [e.value]
  } : {
    type: n === "bigint" ? "integer" : n,
    const: e.value
  };
}
let Fm;
const vr = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (Fm === void 0 && (Fm = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), Fm),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function Mz(e, t) {
  const n = {
    type: "string"
  };
  if (e.checks)
    for (const i of e.checks)
      switch (i.kind) {
        case "min":
          nt(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, i.value) : i.value, i.message, t);
          break;
        case "max":
          nt(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, i.value) : i.value, i.message, t);
          break;
        case "email":
          switch (t.emailStrategy) {
            case "format:email":
              yr(n, "email", i.message, t);
              break;
            case "format:idn-email":
              yr(n, "idn-email", i.message, t);
              break;
            case "pattern:zod":
              fn(n, vr.email, i.message, t);
              break;
          }
          break;
        case "url":
          yr(n, "uri", i.message, t);
          break;
        case "uuid":
          yr(n, "uuid", i.message, t);
          break;
        case "regex":
          fn(n, i.regex, i.message, t);
          break;
        case "cuid":
          fn(n, vr.cuid, i.message, t);
          break;
        case "cuid2":
          fn(n, vr.cuid2, i.message, t);
          break;
        case "startsWith":
          fn(n, RegExp(`^${Hm(i.value, t)}`), i.message, t);
          break;
        case "endsWith":
          fn(n, RegExp(`${Hm(i.value, t)}$`), i.message, t);
          break;
        case "datetime":
          yr(n, "date-time", i.message, t);
          break;
        case "date":
          yr(n, "date", i.message, t);
          break;
        case "time":
          yr(n, "time", i.message, t);
          break;
        case "duration":
          yr(n, "duration", i.message, t);
          break;
        case "length":
          nt(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, i.value) : i.value, i.message, t), nt(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, i.value) : i.value, i.message, t);
          break;
        case "includes": {
          fn(n, RegExp(Hm(i.value, t)), i.message, t);
          break;
        }
        case "ip": {
          i.version !== "v6" && yr(n, "ipv4", i.message, t), i.version !== "v4" && yr(n, "ipv6", i.message, t);
          break;
        }
        case "base64url":
          fn(n, vr.base64url, i.message, t);
          break;
        case "jwt":
          fn(n, vr.jwt, i.message, t);
          break;
        case "cidr": {
          i.version !== "v6" && fn(n, vr.ipv4Cidr, i.message, t), i.version !== "v4" && fn(n, vr.ipv6Cidr, i.message, t);
          break;
        }
        case "emoji":
          fn(n, vr.emoji(), i.message, t);
          break;
        case "ulid": {
          fn(n, vr.ulid, i.message, t);
          break;
        }
        case "base64": {
          switch (t.base64Strategy) {
            case "format:binary": {
              yr(n, "binary", i.message, t);
              break;
            }
            case "contentEncoding:base64": {
              nt(n, "contentEncoding", "base64", i.message, t);
              break;
            }
            case "pattern:zod": {
              fn(n, vr.base64, i.message, t);
              break;
            }
          }
          break;
        }
        case "nanoid":
          fn(n, vr.nanoid, i.message, t);
      }
  return n;
}
function Hm(e, t) {
  return t.patternStrategy === "escape" ? o8(e) : e;
}
const s8 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function o8(e) {
  let t = "";
  for (let n = 0; n < e.length; n++)
    s8.has(e[n]) || (t += "\\"), t += e[n];
  return t;
}
function yr(e, t, n, i) {
  e.format || e.anyOf?.some((r) => r.format) ? (e.anyOf || (e.anyOf = []), e.format && (e.anyOf.push({
    format: e.format,
    ...e.errorMessage && i.errorMessages && {
      errorMessage: { format: e.errorMessage.format }
    }
  }), delete e.format, e.errorMessage && (delete e.errorMessage.format, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.anyOf.push({
    format: t,
    ...n && i.errorMessages && { errorMessage: { format: n } }
  })) : nt(e, "format", t, n, i);
}
function fn(e, t, n, i) {
  e.pattern || e.allOf?.some((r) => r.pattern) ? (e.allOf || (e.allOf = []), e.pattern && (e.allOf.push({
    pattern: e.pattern,
    ...e.errorMessage && i.errorMessages && {
      errorMessage: { pattern: e.errorMessage.pattern }
    }
  }), delete e.pattern, e.errorMessage && (delete e.errorMessage.pattern, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.allOf.push({
    pattern: yk(t, i),
    ...n && i.errorMessages && { errorMessage: { pattern: n } }
  })) : nt(e, "pattern", yk(t, i), n, i);
}
function yk(e, t) {
  if (!t.applyRegexFlags || !e.flags)
    return e.source;
  const n = {
    i: e.flags.includes("i"),
    m: e.flags.includes("m"),
    s: e.flags.includes("s")
    // `.` matches newlines
  }, i = n.i ? e.source.toLowerCase() : e.source;
  let r = "", s = !1, l = !1, c = !1;
  for (let f = 0; f < i.length; f++) {
    if (s) {
      r += i[f], s = !1;
      continue;
    }
    if (n.i) {
      if (l) {
        if (i[f].match(/[a-z]/)) {
          c ? (r += i[f], r += `${i[f - 2]}-${i[f]}`.toUpperCase(), c = !1) : i[f + 1] === "-" && i[f + 2]?.match(/[a-z]/) ? (r += i[f], c = !0) : r += `${i[f]}${i[f].toUpperCase()}`;
          continue;
        }
      } else if (i[f].match(/[a-z]/)) {
        r += `[${i[f]}${i[f].toUpperCase()}]`;
        continue;
      }
    }
    if (n.m) {
      if (i[f] === "^") {
        r += `(^|(?<=[\r
]))`;
        continue;
      } else if (i[f] === "$") {
        r += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (n.s && i[f] === ".") {
      r += l ? `${i[f]}\r
` : `[${i[f]}\r
]`;
      continue;
    }
    r += i[f], i[f] === "\\" ? s = !0 : l && i[f] === "]" ? l = !1 : !l && i[f] === "[" && (l = !0);
  }
  try {
    new RegExp(r);
  } catch {
    return console.warn(`Could not convert regex pattern at ${t.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), e.source;
  }
  return r;
}
function Dz(e, t) {
  if (t.target === "openAi" && console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."), t.target === "openApi3" && e.keyType?._def.typeName === Oe.ZodEnum)
    return {
      type: "object",
      required: e.keyType._def.values,
      properties: e.keyType._def.values.reduce((i, r) => ({
        ...i,
        [r]: Ke(e.valueType._def, {
          ...t,
          currentPath: [...t.currentPath, "properties", r]
        }) ?? $n(t)
      }), {}),
      additionalProperties: t.rejectedAdditionalProperties
    };
  const n = {
    type: "object",
    additionalProperties: Ke(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    }) ?? t.allowedAdditionalProperties
  };
  if (t.target === "openApi3")
    return n;
  if (e.keyType?._def.typeName === Oe.ZodString && e.keyType._def.checks?.length) {
    const { type: i, ...r } = Mz(e.keyType._def, t);
    return {
      ...n,
      propertyNames: r
    };
  } else {
    if (e.keyType?._def.typeName === Oe.ZodEnum)
      return {
        ...n,
        propertyNames: {
          enum: e.keyType._def.values
        }
      };
    if (e.keyType?._def.typeName === Oe.ZodBranded && e.keyType._def.type._def.typeName === Oe.ZodString && e.keyType._def.type._def.checks?.length) {
      const { type: i, ...r } = Rz(e.keyType._def, t);
      return {
        ...n,
        propertyNames: r
      };
    }
  }
  return n;
}
function l8(e, t) {
  if (t.mapStrategy === "record")
    return Dz(e, t);
  const n = Ke(e.keyType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "0"]
  }) || $n(t), i = Ke(e.valueType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "1"]
  }) || $n(t);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, i],
      minItems: 2,
      maxItems: 2
    }
  };
}
function u8(e) {
  const t = e.values, i = Object.keys(e.values).filter((s) => typeof t[t[s]] != "number").map((s) => t[s]), r = Array.from(new Set(i.map((s) => typeof s)));
  return {
    type: r.length === 1 ? r[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: i
  };
}
function c8(e) {
  return e.target === "openAi" ? void 0 : {
    not: $n({
      ...e,
      currentPath: [...e.currentPath, "not"]
    })
  };
}
function d8(e) {
  return e.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const af = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function f8(e, t) {
  if (t.target === "openApi3")
    return bk(e, t);
  const n = e.options instanceof Map ? Array.from(e.options.values()) : e.options;
  if (n.every((i) => i._def.typeName in af && (!i._def.checks || !i._def.checks.length))) {
    const i = n.reduce((r, s) => {
      const l = af[s._def.typeName];
      return l && !r.includes(l) ? [...r, l] : r;
    }, []);
    return {
      type: i.length > 1 ? i : i[0]
    };
  } else if (n.every((i) => i._def.typeName === "ZodLiteral" && !i.description)) {
    const i = n.reduce((r, s) => {
      const l = typeof s._def.value;
      switch (l) {
        case "string":
        case "number":
        case "boolean":
          return [...r, l];
        case "bigint":
          return [...r, "integer"];
        case "object":
          if (s._def.value === null)
            return [...r, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return r;
      }
    }, []);
    if (i.length === n.length) {
      const r = i.filter((s, l, c) => c.indexOf(s) === l);
      return {
        type: r.length > 1 ? r : r[0],
        enum: n.reduce((s, l) => s.includes(l._def.value) ? s : [...s, l._def.value], [])
      };
    }
  } else if (n.every((i) => i._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce((i, r) => [
        ...i,
        ...r._def.values.filter((s) => !i.includes(s))
      ], [])
    };
  return bk(e, t);
}
const bk = (e, t) => {
  const n = (e.options instanceof Map ? Array.from(e.options.values()) : e.options).map((i, r) => Ke(i._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", `${r}`]
  })).filter((i) => !!i && (!t.strictUnions || typeof i == "object" && Object.keys(i).length > 0));
  return n.length ? { anyOf: n } : void 0;
};
function h8(e, t) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(e.innerType._def.typeName) && (!e.innerType._def.checks || !e.innerType._def.checks.length))
    return t.target === "openApi3" ? {
      type: af[e.innerType._def.typeName],
      nullable: !0
    } : {
      type: [
        af[e.innerType._def.typeName],
        "null"
      ]
    };
  if (t.target === "openApi3") {
    const i = Ke(e.innerType._def, {
      ...t,
      currentPath: [...t.currentPath]
    });
    return i && "$ref" in i ? { allOf: [i], nullable: !0 } : i && { ...i, nullable: !0 };
  }
  const n = Ke(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "0"]
  });
  return n && { anyOf: [n, { type: "null" }] };
}
function p8(e, t) {
  const n = {
    type: "number"
  };
  if (!e.checks)
    return n;
  for (const i of e.checks)
    switch (i.kind) {
      case "int":
        n.type = "integer", Cz(n, "type", i.message, t);
        break;
      case "min":
        t.target === "jsonSchema7" ? i.inclusive ? nt(n, "minimum", i.value, i.message, t) : nt(n, "exclusiveMinimum", i.value, i.message, t) : (i.inclusive || (n.exclusiveMinimum = !0), nt(n, "minimum", i.value, i.message, t));
        break;
      case "max":
        t.target === "jsonSchema7" ? i.inclusive ? nt(n, "maximum", i.value, i.message, t) : nt(n, "exclusiveMaximum", i.value, i.message, t) : (i.inclusive || (n.exclusiveMaximum = !0), nt(n, "maximum", i.value, i.message, t));
        break;
      case "multipleOf":
        nt(n, "multipleOf", i.value, i.message, t);
        break;
    }
  return n;
}
function m8(e, t) {
  const n = t.target === "openAi", i = {
    type: "object",
    properties: {}
  }, r = [], s = e.shape();
  for (const c in s) {
    let f = s[c];
    if (f === void 0 || f._def === void 0)
      continue;
    let h = v8(f);
    h && n && (f._def.typeName === "ZodOptional" && (f = f._def.innerType), f.isNullable() || (f = f.nullable()), h = !1);
    const p = Ke(f._def, {
      ...t,
      currentPath: [...t.currentPath, "properties", c],
      propertyPath: [...t.currentPath, "properties", c]
    });
    p !== void 0 && (i.properties[c] = p, h || r.push(c));
  }
  r.length && (i.required = r);
  const l = g8(e, t);
  return l !== void 0 && (i.additionalProperties = l), i;
}
function g8(e, t) {
  if (e.catchall._def.typeName !== "ZodNever")
    return Ke(e.catchall._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    });
  switch (e.unknownKeys) {
    case "passthrough":
      return t.allowedAdditionalProperties;
    case "strict":
      return t.rejectedAdditionalProperties;
    case "strip":
      return t.removeAdditionalStrategy === "strict" ? t.allowedAdditionalProperties : t.rejectedAdditionalProperties;
  }
}
function v8(e) {
  try {
    return e.isOptional();
  } catch {
    return !0;
  }
}
const y8 = (e, t) => {
  if (t.currentPath.toString() === t.propertyPath?.toString())
    return Ke(e.innerType._def, t);
  const n = Ke(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "1"]
  });
  return n ? {
    anyOf: [
      {
        not: $n(t)
      },
      n
    ]
  } : $n(t);
}, b8 = (e, t) => {
  if (t.pipeStrategy === "input")
    return Ke(e.in._def, t);
  if (t.pipeStrategy === "output")
    return Ke(e.out._def, t);
  const n = Ke(e.in._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", "0"]
  }), i = Ke(e.out._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", n ? "1" : "0"]
  });
  return {
    allOf: [n, i].filter((r) => r !== void 0)
  };
};
function x8(e, t) {
  return Ke(e.type._def, t);
}
function w8(e, t) {
  const i = {
    type: "array",
    uniqueItems: !0,
    items: Ke(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "items"]
    })
  };
  return e.minSize && nt(i, "minItems", e.minSize.value, e.minSize.message, t), e.maxSize && nt(i, "maxItems", e.maxSize.value, e.maxSize.message, t), i;
}
function _8(e, t) {
  return e.rest ? {
    type: "array",
    minItems: e.items.length,
    items: e.items.map((n, i) => Ke(n._def, {
      ...t,
      currentPath: [...t.currentPath, "items", `${i}`]
    })).reduce((n, i) => i === void 0 ? n : [...n, i], []),
    additionalItems: Ke(e.rest._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: e.items.length,
    maxItems: e.items.length,
    items: e.items.map((n, i) => Ke(n._def, {
      ...t,
      currentPath: [...t.currentPath, "items", `${i}`]
    })).reduce((n, i) => i === void 0 ? n : [...n, i], [])
  };
}
function S8(e) {
  return {
    not: $n(e)
  };
}
function k8(e) {
  return $n(e);
}
const T8 = (e, t) => Ke(e.innerType._def, t), E8 = (e, t, n) => {
  switch (t) {
    case Oe.ZodString:
      return Mz(e, n);
    case Oe.ZodNumber:
      return p8(e, n);
    case Oe.ZodObject:
      return m8(e, n);
    case Oe.ZodBigInt:
      return XF(e, n);
    case Oe.ZodBoolean:
      return KF();
    case Oe.ZodDate:
      return Nz(e, n);
    case Oe.ZodUndefined:
      return S8(n);
    case Oe.ZodNull:
      return d8(n);
    case Oe.ZodArray:
      return JF(e, n);
    case Oe.ZodUnion:
    case Oe.ZodDiscriminatedUnion:
      return f8(e, n);
    case Oe.ZodIntersection:
      return i8(e, n);
    case Oe.ZodTuple:
      return _8(e, n);
    case Oe.ZodRecord:
      return Dz(e, n);
    case Oe.ZodLiteral:
      return a8(e, n);
    case Oe.ZodEnum:
      return n8(e);
    case Oe.ZodNativeEnum:
      return u8(e);
    case Oe.ZodNullable:
      return h8(e, n);
    case Oe.ZodOptional:
      return y8(e, n);
    case Oe.ZodMap:
      return l8(e, n);
    case Oe.ZodSet:
      return w8(e, n);
    case Oe.ZodLazy:
      return () => e.getter()._def;
    case Oe.ZodPromise:
      return x8(e, n);
    case Oe.ZodNaN:
    case Oe.ZodNever:
      return c8(n);
    case Oe.ZodEffects:
      return t8(e, n);
    case Oe.ZodAny:
      return $n(n);
    case Oe.ZodUnknown:
      return k8(n);
    case Oe.ZodDefault:
      return e8(e, n);
    case Oe.ZodBranded:
      return Rz(e, n);
    case Oe.ZodReadonly:
      return T8(e, n);
    case Oe.ZodCatch:
      return WF(e, n);
    case Oe.ZodPipeline:
      return b8(e, n);
    case Oe.ZodFunction:
    case Oe.ZodVoid:
    case Oe.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((i) => {
      })();
  }
};
function Ke(e, t, n = !1) {
  const i = t.seen.get(e);
  if (t.override) {
    const c = t.override?.(e, t, i, n);
    if (c !== qF)
      return c;
  }
  if (i && !n) {
    const c = $8(i, t);
    if (c !== void 0)
      return c;
  }
  const r = { def: e, path: t.currentPath, jsonSchema: void 0 };
  t.seen.set(e, r);
  const s = E8(e, e.typeName, t), l = typeof s == "function" ? Ke(s(), t) : s;
  if (l && A8(e, t, l), t.postProcess) {
    const c = t.postProcess(l, e, t);
    return r.jsonSchema = l, c;
  }
  return r.jsonSchema = l, l;
}
const $8 = (e, t) => {
  switch (t.$refStrategy) {
    case "root":
      return { $ref: e.path.join("/") };
    case "relative":
      return { $ref: Oz(t.currentPath, e.path) };
    case "none":
    case "seen":
      return e.path.length < t.currentPath.length && e.path.every((n, i) => t.currentPath[i] === n) ? (console.warn(`Recursive reference detected at ${t.currentPath.join("/")}! Defaulting to any`), $n(t)) : t.$refStrategy === "seen" ? $n(t) : void 0;
  }
}, A8 = (e, t, n) => (e.description && (n.description = e.description, t.markdownDescription && (n.markdownDescription = e.description)), n), z8 = (e, t) => {
  const n = YF(t);
  let i = typeof t == "object" && t.definitions ? Object.entries(t.definitions).reduce((f, [h, p]) => ({
    ...f,
    [h]: Ke(p._def, {
      ...n,
      currentPath: [...n.basePath, n.definitionPath, h]
    }, !0) ?? $n(n)
  }), {}) : void 0;
  const r = typeof t == "string" ? t : t?.nameStrategy === "title" ? void 0 : t?.name, s = Ke(e._def, r === void 0 ? n : {
    ...n,
    currentPath: [...n.basePath, n.definitionPath, r]
  }, !1) ?? $n(n), l = typeof t == "object" && t.name !== void 0 && t.nameStrategy === "title" ? t.name : void 0;
  l !== void 0 && (s.title = l), n.flags.hasReferencedOpenAiAnyType && (i || (i = {}), i[n.openAiAnyTypeName] || (i[n.openAiAnyTypeName] = {
    // Skipping "object" as no properties can be defined and additionalProperties must be "false"
    type: ["string", "number", "integer", "boolean", "array", "null"],
    items: {
      $ref: n.$refStrategy === "relative" ? "1" : [
        ...n.basePath,
        n.definitionPath,
        n.openAiAnyTypeName
      ].join("/")
    }
  }));
  const c = r === void 0 ? i ? {
    ...s,
    [n.definitionPath]: i
  } : s : {
    $ref: [
      ...n.$refStrategy === "relative" ? [] : n.basePath,
      n.definitionPath,
      r
    ].join("/"),
    [n.definitionPath]: {
      ...i,
      [r]: s
    }
  };
  return n.target === "jsonSchema7" ? c.$schema = "http://json-schema.org/draft-07/schema#" : (n.target === "jsonSchema2019-09" || n.target === "openAi") && (c.$schema = "https://json-schema.org/draft/2019-09/schema#"), n.target === "openAi" && ("anyOf" in c || "oneOf" in c || "allOf" in c || "type" in c && Array.isArray(c.type)) && console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."), c;
};
var zu = ({
  prefix: e,
  size: t = 16,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator: i = "-"
} = {}) => {
  const r = () => {
    const s = n.length, l = new Array(t);
    for (let c = 0; c < t; c++)
      l[c] = n[Math.random() * s | 0];
    return l.join("");
  };
  if (e == null)
    return r;
  if (n.includes(i))
    throw new LZ({
      argument: "separator",
      message: `The separator "${i}" must not be part of the alphabet "${n}".`
    });
  return () => `${e}${i}${r()}`;
}, by = zu(), I8 = /"__proto__"\s*:/, C8 = /"constructor"\s*:/;
function O8(e) {
  const t = JSON.parse(e);
  return t === null || typeof t != "object" || I8.test(e) === !1 && C8.test(e) === !1 ? t : R8(t);
}
function R8(e) {
  let t = [e];
  for (; t.length; ) {
    const n = t;
    t = [];
    for (const i of n) {
      if (Object.prototype.hasOwnProperty.call(i, "__proto__"))
        throw new SyntaxError("Object contains forbidden prototype property");
      if (Object.prototype.hasOwnProperty.call(i, "constructor") && Object.prototype.hasOwnProperty.call(i.constructor, "prototype"))
        throw new SyntaxError("Object contains forbidden prototype property");
      for (const r in i) {
        const s = i[r];
        s && typeof s == "object" && t.push(s);
      }
    }
  }
  return e;
}
function N8(e) {
  const { stackTraceLimit: t } = Error;
  Error.stackTraceLimit = 0;
  try {
    return O8(e);
  } finally {
    Error.stackTraceLimit = t;
  }
}
var sf = Symbol.for("vercel.ai.validator");
function M8(e) {
  return { [sf]: !0, validate: e };
}
function D8(e) {
  return typeof e == "object" && e !== null && sf in e && e[sf] === !0 && "validate" in e;
}
function j8(e) {
  return D8(e) ? e : P8(e);
}
function P8(e) {
  return M8(async (t) => {
    const n = await e["~standard"].validate(t);
    return n.issues == null ? { success: !0, value: n.value } : {
      success: !1,
      error: new Qd({
        value: t,
        cause: n.issues
      })
    };
  });
}
async function xk({
  value: e,
  schema: t
}) {
  const n = await xy({ value: e, schema: t });
  if (!n.success)
    throw Qd.wrap({ value: e, cause: n.error });
  return n.value;
}
async function xy({
  value: e,
  schema: t
}) {
  const n = j8(t);
  try {
    if (n.validate == null)
      return { success: !0, value: e, rawValue: e };
    const i = await n.validate(e);
    return i.success ? { success: !0, value: i.value, rawValue: e } : {
      success: !1,
      error: Qd.wrap({ value: e, cause: i.error }),
      rawValue: e
    };
  } catch (i) {
    return {
      success: !1,
      error: Qd.wrap({ value: e, cause: i }),
      rawValue: e
    };
  }
}
async function of({
  text: e,
  schema: t
}) {
  try {
    const n = N8(e);
    return t == null ? { success: !0, value: n, rawValue: n } : await xy({ value: n, schema: t });
  } catch (n) {
    return {
      success: !1,
      error: X1.isInstance(n) ? n : new X1({ text: e, cause: n }),
      rawValue: void 0
    };
  }
}
function U8({
  stream: e,
  schema: t
}) {
  return e.pipeThrough(new TextDecoderStream()).pipeThrough(new qZ()).pipeThrough(
    new TransformStream({
      async transform({ data: n }, i) {
        n !== "[DONE]" && i.enqueue(await of({ text: n, schema: t }));
      }
    })
  );
}
async function Vs(e) {
  return typeof e == "function" && (e = e()), Promise.resolve(e);
}
function L8(e, t) {
  var n;
  const i = (n = void 0) != null ? n : !1;
  return wy(
    z8(e, {
      $refStrategy: i ? "root" : "none",
      target: "jsonSchema7"
      // note: openai mode breaks various gemini conversions
    }),
    {
      validate: async (r) => {
        const s = await e.safeParseAsync(r);
        return s.success ? { success: !0, value: s.data } : { success: !1, error: s.error };
      }
    }
  );
}
function B8(e, t) {
  var n;
  const i = (n = void 0) != null ? n : !1, r = PV(e, {
    target: "draft-7",
    io: "output",
    reused: i ? "ref" : "inline"
  });
  return wy(r, {
    validate: async (s) => {
      const l = await Sz(e, s);
      return l.success ? { success: !0, value: l.data } : { success: !1, error: l.error };
    }
  });
}
function Z8(e) {
  return "_zod" in e;
}
function V8(e, t) {
  return Z8(e) ? B8(e) : L8(e);
}
var qg = Symbol.for("vercel.ai.schema");
function wy(e, {
  validate: t
} = {}) {
  return {
    [qg]: !0,
    _type: void 0,
    // should never be used directly
    [sf]: !0,
    jsonSchema: e,
    validate: t
  };
}
function F8(e) {
  return typeof e == "object" && e !== null && qg in e && e[qg] === !0 && "jsonSchema" in e && "validate" in e;
}
function H8(e) {
  return e == null ? wy({
    properties: {},
    additionalProperties: !1
  }) : F8(e) ? e : V8(e);
}
var q8 = Object.defineProperty, G8 = (e, t) => {
  for (var n in t)
    q8(e, n, { get: t[n], enumerable: !0 });
}, jz = "AI_NoObjectGeneratedError", Pz = `vercel.ai.error.${jz}`, Y8 = Symbol.for(Pz), Uz, wk = class extends na {
  constructor({
    message: e = "No object generated.",
    cause: t,
    text: n,
    response: i,
    usage: r,
    finishReason: s
  }) {
    super({ name: jz, message: e, cause: t }), this[Uz] = !0, this.text = n, this.response = i, this.usage = r, this.finishReason = s;
  }
  static isInstance(e) {
    return na.hasMarker(e, Pz);
  }
};
Uz = Y8;
var Lz = Vt([
  te(),
  rf(Uint8Array),
  rf(ArrayBuffer),
  VF(
    // Buffer might not be available in some environments such as CloudFlare:
    (e) => {
      var t, n;
      return (n = (t = globalThis.Buffer) == null ? void 0 : t.isBuffer(e)) != null ? n : !1;
    },
    { message: "Must be a Buffer" }
  )
]), su = BF(
  () => Vt([
    vF(),
    te(),
    au(),
    Ot(),
    Fg(te(), su),
    Si(su)
  ])
), Ye = Fg(
  te(),
  Fg(te(), su)
), Bz = Ee({
  type: me("text"),
  text: te(),
  providerOptions: Ye.optional()
}), J8 = Ee({
  type: me("image"),
  image: Vt([Lz, rf(URL)]),
  mediaType: te().optional(),
  providerOptions: Ye.optional()
}), Zz = Ee({
  type: me("file"),
  data: Vt([Lz, rf(URL)]),
  filename: te().optional(),
  mediaType: te(),
  providerOptions: Ye.optional()
}), X8 = Ee({
  type: me("reasoning"),
  text: te(),
  providerOptions: Ye.optional()
}), K8 = Ee({
  type: me("tool-call"),
  toolCallId: te(),
  toolName: te(),
  input: pt(),
  providerOptions: Ye.optional(),
  providerExecuted: Ot().optional()
}), W8 = _F("type", [
  Ee({
    type: me("text"),
    value: te()
  }),
  Ee({
    type: me("json"),
    value: su
  }),
  Ee({
    type: me("error-text"),
    value: te()
  }),
  Ee({
    type: me("error-json"),
    value: su
  }),
  Ee({
    type: me("content"),
    value: Si(
      Vt([
        Ee({
          type: me("text"),
          text: te()
        }),
        Ee({
          type: me("media"),
          data: te(),
          mediaType: te()
        })
      ])
    )
  })
]), Vz = Ee({
  type: me("tool-result"),
  toolCallId: te(),
  toolName: te(),
  output: W8,
  providerOptions: Ye.optional()
}), Q8 = Ee(
  {
    role: me("system"),
    content: te(),
    providerOptions: Ye.optional()
  }
), e7 = Ee({
  role: me("user"),
  content: Vt([
    te(),
    Si(Vt([Bz, J8, Zz]))
  ]),
  providerOptions: Ye.optional()
}), t7 = Ee({
  role: me("assistant"),
  content: Vt([
    te(),
    Si(
      Vt([
        Bz,
        Zz,
        X8,
        K8,
        Vz
      ])
    )
  ]),
  providerOptions: Ye.optional()
}), n7 = Ee({
  role: me("tool"),
  content: Si(Vz),
  providerOptions: Ye.optional()
});
Vt([
  Q8,
  e7,
  t7,
  n7
]);
zu({
  prefix: "aitxt",
  size: 24
});
(class extends TransformStream {
  constructor() {
    super({
      transform(e, t) {
        t.enqueue(`data: ${JSON.stringify(e)}

`);
      },
      flush(e) {
        e.enqueue(`data: [DONE]

`);
      }
    });
  }
});
var r7 = Vt([
  ft({
    type: me("text-start"),
    id: te(),
    providerMetadata: Ye.optional()
  }),
  ft({
    type: me("text-delta"),
    id: te(),
    delta: te(),
    providerMetadata: Ye.optional()
  }),
  ft({
    type: me("text-end"),
    id: te(),
    providerMetadata: Ye.optional()
  }),
  ft({
    type: me("error"),
    errorText: te()
  }),
  ft({
    type: me("tool-input-start"),
    toolCallId: te(),
    toolName: te(),
    providerExecuted: Ot().optional(),
    dynamic: Ot().optional()
  }),
  ft({
    type: me("tool-input-delta"),
    toolCallId: te(),
    inputTextDelta: te()
  }),
  ft({
    type: me("tool-input-available"),
    toolCallId: te(),
    toolName: te(),
    input: pt(),
    providerExecuted: Ot().optional(),
    providerMetadata: Ye.optional(),
    dynamic: Ot().optional()
  }),
  ft({
    type: me("tool-input-error"),
    toolCallId: te(),
    toolName: te(),
    input: pt(),
    providerExecuted: Ot().optional(),
    providerMetadata: Ye.optional(),
    dynamic: Ot().optional(),
    errorText: te()
  }),
  ft({
    type: me("tool-output-available"),
    toolCallId: te(),
    output: pt(),
    providerExecuted: Ot().optional(),
    dynamic: Ot().optional(),
    preliminary: Ot().optional()
  }),
  ft({
    type: me("tool-output-error"),
    toolCallId: te(),
    errorText: te(),
    providerExecuted: Ot().optional(),
    dynamic: Ot().optional()
  }),
  ft({
    type: me("reasoning"),
    text: te(),
    providerMetadata: Ye.optional()
  }),
  ft({
    type: me("reasoning-start"),
    id: te(),
    providerMetadata: Ye.optional()
  }),
  ft({
    type: me("reasoning-delta"),
    id: te(),
    delta: te(),
    providerMetadata: Ye.optional()
  }),
  ft({
    type: me("reasoning-end"),
    id: te(),
    providerMetadata: Ye.optional()
  }),
  ft({
    type: me("reasoning-part-finish")
  }),
  ft({
    type: me("source-url"),
    sourceId: te(),
    url: te(),
    title: te().optional(),
    providerMetadata: Ye.optional()
  }),
  ft({
    type: me("source-document"),
    sourceId: te(),
    mediaType: te(),
    title: te(),
    filename: te().optional(),
    providerMetadata: Ye.optional()
  }),
  ft({
    type: me("file"),
    url: te(),
    mediaType: te(),
    providerMetadata: Ye.optional()
  }),
  ft({
    type: te().startsWith("data-"),
    id: te().optional(),
    data: pt(),
    transient: Ot().optional()
  }),
  ft({
    type: me("start-step")
  }),
  ft({
    type: me("finish-step")
  }),
  ft({
    type: me("start"),
    messageId: te().optional(),
    messageMetadata: pt().optional()
  }),
  ft({
    type: me("finish"),
    messageMetadata: pt().optional()
  }),
  ft({
    type: me("abort")
  }),
  ft({
    type: me("message-metadata"),
    messageMetadata: pt()
  })
]);
function i7(e) {
  return e.type.startsWith("data-");
}
function Fz(e, t) {
  if (e === void 0 && t === void 0)
    return;
  if (e === void 0)
    return t;
  if (t === void 0)
    return e;
  const n = { ...e };
  for (const i in t)
    if (Object.prototype.hasOwnProperty.call(t, i)) {
      const r = t[i];
      if (r === void 0)
        continue;
      const s = i in e ? e[i] : void 0, l = r !== null && typeof r == "object" && !Array.isArray(r) && !(r instanceof Date) && !(r instanceof RegExp), c = s != null && typeof s == "object" && !Array.isArray(s) && !(s instanceof Date) && !(s instanceof RegExp);
      l && c ? n[i] = Fz(
        s,
        r
      ) : n[i] = r;
    }
  return n;
}
function a7(e) {
  const t = ["ROOT"];
  let n = -1, i = null;
  function r(f, h, p) {
    switch (f) {
      case '"': {
        n = h, t.pop(), t.push(p), t.push("INSIDE_STRING");
        break;
      }
      case "f":
      case "t":
      case "n": {
        n = h, i = h, t.pop(), t.push(p), t.push("INSIDE_LITERAL");
        break;
      }
      case "-": {
        t.pop(), t.push(p), t.push("INSIDE_NUMBER");
        break;
      }
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9": {
        n = h, t.pop(), t.push(p), t.push("INSIDE_NUMBER");
        break;
      }
      case "{": {
        n = h, t.pop(), t.push(p), t.push("INSIDE_OBJECT_START");
        break;
      }
      case "[": {
        n = h, t.pop(), t.push(p), t.push("INSIDE_ARRAY_START");
        break;
      }
    }
  }
  function s(f, h) {
    switch (f) {
      case ",": {
        t.pop(), t.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        n = h, t.pop();
        break;
      }
    }
  }
  function l(f, h) {
    switch (f) {
      case ",": {
        t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        n = h, t.pop();
        break;
      }
    }
  }
  for (let f = 0; f < e.length; f++) {
    const h = e[f];
    switch (t[t.length - 1]) {
      case "ROOT":
        r(h, f, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (h) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            n = f, t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (h) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (h) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (h) {
          case ":": {
            t.pop(), t.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        r(h, f, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        s(h, f);
        break;
      }
      case "INSIDE_STRING": {
        switch (h) {
          case '"': {
            t.pop(), n = f;
            break;
          }
          case "\\": {
            t.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default:
            n = f;
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (h) {
          case "]": {
            n = f, t.pop();
            break;
          }
          default: {
            n = f, r(h, f, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (h) {
          case ",": {
            t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            n = f, t.pop();
            break;
          }
          default: {
            n = f;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        r(h, f, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        t.pop(), n = f;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (h) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            n = f;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".":
            break;
          case ",": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && l(h, f), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && s(h, f);
            break;
          }
          case "}": {
            t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && s(h, f);
            break;
          }
          case "]": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && l(h, f);
            break;
          }
          default: {
            t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const m = e.substring(i, f + 1);
        !"false".startsWith(m) && !"true".startsWith(m) && !"null".startsWith(m) ? (t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" ? s(h, f) : t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && l(h, f)) : n = f;
        break;
      }
    }
  }
  let c = e.slice(0, n + 1);
  for (let f = t.length - 1; f >= 0; f--)
    switch (t[f]) {
      case "INSIDE_STRING": {
        c += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        c += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        c += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const p = e.substring(i, e.length);
        "true".startsWith(p) ? c += "true".slice(p.length) : "false".startsWith(p) ? c += "false".slice(p.length) : "null".startsWith(p) && (c += "null".slice(p.length));
      }
    }
  return c;
}
async function Hz(e) {
  if (e === void 0)
    return { value: void 0, state: "undefined-input" };
  let t = await of({ text: e });
  return t.success ? { value: t.value, state: "successful-parse" } : (t = await of({ text: a7(e) }), t.success ? { value: t.value, state: "repaired-parse" } : { value: void 0, state: "failed-parse" });
}
function ao(e) {
  return e.type.startsWith("tool-");
}
function _k(e) {
  return e.type.split("-").slice(1).join("-");
}
function s7({
  lastMessage: e,
  messageId: t
}) {
  return {
    message: e?.role === "assistant" ? e : {
      id: t,
      metadata: void 0,
      role: "assistant",
      parts: []
    },
    activeTextParts: {},
    activeReasoningParts: {},
    partialToolCalls: {}
  };
}
function o7({
  stream: e,
  messageMetadataSchema: t,
  dataPartSchemas: n,
  runUpdateMessageJob: i,
  onError: r,
  onToolCall: s,
  onData: l
}) {
  return e.pipeThrough(
    new TransformStream({
      async transform(c, f) {
        await i(async ({ state: h, write: p }) => {
          var m, y, b, x;
          function w(O) {
            const N = h.message.parts.filter(ao).find(
              (U) => U.toolCallId === O
            );
            if (N == null)
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available"
              );
            return N;
          }
          function k(O) {
            const N = h.message.parts.filter(
              (U) => U.type === "dynamic-tool"
            ).find(
              (U) => U.toolCallId === O
            );
            if (N == null)
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available"
              );
            return N;
          }
          function T(O) {
            var M;
            const N = h.message.parts.find(
              (re) => ao(re) && re.toolCallId === O.toolCallId
            ), U = O, Z = N;
            N != null ? (N.state = O.state, Z.input = U.input, Z.output = U.output, Z.errorText = U.errorText, Z.rawInput = U.rawInput, Z.preliminary = U.preliminary, Z.providerExecuted = (M = U.providerExecuted) != null ? M : N.providerExecuted, U.providerMetadata != null && N.state === "input-available" && (N.callProviderMetadata = U.providerMetadata)) : h.message.parts.push({
              type: `tool-${O.toolName}`,
              toolCallId: O.toolCallId,
              state: O.state,
              input: U.input,
              output: U.output,
              rawInput: U.rawInput,
              errorText: U.errorText,
              providerExecuted: U.providerExecuted,
              preliminary: U.preliminary,
              ...U.providerMetadata != null ? { callProviderMetadata: U.providerMetadata } : {}
            });
          }
          function A(O) {
            var M;
            const N = h.message.parts.find(
              (re) => re.type === "dynamic-tool" && re.toolCallId === O.toolCallId
            ), U = O, Z = N;
            N != null ? (N.state = O.state, Z.toolName = O.toolName, Z.input = U.input, Z.output = U.output, Z.errorText = U.errorText, Z.rawInput = (M = U.rawInput) != null ? M : Z.rawInput, Z.preliminary = U.preliminary, U.providerMetadata != null && N.state === "input-available" && (N.callProviderMetadata = U.providerMetadata)) : h.message.parts.push({
              type: "dynamic-tool",
              toolName: O.toolName,
              toolCallId: O.toolCallId,
              state: O.state,
              input: U.input,
              output: U.output,
              errorText: U.errorText,
              preliminary: U.preliminary,
              ...U.providerMetadata != null ? { callProviderMetadata: U.providerMetadata } : {}
            });
          }
          async function z(O) {
            if (O != null) {
              const M = h.message.metadata != null ? Fz(h.message.metadata, O) : O;
              t != null && await xk({
                value: M,
                schema: t
              }), h.message.metadata = M;
            }
          }
          switch (c.type) {
            case "text-start": {
              const O = {
                type: "text",
                text: "",
                providerMetadata: c.providerMetadata,
                state: "streaming"
              };
              h.activeTextParts[c.id] = O, h.message.parts.push(O), p();
              break;
            }
            case "text-delta": {
              const O = h.activeTextParts[c.id];
              O.text += c.delta, O.providerMetadata = (m = c.providerMetadata) != null ? m : O.providerMetadata, p();
              break;
            }
            case "text-end": {
              const O = h.activeTextParts[c.id];
              O.state = "done", O.providerMetadata = (y = c.providerMetadata) != null ? y : O.providerMetadata, delete h.activeTextParts[c.id], p();
              break;
            }
            case "reasoning-start": {
              const O = {
                type: "reasoning",
                text: "",
                providerMetadata: c.providerMetadata,
                state: "streaming"
              };
              h.activeReasoningParts[c.id] = O, h.message.parts.push(O), p();
              break;
            }
            case "reasoning-delta": {
              const O = h.activeReasoningParts[c.id];
              O.text += c.delta, O.providerMetadata = (b = c.providerMetadata) != null ? b : O.providerMetadata, p();
              break;
            }
            case "reasoning-end": {
              const O = h.activeReasoningParts[c.id];
              O.providerMetadata = (x = c.providerMetadata) != null ? x : O.providerMetadata, O.state = "done", delete h.activeReasoningParts[c.id], p();
              break;
            }
            case "file": {
              h.message.parts.push({
                type: "file",
                mediaType: c.mediaType,
                url: c.url
              }), p();
              break;
            }
            case "source-url": {
              h.message.parts.push({
                type: "source-url",
                sourceId: c.sourceId,
                url: c.url,
                title: c.title,
                providerMetadata: c.providerMetadata
              }), p();
              break;
            }
            case "source-document": {
              h.message.parts.push({
                type: "source-document",
                sourceId: c.sourceId,
                mediaType: c.mediaType,
                title: c.title,
                filename: c.filename,
                providerMetadata: c.providerMetadata
              }), p();
              break;
            }
            case "tool-input-start": {
              const O = h.message.parts.filter(ao);
              h.partialToolCalls[c.toolCallId] = {
                text: "",
                toolName: c.toolName,
                index: O.length,
                dynamic: c.dynamic
              }, c.dynamic ? A({
                toolCallId: c.toolCallId,
                toolName: c.toolName,
                state: "input-streaming",
                input: void 0
              }) : T({
                toolCallId: c.toolCallId,
                toolName: c.toolName,
                state: "input-streaming",
                input: void 0,
                providerExecuted: c.providerExecuted
              }), p();
              break;
            }
            case "tool-input-delta": {
              const O = h.partialToolCalls[c.toolCallId];
              O.text += c.inputTextDelta;
              const { value: M } = await Hz(
                O.text
              );
              O.dynamic ? A({
                toolCallId: c.toolCallId,
                toolName: O.toolName,
                state: "input-streaming",
                input: M
              }) : T({
                toolCallId: c.toolCallId,
                toolName: O.toolName,
                state: "input-streaming",
                input: M
              }), p();
              break;
            }
            case "tool-input-available": {
              c.dynamic ? A({
                toolCallId: c.toolCallId,
                toolName: c.toolName,
                state: "input-available",
                input: c.input,
                providerMetadata: c.providerMetadata
              }) : T({
                toolCallId: c.toolCallId,
                toolName: c.toolName,
                state: "input-available",
                input: c.input,
                providerExecuted: c.providerExecuted,
                providerMetadata: c.providerMetadata
              }), p(), s && !c.providerExecuted && await s({
                toolCall: c
              });
              break;
            }
            case "tool-input-error": {
              c.dynamic ? A({
                toolCallId: c.toolCallId,
                toolName: c.toolName,
                state: "output-error",
                input: c.input,
                errorText: c.errorText,
                providerMetadata: c.providerMetadata
              }) : T({
                toolCallId: c.toolCallId,
                toolName: c.toolName,
                state: "output-error",
                input: void 0,
                rawInput: c.input,
                errorText: c.errorText,
                providerExecuted: c.providerExecuted,
                providerMetadata: c.providerMetadata
              }), p();
              break;
            }
            case "tool-output-available": {
              if (c.dynamic) {
                const O = k(
                  c.toolCallId
                );
                A({
                  toolCallId: c.toolCallId,
                  toolName: O.toolName,
                  state: "output-available",
                  input: O.input,
                  output: c.output,
                  preliminary: c.preliminary
                });
              } else {
                const O = w(c.toolCallId);
                T({
                  toolCallId: c.toolCallId,
                  toolName: _k(O),
                  state: "output-available",
                  input: O.input,
                  output: c.output,
                  providerExecuted: c.providerExecuted,
                  preliminary: c.preliminary
                });
              }
              p();
              break;
            }
            case "tool-output-error": {
              if (c.dynamic) {
                const O = k(
                  c.toolCallId
                );
                A({
                  toolCallId: c.toolCallId,
                  toolName: O.toolName,
                  state: "output-error",
                  input: O.input,
                  errorText: c.errorText
                });
              } else {
                const O = w(c.toolCallId);
                T({
                  toolCallId: c.toolCallId,
                  toolName: _k(O),
                  state: "output-error",
                  input: O.input,
                  rawInput: O.rawInput,
                  errorText: c.errorText
                });
              }
              p();
              break;
            }
            case "start-step": {
              h.message.parts.push({ type: "step-start" });
              break;
            }
            case "finish-step": {
              h.activeTextParts = {}, h.activeReasoningParts = {};
              break;
            }
            case "start": {
              c.messageId != null && (h.message.id = c.messageId), await z(c.messageMetadata), (c.messageId != null || c.messageMetadata != null) && p();
              break;
            }
            case "finish": {
              await z(c.messageMetadata), c.messageMetadata != null && p();
              break;
            }
            case "message-metadata": {
              await z(c.messageMetadata), c.messageMetadata != null && p();
              break;
            }
            case "error": {
              r?.(new Error(c.errorText));
              break;
            }
            default:
              if (i7(c)) {
                n?.[c.type] != null && await xk({
                  value: c.data,
                  schema: n[c.type]
                });
                const O = c;
                if (O.transient) {
                  l?.(O);
                  break;
                }
                const M = O.id != null ? h.message.parts.find(
                  (N) => O.type === N.type && O.id === N.id
                ) : void 0;
                M != null ? M.data = O.data : h.message.parts.push(O), l?.(O), p();
              }
          }
          f.enqueue(c);
        });
      }
    })
  );
}
async function l7({
  stream: e,
  onError: t
}) {
  const n = e.getReader();
  try {
    for (; ; ) {
      const { done: i } = await n.read();
      if (i)
        break;
    }
  } catch (i) {
    t?.(i);
  } finally {
    n.releaseLock();
  }
}
zu({
  prefix: "aitxt",
  size: 24
});
zu({ prefix: "aiobj", size: 24 });
var u7 = class {
  constructor() {
    this.queue = [], this.isProcessing = !1;
  }
  async processQueue() {
    if (!this.isProcessing) {
      for (this.isProcessing = !0; this.queue.length > 0; )
        await this.queue[0](), this.queue.shift();
      this.isProcessing = !1;
    }
  }
  async run(e) {
    return new Promise((t, n) => {
      this.queue.push(async () => {
        try {
          await e(), t();
        } catch (i) {
          n(i);
        }
      }), this.processQueue();
    });
  }
};
zu({ prefix: "aiobj", size: 24 });
var c7 = {};
G8(c7, {
  object: () => f7,
  text: () => d7
});
var d7 = () => ({
  type: "text",
  responseFormat: { type: "text" },
  async parsePartial({ text: e }) {
    return { partial: e };
  },
  async parseOutput({ text: e }) {
    return e;
  }
}), f7 = ({
  schema: e
}) => {
  const t = H8(e);
  return {
    type: "object",
    responseFormat: {
      type: "json",
      schema: t.jsonSchema
    },
    async parsePartial({ text: n }) {
      const i = await Hz(n);
      switch (i.state) {
        case "failed-parse":
        case "undefined-input":
          return;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: i.value
          };
        default: {
          const r = i.state;
          throw new Error(`Unsupported parse state: ${r}`);
        }
      }
    },
    async parseOutput({ text: n }, i) {
      const r = await of({ text: n });
      if (!r.success)
        throw new wk({
          message: "No object generated: could not parse the response.",
          cause: r.error,
          text: n,
          response: i.response,
          usage: i.usage,
          finishReason: i.finishReason
        });
      const s = await xy({
        value: r.value,
        schema: t
      });
      if (!s.success)
        throw new wk({
          message: "No object generated: response did not match schema.",
          cause: s.error,
          text: n,
          response: i.response,
          usage: i.usage,
          finishReason: i.finishReason
        });
      return s.value;
    }
  };
}, h7 = Ks({
  name: te(),
  version: te()
}), _y = Ks({
  _meta: jt(Ee({}).loose())
}), ou = _y, p7 = Ee({
  method: te(),
  params: jt(_y)
}), m7 = Ks({
  experimental: jt(Ee({}).loose()),
  logging: jt(Ee({}).loose()),
  prompts: jt(
    Ks({
      listChanged: jt(Ot())
    })
  ),
  resources: jt(
    Ks({
      subscribe: jt(Ot()),
      listChanged: jt(Ot())
    })
  ),
  tools: jt(
    Ks({
      listChanged: jt(Ot())
    })
  )
});
ou.extend({
  protocolVersion: te(),
  capabilities: m7,
  serverInfo: h7,
  instructions: jt(te())
});
var g7 = ou.extend({
  nextCursor: jt(te())
}), v7 = Ee({
  name: te(),
  description: jt(te()),
  inputSchema: Ee({
    type: me("object"),
    properties: jt(Ee({}).loose())
  }).loose()
}).loose();
g7.extend({
  tools: Si(v7)
});
var y7 = Ee({
  type: me("text"),
  text: te()
}).loose(), b7 = Ee({
  type: me("image"),
  data: Ez(),
  mimeType: te()
}).loose(), qz = Ee({
  /**
   * The URI of this resource.
   */
  uri: te(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: jt(te())
}).loose(), x7 = qz.extend({
  text: te()
}), w7 = qz.extend({
  blob: Ez()
}), _7 = Ee({
  type: me("resource"),
  resource: Vt([x7, w7])
}).loose();
ou.extend({
  content: Si(
    Vt([y7, b7, _7])
  ),
  isError: Ot().default(!1).optional()
}).or(
  ou.extend({
    toolResult: pt()
  })
);
var Uf = "2.0", S7 = Ee({
  jsonrpc: me(Uf),
  id: Vt([te(), au().int()])
}).merge(p7).strict(), k7 = Ee({
  jsonrpc: me(Uf),
  id: Vt([te(), au().int()]),
  result: ou
}).strict(), T7 = Ee({
  jsonrpc: me(Uf),
  id: Vt([te(), au().int()]),
  error: Ee({
    code: au().int(),
    message: te(),
    data: jt(pt())
  })
}).strict(), E7 = Ee({
  jsonrpc: me(Uf)
}).merge(
  Ee({
    method: te(),
    params: jt(_y)
  })
).strict();
Vt([
  S7,
  E7,
  k7,
  T7
]);
async function $7(e) {
  if (e == null)
    return [];
  if (!globalThis.FileList || !(e instanceof globalThis.FileList))
    throw new Error("FileList is not supported in the current environment");
  return Promise.all(
    Array.from(e).map(async (t) => {
      const { name: n, type: i } = t, r = await new Promise((s, l) => {
        const c = new FileReader();
        c.onload = (f) => {
          var h;
          s((h = f.target) == null ? void 0 : h.result);
        }, c.onerror = (f) => l(f), c.readAsDataURL(t);
      });
      return {
        type: "file",
        mediaType: i,
        filename: n,
        url: r
      };
    })
  );
}
var A7 = class {
  constructor({
    api: e = "/api/chat",
    credentials: t,
    headers: n,
    body: i,
    fetch: r,
    prepareSendMessagesRequest: s,
    prepareReconnectToStreamRequest: l
  }) {
    this.api = e, this.credentials = t, this.headers = n, this.body = i, this.fetch = r, this.prepareSendMessagesRequest = s, this.prepareReconnectToStreamRequest = l;
  }
  async sendMessages({
    abortSignal: e,
    ...t
  }) {
    var n, i, r, s, l;
    const c = await Vs(this.body), f = await Vs(this.headers), h = await Vs(this.credentials), p = await ((n = this.prepareSendMessagesRequest) == null ? void 0 : n.call(this, {
      api: this.api,
      id: t.chatId,
      messages: t.messages,
      body: { ...c, ...t.body },
      headers: { ...f, ...t.headers },
      credentials: h,
      requestMetadata: t.metadata,
      trigger: t.trigger,
      messageId: t.messageId
    })), m = (i = p?.api) != null ? i : this.api, y = p?.headers !== void 0 ? p.headers : { ...f, ...t.headers }, b = p?.body !== void 0 ? p.body : {
      ...c,
      ...t.body,
      id: t.chatId,
      messages: t.messages,
      trigger: t.trigger,
      messageId: t.messageId
    }, x = (r = p?.credentials) != null ? r : h, k = await ((s = this.fetch) != null ? s : globalThis.fetch)(m, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...y
      },
      body: JSON.stringify(b),
      credentials: x,
      signal: e
    });
    if (!k.ok)
      throw new Error(
        (l = await k.text()) != null ? l : "Failed to fetch the chat response."
      );
    if (!k.body)
      throw new Error("The response body is empty.");
    return this.processResponseStream(k.body);
  }
  async reconnectToStream(e) {
    var t, n, i, r, s;
    const l = await Vs(this.body), c = await Vs(this.headers), f = await Vs(this.credentials), h = await ((t = this.prepareReconnectToStreamRequest) == null ? void 0 : t.call(this, {
      api: this.api,
      id: e.chatId,
      body: { ...l, ...e.body },
      headers: { ...c, ...e.headers },
      credentials: f,
      requestMetadata: e.metadata
    })), p = (n = h?.api) != null ? n : `${this.api}/${e.chatId}/stream`, m = h?.headers !== void 0 ? h.headers : { ...c, ...e.headers }, y = (i = h?.credentials) != null ? i : f, x = await ((r = this.fetch) != null ? r : globalThis.fetch)(p, {
      method: "GET",
      headers: m,
      credentials: y
    });
    if (x.status === 204)
      return null;
    if (!x.ok)
      throw new Error(
        (s = await x.text()) != null ? s : "Failed to fetch the chat response."
      );
    if (!x.body)
      throw new Error("The response body is empty.");
    return this.processResponseStream(x.body);
  }
}, Gz = class extends A7 {
  constructor(e = {}) {
    super(e);
  }
  processResponseStream(e) {
    return U8({
      stream: e,
      schema: r7
    }).pipeThrough(
      new TransformStream({
        async transform(t, n) {
          if (!t.success)
            throw t.error;
          n.enqueue(t.value);
        }
      })
    );
  }
}, z7 = class {
  constructor({
    generateId: e = by,
    id: t = e(),
    transport: n = new Gz(),
    messageMetadataSchema: i,
    dataPartSchemas: r,
    state: s,
    onError: l,
    onToolCall: c,
    onFinish: f,
    onData: h,
    sendAutomaticallyWhen: p
  }) {
    this.activeResponse = void 0, this.jobExecutor = new u7(), this.sendMessage = async (m, y) => {
      var b, x, w, k;
      if (m == null) {
        await this.makeRequest({
          trigger: "submit-message",
          messageId: (b = this.lastMessage) == null ? void 0 : b.id,
          ...y
        });
        return;
      }
      let T;
      if ("text" in m || "files" in m ? T = {
        parts: [
          ...Array.isArray(m.files) ? m.files : await $7(m.files),
          ..."text" in m && m.text != null ? [{ type: "text", text: m.text }] : []
        ]
      } : T = m, m.messageId != null) {
        const A = this.state.messages.findIndex(
          (z) => z.id === m.messageId
        );
        if (A === -1)
          throw new Error(`message with id ${m.messageId} not found`);
        if (this.state.messages[A].role !== "user")
          throw new Error(
            `message with id ${m.messageId} is not a user message`
          );
        this.state.messages = this.state.messages.slice(0, A + 1), this.state.replaceMessage(A, {
          ...T,
          id: m.messageId,
          role: (x = T.role) != null ? x : "user",
          metadata: m.metadata
        });
      } else
        this.state.pushMessage({
          ...T,
          id: (w = T.id) != null ? w : this.generateId(),
          role: (k = T.role) != null ? k : "user",
          metadata: m.metadata
        });
      await this.makeRequest({
        trigger: "submit-message",
        messageId: m.messageId,
        ...y
      });
    }, this.regenerate = async ({
      messageId: m,
      ...y
    } = {}) => {
      const b = m == null ? this.state.messages.length - 1 : this.state.messages.findIndex((x) => x.id === m);
      if (b === -1)
        throw new Error(`message ${m} not found`);
      this.state.messages = this.state.messages.slice(
        0,
        // if the message is a user message, we need to include it in the request:
        this.messages[b].role === "assistant" ? b : b + 1
      ), await this.makeRequest({
        trigger: "regenerate-message",
        messageId: m,
        ...y
      });
    }, this.resumeStream = async (m = {}) => {
      await this.makeRequest({ trigger: "resume-stream", ...m });
    }, this.clearError = () => {
      this.status === "error" && (this.state.error = void 0, this.setStatus({ status: "ready" }));
    }, this.addToolResult = async ({
      tool: m,
      toolCallId: y,
      output: b
    }) => this.jobExecutor.run(async () => {
      var x, w;
      const k = this.state.messages, T = k[k.length - 1];
      this.state.replaceMessage(k.length - 1, {
        ...T,
        parts: T.parts.map(
          (A) => ao(A) && A.toolCallId === y ? { ...A, state: "output-available", output: b } : A
        )
      }), this.activeResponse && (this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(
        (A) => ao(A) && A.toolCallId === y ? {
          ...A,
          state: "output-available",
          output: b,
          errorText: void 0
        } : A
      )), this.status !== "streaming" && this.status !== "submitted" && ((x = this.sendAutomaticallyWhen) != null && x.call(this, { messages: this.state.messages })) && this.makeRequest({
        trigger: "submit-message",
        messageId: (w = this.lastMessage) == null ? void 0 : w.id
      });
    }), this.stop = async () => {
      var m;
      this.status !== "streaming" && this.status !== "submitted" || (m = this.activeResponse) != null && m.abortController && this.activeResponse.abortController.abort();
    }, this.id = t, this.transport = n, this.generateId = e, this.messageMetadataSchema = i, this.dataPartSchemas = r, this.state = s, this.onError = l, this.onToolCall = c, this.onFinish = f, this.onData = h, this.sendAutomaticallyWhen = p;
  }
  /**
   * Hook status:
   *
   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.
   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.
   * - `ready`: The full response has been received and processed; a new user message can be submitted.
   * - `error`: An error occurred during the API request, preventing successful completion.
   */
  get status() {
    return this.state.status;
  }
  setStatus({
    status: e,
    error: t
  }) {
    this.status !== e && (this.state.status = e, this.state.error = t);
  }
  get error() {
    return this.state.error;
  }
  get messages() {
    return this.state.messages;
  }
  get lastMessage() {
    return this.state.messages[this.state.messages.length - 1];
  }
  set messages(e) {
    this.state.messages = e;
  }
  async makeRequest({
    trigger: e,
    metadata: t,
    headers: n,
    body: i,
    messageId: r
  }) {
    var s, l, c;
    this.setStatus({ status: "submitted", error: void 0 });
    const f = this.lastMessage;
    try {
      const h = {
        state: s7({
          lastMessage: this.state.snapshot(f),
          messageId: this.generateId()
        }),
        abortController: new AbortController()
      };
      this.activeResponse = h;
      let p;
      if (e === "resume-stream") {
        const y = await this.transport.reconnectToStream({
          chatId: this.id,
          metadata: t,
          headers: n,
          body: i
        });
        if (y == null) {
          this.setStatus({ status: "ready" });
          return;
        }
        p = y;
      } else
        p = await this.transport.sendMessages({
          chatId: this.id,
          messages: this.state.messages,
          abortSignal: h.abortController.signal,
          metadata: t,
          headers: n,
          body: i,
          trigger: e,
          messageId: r
        });
      const m = (y) => (
        // serialize the job execution to avoid race conditions:
        this.jobExecutor.run(
          () => y({
            state: h.state,
            write: () => {
              var b;
              this.setStatus({ status: "streaming" }), h.state.message.id === ((b = this.lastMessage) == null ? void 0 : b.id) ? this.state.replaceMessage(
                this.state.messages.length - 1,
                h.state.message
              ) : this.state.pushMessage(h.state.message);
            }
          })
        )
      );
      await l7({
        stream: o7({
          stream: p,
          onToolCall: this.onToolCall,
          onData: this.onData,
          messageMetadataSchema: this.messageMetadataSchema,
          dataPartSchemas: this.dataPartSchemas,
          runUpdateMessageJob: m,
          onError: (y) => {
            throw y;
          }
        }),
        onError: (y) => {
          throw y;
        }
      }), (s = this.onFinish) == null || s.call(this, { message: h.state.message }), this.setStatus({ status: "ready" });
    } catch (h) {
      if (h.name === "AbortError")
        return this.setStatus({ status: "ready" }), null;
      this.onError && h instanceof Error && this.onError(h), this.setStatus({ status: "error", error: h });
    } finally {
      this.activeResponse = void 0;
    }
    (l = this.sendAutomaticallyWhen) != null && l.call(this, { messages: this.state.messages }) && await this.makeRequest({
      trigger: "submit-message",
      messageId: (c = this.lastMessage) == null ? void 0 : c.id,
      metadata: t,
      headers: n,
      body: i
    });
  }
}, I7 = Ee({
  type: me("text"),
  text: te(),
  state: Pf(["streaming", "done"]).optional(),
  providerMetadata: Ye.optional()
}), C7 = Ee({
  type: me("reasoning"),
  text: te(),
  state: Pf(["streaming", "done"]).optional(),
  providerMetadata: Ye.optional()
}), O7 = Ee({
  type: me("source-url"),
  sourceId: te(),
  url: te(),
  title: te().optional(),
  providerMetadata: Ye.optional()
}), R7 = Ee({
  type: me("source-document"),
  sourceId: te(),
  mediaType: te(),
  title: te(),
  filename: te().optional(),
  providerMetadata: Ye.optional()
}), N7 = Ee({
  type: me("file"),
  mediaType: te(),
  filename: te().optional(),
  url: te(),
  providerMetadata: Ye.optional()
}), M7 = Ee({
  type: me("step-start")
}), D7 = Ee({
  type: te().startsWith("data-"),
  id: te().optional(),
  data: pt()
}), j7 = [
  Ee({
    type: me("dynamic-tool"),
    toolName: te(),
    toolCallId: te(),
    state: me("input-streaming"),
    input: pt().optional(),
    output: Tn().optional(),
    errorText: Tn().optional()
  }),
  Ee({
    type: me("dynamic-tool"),
    toolName: te(),
    toolCallId: te(),
    state: me("input-available"),
    input: pt(),
    output: Tn().optional(),
    errorText: Tn().optional(),
    callProviderMetadata: Ye.optional()
  }),
  Ee({
    type: me("dynamic-tool"),
    toolName: te(),
    toolCallId: te(),
    state: me("output-available"),
    input: pt(),
    output: pt(),
    errorText: Tn().optional(),
    callProviderMetadata: Ye.optional(),
    preliminary: Ot().optional()
  }),
  Ee({
    type: me("dynamic-tool"),
    toolName: te(),
    toolCallId: te(),
    state: me("output-error"),
    input: pt(),
    output: Tn().optional(),
    errorText: te(),
    callProviderMetadata: Ye.optional()
  })
], P7 = [
  Ee({
    type: te().startsWith("tool-"),
    toolCallId: te(),
    state: me("input-streaming"),
    input: pt().optional(),
    output: Tn().optional(),
    errorText: Tn().optional()
  }),
  Ee({
    type: te().startsWith("tool-"),
    toolCallId: te(),
    state: me("input-available"),
    input: pt(),
    output: Tn().optional(),
    errorText: Tn().optional(),
    callProviderMetadata: Ye.optional()
  }),
  Ee({
    type: te().startsWith("tool-"),
    toolCallId: te(),
    state: me("output-available"),
    input: pt(),
    output: pt(),
    errorText: Tn().optional(),
    callProviderMetadata: Ye.optional(),
    preliminary: Ot().optional()
  }),
  Ee({
    type: te().startsWith("tool-"),
    toolCallId: te(),
    state: me("output-error"),
    input: pt(),
    output: Tn().optional(),
    errorText: te(),
    callProviderMetadata: Ye.optional()
  })
];
Ee({
  id: te(),
  role: Pf(["system", "user", "assistant"]),
  metadata: pt().optional(),
  parts: Si(
    Vt([
      I7,
      C7,
      O7,
      R7,
      N7,
      M7,
      D7,
      ...j7,
      ...P7
    ])
  )
});
var Sk = async (e) => {
  const n = [
    {
      type: "text",
      text: e.content.filter((s) => s.type === "text").map((s) => s.text).join(`

`)
    }
  ], i = e.content.filter((s) => s.type === "image").map(
    (s) => ({
      type: "file",
      mediaType: "image/png",
      // Default to PNG, could be made more dynamic
      url: s.image
    })
  );
  n.push(...i);
  const r = await Promise.all(
    (e.attachments ?? []).map(async (s) => {
      if (s.file == null) throw new Error("Attachment did not contain a file");
      return {
        type: "file",
        mediaType: s.file.type,
        filename: s.file.name,
        url: await U7(s.file)
      };
    })
  );
  return n.push(...r), {
    id: by(),
    role: e.role,
    parts: n
  };
}, U7 = (e) => new Promise((t, n) => {
  const i = new FileReader();
  i.onload = () => t(i.result), i.onerror = (r) => n(r), i.readAsDataURL(e);
}), L7 = {
  accept: "image/*, text/plain, text/html, text/markdown, text/csv, text/xml, text/json, text/css",
  async add({ file: e }) {
    return {
      id: by(),
      type: "file",
      name: e.name,
      file: e,
      contentType: e.type,
      content: [],
      status: { type: "requires-action", reason: "composer-send" }
    };
  },
  async send(e) {
    return {
      ...e,
      status: { type: "complete" },
      content: []
    };
  },
  async remove() {
  }
}, B7 = (e) => Za(e), qm = (e) => !e.parts || e.parts.length === 0 ? [] : e.parts.filter((t) => t.type !== "step-start").map((t) => {
  const n = t.type;
  if (n === "text")
    return {
      type: "text",
      text: t.text
    };
  if (n === "reasoning")
    return {
      type: "reasoning",
      text: t.text
    };
  if (ao(t)) {
    const i = n.replace("tool-", ""), r = t.toolCallId;
    let s = {}, l, c = !1;
    return t.state === "input-streaming" || t.state === "input-available" ? s = t.input || {} : t.state === "output-available" ? (s = t.input || {}, l = t.output) : t.state === "output-error" && (s = t.input || {}, c = !0, l = { error: t.errorText }), {
      type: "tool-call",
      toolName: i,
      toolCallId: r,
      argsText: JSON.stringify(s),
      args: s,
      result: l,
      isError: c
    };
  }
  if (n === "dynamic-tool") {
    const i = t.toolName, r = t.toolCallId;
    let s = {}, l, c = !1;
    return t.state === "input-streaming" || t.state === "input-available" ? s = t.input || {} : t.state === "output-available" ? (s = t.input || {}, l = t.output) : t.state === "output-error" && (s = t.input || {}, c = !0, l = { error: t.errorText }), {
      type: "tool-call",
      toolName: i,
      toolCallId: r,
      argsText: JSON.stringify(s),
      args: s,
      result: l,
      isError: c
    };
  }
  return n === "source-url" ? {
    type: "source",
    sourceType: "url",
    id: t.sourceId,
    url: t.url,
    title: t.title || ""
  } : n === "source-document" ? (console.warn(
    `Source document part type ${n} is not yet supported in conversion`
  ), null) : n === "file" ? {
    type: "file",
    data: t.url,
    mimeType: t.mediaType
  } : n.startsWith("data-") ? (console.warn(
    `Data part type ${n} is not yet supported in conversion`
  ), null) : (console.warn(`Unsupported message part type: ${n}`), null);
}).filter(Boolean), kk = tL(
  (e) => {
    const t = /* @__PURE__ */ new Date();
    switch (e.role) {
      case "user":
        return {
          role: "user",
          id: e.id,
          createdAt: t,
          content: qm(e),
          attachments: e.parts?.filter((n) => n.type === "file").map((n, i) => ({
            id: i.toString(),
            type: "file",
            name: n.name ?? n.url ?? "file",
            content: [],
            contentType: n.mediaType ?? n.mimeType ?? "unknown/unknown",
            status: { type: "complete" }
          }))
        };
      case "system":
        return {
          role: "system",
          id: e.id,
          createdAt: t,
          content: qm(e)
        };
      case "assistant":
        return {
          role: "assistant",
          id: e.id,
          createdAt: t,
          content: qm(e),
          metadata: {
            unstable_annotations: e.annotations,
            unstable_data: Array.isArray(e.data) ? e.data : e.data ? [e.data] : void 0,
            custom: {}
          }
        };
      default:
        return console.warn(`Unsupported message role: ${e.role}`), [];
    }
  }
), Z7 = {
  format: "ai-sdk/v5",
  encode({
    message: { id: e, parts: t, ...n }
  }) {
    return {
      ...n,
      parts: t.filter((i) => i.type !== "file")
    };
  },
  decode(e) {
    return {
      parentId: e.parent_id,
      message: {
        id: e.id,
        ...e.content
      }
    };
  },
  getId(e) {
    return e.id;
  }
}, { MessageRepository: V7 } = V$, F7 = (e, t) => ({
  headId: t.headId,
  messages: t.messages.map((n) => {
    const i = e([n.message])[0];
    return {
      ...n,
      message: i
    };
  })
}), H7 = (e, t, n, i, r) => {
  const s = $.useRef(!1), [l, c] = $.useState(!0), f = $.useRef(/* @__PURE__ */ new Set()), h = $.useRef(() => r);
  return $.useEffect(() => {
    h.current = r;
  }), $.useEffect(() => {
    if (!t || s.current) return;
    const p = async () => {
      c(!0);
      try {
        const m = await t.withFormat?.(i).load();
        if (m && m.messages.length > 0) {
          const y = F7(n, m);
          e.current.thread.import(y);
          const b = new V7();
          b.import(y);
          const x = b.getMessages();
          h.current(
            x.map(Za).flat()
          ), f.current = new Set(
            y.messages.map((w) => w.message.id)
          );
        }
      } catch (m) {
        console.error("Failed to load message history:", m);
      } finally {
        c(!1);
      }
    };
    s.current || (s.current = !0, p());
  }, [t, i, n, e]), $.useEffect(() => e.current.thread.subscribe(async () => {
    const { messages: p, isRunning: m } = e.current.thread.getState();
    if (!m)
      for (let y = 0; y < p.length; y++) {
        const b = p[y];
        if (b.status === void 0 || b.status.type === "complete" || b.status.type === "incomplete") {
          if (f.current.has(b.id)) return;
          f.current.add(b.id);
          const x = y > 0 ? p[y - 1].id : null;
          await t?.withFormat?.(i).append({
            parentId: x,
            message: Za(b)[0]
          });
        }
      }
  }), [t, i, e]), l;
}, q7 = (e, t = {}) => {
  const n = kk.useThreadMessages({
    isRunning: e.status === "submitted" || e.status == "streaming",
    messages: e.messages
  }), i = H7(
    $.useMemo(
      () => ({
        get current() {
          return r;
        }
      }),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    ),
    t.adapters?.history,
    kk.toThreadMessages,
    Z7,
    (s) => {
      e.setMessages(s);
    }
  ), r = $U({
    isRunning: e.status === "submitted" || e.status === "streaming",
    messages: n,
    setMessages: (s) => e.setMessages(
      s.map(B7).flat()
    ),
    onCancel: async () => e.stop(),
    onNew: async (s) => {
      const l = await Sk(s);
      await e.sendMessage(l, {
        metadata: s.runConfig
      });
    },
    onEdit: async (s) => {
      const l = J1(
        e.messages,
        s.parentId
      );
      e.setMessages(l);
      const c = await Sk(s);
      await e.sendMessage(c, {
        metadata: s.runConfig
      });
    },
    onReload: async (s, l) => {
      const c = J1(e.messages, s);
      e.setMessages(c), await e.regenerate({ metadata: l.runConfig });
    },
    onAddToolResult: ({ toolCallId: s, result: l }) => {
      e.addToolResult({
        tool: s,
        toolCallId: s,
        output: l
      });
    },
    adapters: {
      attachments: L7,
      ...t.adapters
    },
    isLoading: i
  });
  return r;
}, Gm, Tk;
function G7() {
  if (Tk) return Gm;
  Tk = 1;
  function e(t, n) {
    if (typeof t != "function")
      throw new TypeError(`Expected the first argument to be a \`function\`, got \`${typeof t}\`.`);
    let i, r = 0;
    return function(...l) {
      clearTimeout(i);
      const c = Date.now(), f = c - r, h = n - f;
      h <= 0 ? (r = c, t.apply(this, l)) : i = setTimeout(() => {
        r = Date.now(), t.apply(this, l);
      }, h);
    };
  }
  return Gm = e, Gm;
}
var Y7 = /* @__PURE__ */ G7();
const J7 = /* @__PURE__ */ la(Y7);
var Yz = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, ht = (e, t, n) => (Yz(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Pr = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Xi = (e, t, n, i) => (Yz(e, t, "write to private field"), t.set(e, n), n);
function X7(e, t) {
  return t != null ? J7(e, t) : e;
}
var or, Ud, Ld, Ll, Bl, Zl, Gs, Gg, Yg, K7 = class {
  constructor(e = []) {
    Pr(this, or, void 0), Pr(this, Ud, "ready"), Pr(this, Ld, void 0), Pr(this, Ll, /* @__PURE__ */ new Set()), Pr(this, Bl, /* @__PURE__ */ new Set()), Pr(this, Zl, /* @__PURE__ */ new Set()), this.pushMessage = (t) => {
      Xi(this, or, ht(this, or).concat(t)), ht(this, Gs).call(this);
    }, this.popMessage = () => {
      Xi(this, or, ht(this, or).slice(0, -1)), ht(this, Gs).call(this);
    }, this.replaceMessage = (t, n) => {
      Xi(this, or, [
        ...ht(this, or).slice(0, t),
        // We deep clone the message here to ensure the new React Compiler (currently in RC) detects deeply nested parts/metadata changes:
        this.snapshot(n),
        ...ht(this, or).slice(t + 1)
      ]), ht(this, Gs).call(this);
    }, this.snapshot = (t) => structuredClone(t), this["~registerMessagesCallback"] = (t, n) => {
      const i = n ? X7(t, n) : t;
      return ht(this, Ll).add(i), () => {
        ht(this, Ll).delete(i);
      };
    }, this["~registerStatusCallback"] = (t) => (ht(this, Bl).add(t), () => {
      ht(this, Bl).delete(t);
    }), this["~registerErrorCallback"] = (t) => (ht(this, Zl).add(t), () => {
      ht(this, Zl).delete(t);
    }), Pr(this, Gs, () => {
      ht(this, Ll).forEach((t) => t());
    }), Pr(this, Gg, () => {
      ht(this, Bl).forEach((t) => t());
    }), Pr(this, Yg, () => {
      ht(this, Zl).forEach((t) => t());
    }), Xi(this, or, e);
  }
  get status() {
    return ht(this, Ud);
  }
  set status(e) {
    Xi(this, Ud, e), ht(this, Gg).call(this);
  }
  get error() {
    return ht(this, Ld);
  }
  set error(e) {
    Xi(this, Ld, e), ht(this, Yg).call(this);
  }
  get messages() {
    return ht(this, or);
  }
  set messages(e) {
    Xi(this, or, [...e]), ht(this, Gs).call(this);
  }
};
or = /* @__PURE__ */ new WeakMap();
Ud = /* @__PURE__ */ new WeakMap();
Ld = /* @__PURE__ */ new WeakMap();
Ll = /* @__PURE__ */ new WeakMap();
Bl = /* @__PURE__ */ new WeakMap();
Zl = /* @__PURE__ */ new WeakMap();
Gs = /* @__PURE__ */ new WeakMap();
Gg = /* @__PURE__ */ new WeakMap();
Yg = /* @__PURE__ */ new WeakMap();
var Ys, Ek = class extends z7 {
  constructor({ messages: e, ...t }) {
    const n = new K7(e);
    super({ ...t, state: n }), Pr(this, Ys, void 0), this["~registerMessagesCallback"] = (i, r) => ht(this, Ys)["~registerMessagesCallback"](i, r), this["~registerStatusCallback"] = (i) => ht(this, Ys)["~registerStatusCallback"](i), this["~registerErrorCallback"] = (i) => ht(this, Ys)["~registerErrorCallback"](i), Xi(this, Ys, n);
  }
};
Ys = /* @__PURE__ */ new WeakMap();
function W7({
  experimental_throttle: e,
  resume: t = !1,
  ...n
} = {}) {
  const i = $.useRef(
    "chat" in n ? n.chat : new Ek(n)
  );
  ("chat" in n && n.chat !== i.current || "id" in n && i.current.id !== n.id) && (i.current = "chat" in n ? n.chat : new Ek(n));
  const s = "id" in n ? n.id : null, l = $.useCallback(
    (m) => i.current["~registerMessagesCallback"](m, e),
    // optionsId is required to trigger re-subscription when the chat ID changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [e, s]
  ), c = $.useSyncExternalStore(
    l,
    () => i.current.messages,
    () => i.current.messages
  ), f = $.useSyncExternalStore(
    i.current["~registerStatusCallback"],
    () => i.current.status,
    () => i.current.status
  ), h = $.useSyncExternalStore(
    i.current["~registerErrorCallback"],
    () => i.current.error,
    () => i.current.error
  ), p = $.useCallback(
    (m) => {
      typeof m == "function" && (m = m(i.current.messages)), i.current.messages = m;
    },
    [i]
  );
  return $.useEffect(() => {
    t && i.current.resumeStream();
  }, [t, i]), {
    id: i.current.id,
    messages: c,
    setMessages: p,
    sendMessage: i.current.sendMessage,
    regenerate: i.current.regenerate,
    clearError: i.current.clearError,
    stop: i.current.stop,
    error: h,
    resumeStream: i.current.resumeStream,
    status: f,
    addToolResult: i.current.addToolResult
  };
}
const Jz = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function B(e, t, n) {
  function i(c, f) {
    var h;
    Object.defineProperty(c, "_zod", {
      value: c._zod ?? {},
      enumerable: !1
    }), (h = c._zod).traits ?? (h.traits = /* @__PURE__ */ new Set()), c._zod.traits.add(e), t(c, f);
    for (const p in l.prototype)
      p in c || Object.defineProperty(c, p, { value: l.prototype[p].bind(c) });
    c._zod.constr = l, c._zod.def = f;
  }
  const r = n?.Parent ?? Object;
  class s extends r {
  }
  Object.defineProperty(s, "name", { value: e });
  function l(c) {
    var f;
    const h = n?.Parent ? new s() : this;
    i(h, c), (f = h._zod).deferred ?? (f.deferred = []);
    for (const p of h._zod.deferred)
      p();
    return h;
  }
  return Object.defineProperty(l, "init", { value: i }), Object.defineProperty(l, Symbol.hasInstance, {
    value: (c) => n?.Parent && c instanceof n.Parent ? !0 : c?._zod?.traits?.has(e)
  }), Object.defineProperty(l, "name", { value: e }), l;
}
const Xz = Symbol("zod_brand");
class Va extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class Lf extends Error {
  constructor(t) {
    super(`Encountered unidirectional transform during encode: ${t}`), this.name = "ZodEncodeError";
  }
}
const lf = {};
function vn(e) {
  return e && Object.assign(lf, e), lf;
}
function Q7(e) {
  return e;
}
function eH(e) {
  return e;
}
function tH(e) {
}
function nH(e) {
  throw new Error();
}
function rH(e) {
}
function Sy(e) {
  const t = Object.values(e).filter((i) => typeof i == "number");
  return Object.entries(e).filter(([i, r]) => t.indexOf(+i) === -1).map(([i, r]) => r);
}
function de(e, t = "|") {
  return e.map((n) => Re(n)).join(t);
}
function uf(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function Iu(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function es(e) {
  return e == null;
}
function Bf(e) {
  const t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
function Kz(e, t) {
  const n = (e.toString().split(".")[1] || "").length, i = t.toString();
  let r = (i.split(".")[1] || "").length;
  if (r === 0 && /\d?e-\d?/.test(i)) {
    const f = i.match(/\d?e-(\d?)/);
    f?.[1] && (r = Number.parseInt(f[1]));
  }
  const s = n > r ? n : r, l = Number.parseInt(e.toFixed(s).replace(".", "")), c = Number.parseInt(t.toFixed(s).replace(".", ""));
  return l % c / 10 ** s;
}
const $k = Symbol("evaluating");
function He(e, t, n) {
  let i;
  Object.defineProperty(e, t, {
    get() {
      if (i !== $k)
        return i === void 0 && (i = $k, i = n()), i;
    },
    set(r) {
      Object.defineProperty(e, t, {
        value: r
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function Zf(e) {
  return Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e));
}
function Ir(e, t, n) {
  Object.defineProperty(e, t, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function ca(...e) {
  const t = {};
  for (const n of e) {
    const i = Object.getOwnPropertyDescriptors(n);
    Object.assign(t, i);
  }
  return Object.defineProperties({}, t);
}
function iH(e) {
  return ca(e._zod.def);
}
function aH(e, t) {
  return t ? t.reduce((n, i) => n?.[i], e) : e;
}
function sH(e) {
  const t = Object.keys(e), n = t.map((i) => e[i]);
  return Promise.all(n).then((i) => {
    const r = {};
    for (let s = 0; s < t.length; s++)
      r[t[s]] = i[s];
    return r;
  });
}
function oH(e = 10) {
  const t = "abcdefghijklmnopqrstuvwxyz";
  let n = "";
  for (let i = 0; i < e; i++)
    n += t[Math.floor(Math.random() * t.length)];
  return n;
}
function Jg(e) {
  return JSON.stringify(e);
}
const ky = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function uo(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const Wz = Iu(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function Ga(e) {
  if (uo(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const n = t.prototype;
  return !(uo(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1);
}
function Vf(e) {
  return Ga(e) ? { ...e } : e;
}
function lH(e) {
  let t = 0;
  for (const n in e)
    Object.prototype.hasOwnProperty.call(e, n) && t++;
  return t;
}
const uH = (e) => {
  const t = typeof e;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(e) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      return Array.isArray(e) ? "array" : e === null ? "null" : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? "promise" : typeof Map < "u" && e instanceof Map ? "map" : typeof Set < "u" && e instanceof Set ? "set" : typeof Date < "u" && e instanceof Date ? "date" : typeof File < "u" && e instanceof File ? "file" : "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, cf = /* @__PURE__ */ new Set(["string", "number", "symbol"]), Qz = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function aa(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function dr(e, t, n) {
  const i = new e._zod.constr(t ?? e._zod.def);
  return (!t || n?.parent) && (i._zod.parent = e), i;
}
function ne(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function cH(e) {
  let t;
  return new Proxy({}, {
    get(n, i, r) {
      return t ?? (t = e()), Reflect.get(t, i, r);
    },
    set(n, i, r, s) {
      return t ?? (t = e()), Reflect.set(t, i, r, s);
    },
    has(n, i) {
      return t ?? (t = e()), Reflect.has(t, i);
    },
    deleteProperty(n, i) {
      return t ?? (t = e()), Reflect.deleteProperty(t, i);
    },
    ownKeys(n) {
      return t ?? (t = e()), Reflect.ownKeys(t);
    },
    getOwnPropertyDescriptor(n, i) {
      return t ?? (t = e()), Reflect.getOwnPropertyDescriptor(t, i);
    },
    defineProperty(n, i, r) {
      return t ?? (t = e()), Reflect.defineProperty(t, i, r);
    }
  });
}
function Re(e) {
  return typeof e == "bigint" ? e.toString() + "n" : typeof e == "string" ? `"${e}"` : `${e}`;
}
function eI(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const tI = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
}, nI = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function rI(e, t) {
  const n = e._zod.def, i = ca(e._zod.def, {
    get shape() {
      const r = {};
      for (const s in t) {
        if (!(s in n.shape))
          throw new Error(`Unrecognized key: "${s}"`);
        t[s] && (r[s] = n.shape[s]);
      }
      return Ir(this, "shape", r), r;
    },
    checks: []
  });
  return dr(e, i);
}
function iI(e, t) {
  const n = e._zod.def, i = ca(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape };
      for (const s in t) {
        if (!(s in n.shape))
          throw new Error(`Unrecognized key: "${s}"`);
        t[s] && delete r[s];
      }
      return Ir(this, "shape", r), r;
    },
    checks: []
  });
  return dr(e, i);
}
function aI(e, t) {
  if (!Ga(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const n = e._zod.def.checks;
  if (n && n.length > 0)
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  const r = ca(e._zod.def, {
    get shape() {
      const s = { ...e._zod.def.shape, ...t };
      return Ir(this, "shape", s), s;
    },
    checks: []
  });
  return dr(e, r);
}
function sI(e, t) {
  if (!Ga(t))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const n = {
    ...e._zod.def,
    get shape() {
      const i = { ...e._zod.def.shape, ...t };
      return Ir(this, "shape", i), i;
    },
    checks: e._zod.def.checks
  };
  return dr(e, n);
}
function oI(e, t) {
  const n = ca(e._zod.def, {
    get shape() {
      const i = { ...e._zod.def.shape, ...t._zod.def.shape };
      return Ir(this, "shape", i), i;
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return dr(e, n);
}
function lI(e, t, n) {
  const i = ca(t._zod.def, {
    get shape() {
      const r = t._zod.def.shape, s = { ...r };
      if (n)
        for (const l in n) {
          if (!(l in r))
            throw new Error(`Unrecognized key: "${l}"`);
          n[l] && (s[l] = e ? new e({
            type: "optional",
            innerType: r[l]
          }) : r[l]);
        }
      else
        for (const l in r)
          s[l] = e ? new e({
            type: "optional",
            innerType: r[l]
          }) : r[l];
      return Ir(this, "shape", s), s;
    },
    checks: []
  });
  return dr(t, i);
}
function uI(e, t, n) {
  const i = ca(t._zod.def, {
    get shape() {
      const r = t._zod.def.shape, s = { ...r };
      if (n)
        for (const l in n) {
          if (!(l in s))
            throw new Error(`Unrecognized key: "${l}"`);
          n[l] && (s[l] = new e({
            type: "nonoptional",
            innerType: r[l]
          }));
        }
      else
        for (const l in r)
          s[l] = new e({
            type: "nonoptional",
            innerType: r[l]
          });
      return Ir(this, "shape", s), s;
    },
    checks: []
  });
  return dr(t, i);
}
function Pa(e, t = 0) {
  if (e.aborted === !0)
    return !0;
  for (let n = t; n < e.issues.length; n++)
    if (e.issues[n]?.continue !== !0)
      return !0;
  return !1;
}
function wr(e, t) {
  return t.map((n) => {
    var i;
    return (i = n).path ?? (i.path = []), n.path.unshift(e), n;
  });
}
function Vl(e) {
  return typeof e == "string" ? e : e?.message;
}
function $r(e, t, n) {
  const i = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const r = Vl(e.inst?._zod.def?.error?.(e)) ?? Vl(t?.error?.(e)) ?? Vl(n.customError?.(e)) ?? Vl(n.localeError?.(e)) ?? "Invalid input";
    i.message = r;
  }
  return delete i.inst, delete i.continue, t?.reportInput || delete i.input, i;
}
function Ff(e) {
  return e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof File ? "file" : "unknown";
}
function Hf(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function co(...e) {
  const [t, n, i] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: n,
    inst: i
  } : { ...t };
}
function dH(e) {
  return Object.entries(e).filter(([t, n]) => Number.isNaN(Number.parseInt(t, 10))).map((t) => t[1]);
}
function cI(e) {
  const t = atob(e), n = new Uint8Array(t.length);
  for (let i = 0; i < t.length; i++)
    n[i] = t.charCodeAt(i);
  return n;
}
function dI(e) {
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += String.fromCharCode(e[n]);
  return btoa(t);
}
function fH(e) {
  const t = e.replace(/-/g, "+").replace(/_/g, "/"), n = "=".repeat((4 - t.length % 4) % 4);
  return cI(t + n);
}
function hH(e) {
  return dI(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function pH(e) {
  const t = e.replace(/^0x/, "");
  if (t.length % 2 !== 0)
    throw new Error("Invalid hex string length");
  const n = new Uint8Array(t.length / 2);
  for (let i = 0; i < t.length; i += 2)
    n[i / 2] = Number.parseInt(t.slice(i, i + 2), 16);
  return n;
}
function mH(e) {
  return Array.from(e).map((t) => t.toString(16).padStart(2, "0")).join("");
}
class gH {
  constructor(...t) {
  }
}
const vH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BIGINT_FORMAT_RANGES: nI,
  Class: gH,
  NUMBER_FORMAT_RANGES: tI,
  aborted: Pa,
  allowsEval: Wz,
  assert: rH,
  assertEqual: Q7,
  assertIs: tH,
  assertNever: nH,
  assertNotEqual: eH,
  assignProp: Ir,
  base64ToUint8Array: cI,
  base64urlToUint8Array: fH,
  cached: Iu,
  captureStackTrace: ky,
  cleanEnum: dH,
  cleanRegex: Bf,
  clone: dr,
  cloneDef: iH,
  createTransparentProxy: cH,
  defineLazy: He,
  esc: Jg,
  escapeRegex: aa,
  extend: aI,
  finalizeIssue: $r,
  floatSafeRemainder: Kz,
  getElementAtPath: aH,
  getEnumValues: Sy,
  getLengthableOrigin: Hf,
  getParsedType: uH,
  getSizableOrigin: Ff,
  hexToUint8Array: pH,
  isObject: uo,
  isPlainObject: Ga,
  issue: co,
  joinValues: de,
  jsonStringifyReplacer: uf,
  merge: oI,
  mergeDefs: ca,
  normalizeParams: ne,
  nullish: es,
  numKeys: lH,
  objectClone: Zf,
  omit: iI,
  optionalKeys: eI,
  partial: lI,
  pick: rI,
  prefixIssues: wr,
  primitiveTypes: Qz,
  promiseAllObject: sH,
  propertyKeyTypes: cf,
  randomString: oH,
  required: uI,
  safeExtend: sI,
  shallowClone: Vf,
  stringifyPrimitive: Re,
  uint8ArrayToBase64: dI,
  uint8ArrayToBase64url: hH,
  uint8ArrayToHex: mH,
  unwrapMessage: Vl
}, Symbol.toStringTag, { value: "Module" })), fI = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), e.message = JSON.stringify(t, uf, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, Ty = /* @__PURE__ */ B("$ZodError", fI), Gn = /* @__PURE__ */ B("$ZodError", fI, { Parent: Error });
function Ey(e, t = (n) => n.message) {
  const n = {}, i = [];
  for (const r of e.issues)
    r.path.length > 0 ? (n[r.path[0]] = n[r.path[0]] || [], n[r.path[0]].push(t(r))) : i.push(t(r));
  return { formErrors: i, fieldErrors: n };
}
function $y(e, t) {
  const n = t || function(s) {
    return s.message;
  }, i = { _errors: [] }, r = (s) => {
    for (const l of s.issues)
      if (l.code === "invalid_union" && l.errors.length)
        l.errors.map((c) => r({ issues: c }));
      else if (l.code === "invalid_key")
        r({ issues: l.issues });
      else if (l.code === "invalid_element")
        r({ issues: l.issues });
      else if (l.path.length === 0)
        i._errors.push(n(l));
      else {
        let c = i, f = 0;
        for (; f < l.path.length; ) {
          const h = l.path[f];
          f === l.path.length - 1 ? (c[h] = c[h] || { _errors: [] }, c[h]._errors.push(n(l))) : c[h] = c[h] || { _errors: [] }, c = c[h], f++;
        }
      }
  };
  return r(e), i;
}
function hI(e, t) {
  const n = t || function(s) {
    return s.message;
  }, i = { errors: [] }, r = (s, l = []) => {
    var c, f;
    for (const h of s.issues)
      if (h.code === "invalid_union" && h.errors.length)
        h.errors.map((p) => r({ issues: p }, h.path));
      else if (h.code === "invalid_key")
        r({ issues: h.issues }, h.path);
      else if (h.code === "invalid_element")
        r({ issues: h.issues }, h.path);
      else {
        const p = [...l, ...h.path];
        if (p.length === 0) {
          i.errors.push(n(h));
          continue;
        }
        let m = i, y = 0;
        for (; y < p.length; ) {
          const b = p[y], x = y === p.length - 1;
          typeof b == "string" ? (m.properties ?? (m.properties = {}), (c = m.properties)[b] ?? (c[b] = { errors: [] }), m = m.properties[b]) : (m.items ?? (m.items = []), (f = m.items)[b] ?? (f[b] = { errors: [] }), m = m.items[b]), x && m.errors.push(n(h)), y++;
        }
      }
  };
  return r(e), i;
}
function pI(e) {
  const t = [], n = e.map((i) => typeof i == "object" ? i.key : i);
  for (const i of n)
    typeof i == "number" ? t.push(`[${i}]`) : typeof i == "symbol" ? t.push(`[${JSON.stringify(String(i))}]`) : /[^\w$]/.test(i) ? t.push(`[${JSON.stringify(i)}]`) : (t.length && t.push("."), t.push(i));
  return t.join("");
}
function mI(e) {
  const t = [], n = [...e.issues].sort((i, r) => (i.path ?? []).length - (r.path ?? []).length);
  for (const i of n)
    t.push(` ${i.message}`), i.path?.length && t.push(`   at ${pI(i.path)}`);
  return t.join(`
`);
}
const Cu = (e) => (t, n, i, r) => {
  const s = i ? Object.assign(i, { async: !1 }) : { async: !1 }, l = t._zod.run({ value: n, issues: [] }, s);
  if (l instanceof Promise)
    throw new Va();
  if (l.issues.length) {
    const c = new (r?.Err ?? e)(l.issues.map((f) => $r(f, s, vn())));
    throw ky(c, r?.callee), c;
  }
  return l.value;
}, Xg = /* @__PURE__ */ Cu(Gn), Ou = (e) => async (t, n, i, r) => {
  const s = i ? Object.assign(i, { async: !0 }) : { async: !0 };
  let l = t._zod.run({ value: n, issues: [] }, s);
  if (l instanceof Promise && (l = await l), l.issues.length) {
    const c = new (r?.Err ?? e)(l.issues.map((f) => $r(f, s, vn())));
    throw ky(c, r?.callee), c;
  }
  return l.value;
}, Kg = /* @__PURE__ */ Ou(Gn), Ru = (e) => (t, n, i) => {
  const r = i ? { ...i, async: !1 } : { async: !1 }, s = t._zod.run({ value: n, issues: [] }, r);
  if (s instanceof Promise)
    throw new Va();
  return s.issues.length ? {
    success: !1,
    error: new (e ?? Ty)(s.issues.map((l) => $r(l, r, vn())))
  } : { success: !0, data: s.value };
}, gI = /* @__PURE__ */ Ru(Gn), Nu = (e) => async (t, n, i) => {
  const r = i ? Object.assign(i, { async: !0 }) : { async: !0 };
  let s = t._zod.run({ value: n, issues: [] }, r);
  return s instanceof Promise && (s = await s), s.issues.length ? {
    success: !1,
    error: new e(s.issues.map((l) => $r(l, r, vn())))
  } : { success: !0, data: s.value };
}, vI = /* @__PURE__ */ Nu(Gn), Ay = (e) => (t, n, i) => {
  const r = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" };
  return Cu(e)(t, n, r);
}, yH = /* @__PURE__ */ Ay(Gn), zy = (e) => (t, n, i) => Cu(e)(t, n, i), bH = /* @__PURE__ */ zy(Gn), Iy = (e) => async (t, n, i) => {
  const r = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" };
  return Ou(e)(t, n, r);
}, xH = /* @__PURE__ */ Iy(Gn), Cy = (e) => async (t, n, i) => Ou(e)(t, n, i), wH = /* @__PURE__ */ Cy(Gn), Oy = (e) => (t, n, i) => {
  const r = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" };
  return Ru(e)(t, n, r);
}, _H = /* @__PURE__ */ Oy(Gn), Ry = (e) => (t, n, i) => Ru(e)(t, n, i), SH = /* @__PURE__ */ Ry(Gn), Ny = (e) => async (t, n, i) => {
  const r = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" };
  return Nu(e)(t, n, r);
}, kH = /* @__PURE__ */ Ny(Gn), My = (e) => async (t, n, i) => Nu(e)(t, n, i), TH = /* @__PURE__ */ My(Gn), yI = /^[cC][^\s-]{8,}$/, bI = /^[0-9a-z]+$/, xI = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, wI = /^[0-9a-vA-V]{20}$/, _I = /^[A-Za-z0-9]{27}$/, SI = /^[a-zA-Z0-9_-]{21}$/, kI = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, EH = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, TI = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, fo = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, $H = /* @__PURE__ */ fo(4), AH = /* @__PURE__ */ fo(6), zH = /* @__PURE__ */ fo(7), EI = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, IH = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, CH = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, OH = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, RH = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, NH = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, MH = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function $I() {
  return new RegExp(MH, "u");
}
const AI = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, zI = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/, II = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, CI = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, OI = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, Dy = /^[A-Za-z0-9_-]*$/, jy = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, RI = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, NI = /^\+(?:[0-9]){6,14}[0-9]$/, MI = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", DI = /* @__PURE__ */ new RegExp(`^${MI}$`);
function jI(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function PI(e) {
  return new RegExp(`^${jI(e)}$`);
}
function UI(e) {
  const t = jI({ precision: e.precision }), n = ["Z"];
  e.local && n.push(""), e.offset && n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const i = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${MI}T(?:${i})$`);
}
const LI = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, BI = /^\d+n?$/, ZI = /^\d+$/, VI = /^-?\d+(?:\.\d+)?/i, FI = /true|false/i, HI = /null/i, qI = /undefined/i, GI = /^[^A-Z]*$/, YI = /^[^a-z]*$/, JI = /^[0-9a-fA-F]*$/;
function Mu(e, t) {
  return new RegExp(`^[A-Za-z0-9+/]{${e}}${t}$`);
}
function Du(e) {
  return new RegExp(`^[A-Za-z0-9-_]{${e}}$`);
}
const DH = /^[0-9a-fA-F]{32}$/, jH = /* @__PURE__ */ Mu(22, "=="), PH = /* @__PURE__ */ Du(22), UH = /^[0-9a-fA-F]{40}$/, LH = /* @__PURE__ */ Mu(27, "="), BH = /* @__PURE__ */ Du(27), ZH = /^[0-9a-fA-F]{64}$/, VH = /* @__PURE__ */ Mu(43, "="), FH = /* @__PURE__ */ Du(43), HH = /^[0-9a-fA-F]{96}$/, qH = /* @__PURE__ */ Mu(64, ""), GH = /* @__PURE__ */ Du(64), YH = /^[0-9a-fA-F]{128}$/, JH = /* @__PURE__ */ Mu(86, "=="), XH = /* @__PURE__ */ Du(86), Py = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: OI,
  base64url: Dy,
  bigint: BI,
  boolean: FI,
  browserEmail: NH,
  cidrv4: II,
  cidrv6: CI,
  cuid: yI,
  cuid2: bI,
  date: DI,
  datetime: UI,
  domain: RI,
  duration: kI,
  e164: NI,
  email: EI,
  emoji: $I,
  extendedDuration: EH,
  guid: TI,
  hex: JI,
  hostname: jy,
  html5Email: IH,
  idnEmail: RH,
  integer: ZI,
  ipv4: AI,
  ipv6: zI,
  ksuid: _I,
  lowercase: GI,
  md5_base64: jH,
  md5_base64url: PH,
  md5_hex: DH,
  nanoid: SI,
  null: HI,
  number: VI,
  rfc5322Email: CH,
  sha1_base64: LH,
  sha1_base64url: BH,
  sha1_hex: UH,
  sha256_base64: VH,
  sha256_base64url: FH,
  sha256_hex: ZH,
  sha384_base64: qH,
  sha384_base64url: GH,
  sha384_hex: HH,
  sha512_base64: JH,
  sha512_base64url: XH,
  sha512_hex: YH,
  string: LI,
  time: PI,
  ulid: xI,
  undefined: qI,
  unicodeEmail: OH,
  uppercase: YI,
  uuid: fo,
  uuid4: $H,
  uuid6: AH,
  uuid7: zH,
  xid: wI
}, Symbol.toStringTag, { value: "Module" })), At = /* @__PURE__ */ B("$ZodCheck", (e, t) => {
  var n;
  e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []);
}), XI = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, Uy = /* @__PURE__ */ B("$ZodCheckLessThan", (e, t) => {
  At.init(e, t);
  const n = XI[typeof t.value];
  e._zod.onattach.push((i) => {
    const r = i._zod.bag, s = (t.inclusive ? r.maximum : r.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < s && (t.inclusive ? r.maximum = t.value : r.exclusiveMaximum = t.value);
  }), e._zod.check = (i) => {
    (t.inclusive ? i.value <= t.value : i.value < t.value) || i.issues.push({
      origin: n,
      code: "too_big",
      maximum: t.value,
      input: i.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), Ly = /* @__PURE__ */ B("$ZodCheckGreaterThan", (e, t) => {
  At.init(e, t);
  const n = XI[typeof t.value];
  e._zod.onattach.push((i) => {
    const r = i._zod.bag, s = (t.inclusive ? r.minimum : r.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > s && (t.inclusive ? r.minimum = t.value : r.exclusiveMinimum = t.value);
  }), e._zod.check = (i) => {
    (t.inclusive ? i.value >= t.value : i.value > t.value) || i.issues.push({
      origin: n,
      code: "too_small",
      minimum: t.value,
      input: i.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), KI = /* @__PURE__ */ B("$ZodCheckMultipleOf", (e, t) => {
  At.init(e, t), e._zod.onattach.push((n) => {
    var i;
    (i = n._zod.bag).multipleOf ?? (i.multipleOf = t.value);
  }), e._zod.check = (n) => {
    if (typeof n.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof n.value == "bigint" ? n.value % t.value === BigInt(0) : Kz(n.value, t.value) === 0) || n.issues.push({
      origin: typeof n.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), WI = /* @__PURE__ */ B("$ZodCheckNumberFormat", (e, t) => {
  At.init(e, t), t.format = t.format || "float64";
  const n = t.format?.includes("int"), i = n ? "int" : "number", [r, s] = tI[t.format];
  e._zod.onattach.push((l) => {
    const c = l._zod.bag;
    c.format = t.format, c.minimum = r, c.maximum = s, n && (c.pattern = ZI);
  }), e._zod.check = (l) => {
    const c = l.value;
    if (n) {
      if (!Number.isInteger(c)) {
        l.issues.push({
          expected: i,
          format: t.format,
          code: "invalid_type",
          continue: !1,
          input: c,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(c)) {
        c > 0 ? l.issues.push({
          input: c,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: i,
          continue: !t.abort
        }) : l.issues.push({
          input: c,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: i,
          continue: !t.abort
        });
        return;
      }
    }
    c < r && l.issues.push({
      origin: "number",
      input: c,
      code: "too_small",
      minimum: r,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), c > s && l.issues.push({
      origin: "number",
      input: c,
      code: "too_big",
      maximum: s,
      inst: e
    });
  };
}), QI = /* @__PURE__ */ B("$ZodCheckBigIntFormat", (e, t) => {
  At.init(e, t);
  const [n, i] = nI[t.format];
  e._zod.onattach.push((r) => {
    const s = r._zod.bag;
    s.format = t.format, s.minimum = n, s.maximum = i;
  }), e._zod.check = (r) => {
    const s = r.value;
    s < n && r.issues.push({
      origin: "bigint",
      input: s,
      code: "too_small",
      minimum: n,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), s > i && r.issues.push({
      origin: "bigint",
      input: s,
      code: "too_big",
      maximum: i,
      inst: e
    });
  };
}), eC = /* @__PURE__ */ B("$ZodCheckMaxSize", (e, t) => {
  var n;
  At.init(e, t), (n = e._zod.def).when ?? (n.when = (i) => {
    const r = i.value;
    return !es(r) && r.size !== void 0;
  }), e._zod.onattach.push((i) => {
    const r = i._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < r && (i._zod.bag.maximum = t.maximum);
  }), e._zod.check = (i) => {
    const r = i.value;
    r.size <= t.maximum || i.issues.push({
      origin: Ff(r),
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: r,
      inst: e,
      continue: !t.abort
    });
  };
}), tC = /* @__PURE__ */ B("$ZodCheckMinSize", (e, t) => {
  var n;
  At.init(e, t), (n = e._zod.def).when ?? (n.when = (i) => {
    const r = i.value;
    return !es(r) && r.size !== void 0;
  }), e._zod.onattach.push((i) => {
    const r = i._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > r && (i._zod.bag.minimum = t.minimum);
  }), e._zod.check = (i) => {
    const r = i.value;
    r.size >= t.minimum || i.issues.push({
      origin: Ff(r),
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: r,
      inst: e,
      continue: !t.abort
    });
  };
}), nC = /* @__PURE__ */ B("$ZodCheckSizeEquals", (e, t) => {
  var n;
  At.init(e, t), (n = e._zod.def).when ?? (n.when = (i) => {
    const r = i.value;
    return !es(r) && r.size !== void 0;
  }), e._zod.onattach.push((i) => {
    const r = i._zod.bag;
    r.minimum = t.size, r.maximum = t.size, r.size = t.size;
  }), e._zod.check = (i) => {
    const r = i.value, s = r.size;
    if (s === t.size)
      return;
    const l = s > t.size;
    i.issues.push({
      origin: Ff(r),
      ...l ? { code: "too_big", maximum: t.size } : { code: "too_small", minimum: t.size },
      inclusive: !0,
      exact: !0,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), rC = /* @__PURE__ */ B("$ZodCheckMaxLength", (e, t) => {
  var n;
  At.init(e, t), (n = e._zod.def).when ?? (n.when = (i) => {
    const r = i.value;
    return !es(r) && r.length !== void 0;
  }), e._zod.onattach.push((i) => {
    const r = i._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < r && (i._zod.bag.maximum = t.maximum);
  }), e._zod.check = (i) => {
    const r = i.value;
    if (r.length <= t.maximum)
      return;
    const l = Hf(r);
    i.issues.push({
      origin: l,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: r,
      inst: e,
      continue: !t.abort
    });
  };
}), iC = /* @__PURE__ */ B("$ZodCheckMinLength", (e, t) => {
  var n;
  At.init(e, t), (n = e._zod.def).when ?? (n.when = (i) => {
    const r = i.value;
    return !es(r) && r.length !== void 0;
  }), e._zod.onattach.push((i) => {
    const r = i._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > r && (i._zod.bag.minimum = t.minimum);
  }), e._zod.check = (i) => {
    const r = i.value;
    if (r.length >= t.minimum)
      return;
    const l = Hf(r);
    i.issues.push({
      origin: l,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: r,
      inst: e,
      continue: !t.abort
    });
  };
}), aC = /* @__PURE__ */ B("$ZodCheckLengthEquals", (e, t) => {
  var n;
  At.init(e, t), (n = e._zod.def).when ?? (n.when = (i) => {
    const r = i.value;
    return !es(r) && r.length !== void 0;
  }), e._zod.onattach.push((i) => {
    const r = i._zod.bag;
    r.minimum = t.length, r.maximum = t.length, r.length = t.length;
  }), e._zod.check = (i) => {
    const r = i.value, s = r.length;
    if (s === t.length)
      return;
    const l = Hf(r), c = s > t.length;
    i.issues.push({
      origin: l,
      ...c ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), ju = /* @__PURE__ */ B("$ZodCheckStringFormat", (e, t) => {
  var n, i;
  At.init(e, t), e._zod.onattach.push((r) => {
    const s = r._zod.bag;
    s.format = t.format, t.pattern && (s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(t.pattern));
  }), t.pattern ? (n = e._zod).check ?? (n.check = (r) => {
    t.pattern.lastIndex = 0, !t.pattern.test(r.value) && r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: r.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (i = e._zod).check ?? (i.check = () => {
  });
}), sC = /* @__PURE__ */ B("$ZodCheckRegex", (e, t) => {
  ju.init(e, t), e._zod.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: n.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), oC = /* @__PURE__ */ B("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = GI), ju.init(e, t);
}), lC = /* @__PURE__ */ B("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = YI), ju.init(e, t);
}), uC = /* @__PURE__ */ B("$ZodCheckIncludes", (e, t) => {
  At.init(e, t);
  const n = aa(t.includes), i = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
  t.pattern = i, e._zod.onattach.push((r) => {
    const s = r._zod.bag;
    s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(i);
  }), e._zod.check = (r) => {
    r.value.includes(t.includes, t.position) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), cC = /* @__PURE__ */ B("$ZodCheckStartsWith", (e, t) => {
  At.init(e, t);
  const n = new RegExp(`^${aa(t.prefix)}.*`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((i) => {
    const r = i._zod.bag;
    r.patterns ?? (r.patterns = /* @__PURE__ */ new Set()), r.patterns.add(n);
  }), e._zod.check = (i) => {
    i.value.startsWith(t.prefix) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), dC = /* @__PURE__ */ B("$ZodCheckEndsWith", (e, t) => {
  At.init(e, t);
  const n = new RegExp(`.*${aa(t.suffix)}$`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((i) => {
    const r = i._zod.bag;
    r.patterns ?? (r.patterns = /* @__PURE__ */ new Set()), r.patterns.add(n);
  }), e._zod.check = (i) => {
    i.value.endsWith(t.suffix) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function Ak(e, t, n) {
  e.issues.length && t.issues.push(...wr(n, e.issues));
}
const fC = /* @__PURE__ */ B("$ZodCheckProperty", (e, t) => {
  At.init(e, t), e._zod.check = (n) => {
    const i = t.schema._zod.run({
      value: n.value[t.property],
      issues: []
    }, {});
    if (i instanceof Promise)
      return i.then((r) => Ak(r, n, t.property));
    Ak(i, n, t.property);
  };
}), hC = /* @__PURE__ */ B("$ZodCheckMimeType", (e, t) => {
  At.init(e, t);
  const n = new Set(t.mime);
  e._zod.onattach.push((i) => {
    i._zod.bag.mime = t.mime;
  }), e._zod.check = (i) => {
    n.has(i.value.type) || i.issues.push({
      code: "invalid_value",
      values: t.mime,
      input: i.value.type,
      inst: e,
      continue: !t.abort
    });
  };
}), pC = /* @__PURE__ */ B("$ZodCheckOverwrite", (e, t) => {
  At.init(e, t), e._zod.check = (n) => {
    n.value = t.tx(n.value);
  };
});
class mC {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const i = t.split(`
`).filter((l) => l), r = Math.min(...i.map((l) => l.length - l.trimStart().length)), s = i.map((l) => l.slice(r)).map((l) => " ".repeat(this.indent * 2) + l);
    for (const l of s)
      this.content.push(l);
  }
  compile() {
    const t = Function, n = this?.args, r = [...(this?.content ?? [""]).map((s) => `  ${s}`)];
    return new t(...n, r.join(`
`));
  }
}
const gC = {
  major: 4,
  minor: 1,
  patch: 1
}, Ne = /* @__PURE__ */ B("$ZodType", (e, t) => {
  var n;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = gC;
  const i = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && i.unshift(e);
  for (const r of i)
    for (const s of r._zod.onattach)
      s(e);
  if (i.length === 0)
    (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const r = (l, c, f) => {
      let h = Pa(l), p;
      for (const m of c) {
        if (m._zod.def.when) {
          if (!m._zod.def.when(l))
            continue;
        } else if (h)
          continue;
        const y = l.issues.length, b = m._zod.check(l);
        if (b instanceof Promise && f?.async === !1)
          throw new Va();
        if (p || b instanceof Promise)
          p = (p ?? Promise.resolve()).then(async () => {
            await b, l.issues.length !== y && (h || (h = Pa(l, y)));
          });
        else {
          if (l.issues.length === y)
            continue;
          h || (h = Pa(l, y));
        }
      }
      return p ? p.then(() => l) : l;
    }, s = (l, c, f) => {
      if (Pa(l))
        return l.aborted = !0, l;
      const h = r(c, i, f);
      if (h instanceof Promise) {
        if (f.async === !1)
          throw new Va();
        return h.then((p) => e._zod.parse(p, f));
      }
      return e._zod.parse(h, f);
    };
    e._zod.run = (l, c) => {
      if (c.skipChecks)
        return e._zod.parse(l, c);
      if (c.direction === "backward") {
        const h = e._zod.parse({ value: l.value, issues: [] }, { ...c, skipChecks: !0 });
        return h instanceof Promise ? h.then((p) => s(p, l, c)) : s(h, l, c);
      }
      const f = e._zod.parse(l, c);
      if (f instanceof Promise) {
        if (c.async === !1)
          throw new Va();
        return f.then((h) => r(h, i, c));
      }
      return r(f, i, c);
    };
  }
  e["~standard"] = {
    validate: (r) => {
      try {
        const s = gI(e, r);
        return s.success ? { value: s.data } : { issues: s.error?.issues };
      } catch {
        return vI(e, r).then((l) => l.success ? { value: l.data } : { issues: l.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
}), Pu = /* @__PURE__ */ B("$ZodString", (e, t) => {
  Ne.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? LI(e._zod.bag), e._zod.parse = (n, i) => {
    if (t.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: e
    }), n;
  };
}), dt = /* @__PURE__ */ B("$ZodStringFormat", (e, t) => {
  ju.init(e, t), Pu.init(e, t);
}), vC = /* @__PURE__ */ B("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = TI), dt.init(e, t);
}), yC = /* @__PURE__ */ B("$ZodUUID", (e, t) => {
  if (t.version) {
    const i = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (i === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = fo(i));
  } else
    t.pattern ?? (t.pattern = fo());
  dt.init(e, t);
}), bC = /* @__PURE__ */ B("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = EI), dt.init(e, t);
}), xC = /* @__PURE__ */ B("$ZodURL", (e, t) => {
  dt.init(e, t), e._zod.check = (n) => {
    try {
      const i = n.value.trim(), r = new URL(i);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(r.hostname) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: jy.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(r.protocol.endsWith(":") ? r.protocol.slice(0, -1) : r.protocol) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.normalize ? n.value = r.href : n.value = i;
      return;
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "url",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), wC = /* @__PURE__ */ B("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = $I()), dt.init(e, t);
}), _C = /* @__PURE__ */ B("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = SI), dt.init(e, t);
}), SC = /* @__PURE__ */ B("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = yI), dt.init(e, t);
}), kC = /* @__PURE__ */ B("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = bI), dt.init(e, t);
}), TC = /* @__PURE__ */ B("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = xI), dt.init(e, t);
}), EC = /* @__PURE__ */ B("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = wI), dt.init(e, t);
}), $C = /* @__PURE__ */ B("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = _I), dt.init(e, t);
}), AC = /* @__PURE__ */ B("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = UI(t)), dt.init(e, t);
}), zC = /* @__PURE__ */ B("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = DI), dt.init(e, t);
}), IC = /* @__PURE__ */ B("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = PI(t)), dt.init(e, t);
}), CC = /* @__PURE__ */ B("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = kI), dt.init(e, t);
}), OC = /* @__PURE__ */ B("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = AI), dt.init(e, t), e._zod.onattach.push((n) => {
    const i = n._zod.bag;
    i.format = "ipv4";
  });
}), RC = /* @__PURE__ */ B("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = zI), dt.init(e, t), e._zod.onattach.push((n) => {
    const i = n._zod.bag;
    i.format = "ipv6";
  }), e._zod.check = (n) => {
    try {
      new URL(`http://[${n.value}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), NC = /* @__PURE__ */ B("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = II), dt.init(e, t);
}), MC = /* @__PURE__ */ B("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = CI), dt.init(e, t), e._zod.check = (n) => {
    const [i, r] = n.value.split("/");
    try {
      if (!r)
        throw new Error();
      const s = Number(r);
      if (`${s}` !== r)
        throw new Error();
      if (s < 0 || s > 128)
        throw new Error();
      new URL(`http://[${i}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function By(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const DC = /* @__PURE__ */ B("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = OI), dt.init(e, t), e._zod.onattach.push((n) => {
    n._zod.bag.contentEncoding = "base64";
  }), e._zod.check = (n) => {
    By(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function jC(e) {
  if (!Dy.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (i) => i === "-" ? "+" : "/"), n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return By(n);
}
const PC = /* @__PURE__ */ B("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = Dy), dt.init(e, t), e._zod.onattach.push((n) => {
    n._zod.bag.contentEncoding = "base64url";
  }), e._zod.check = (n) => {
    jC(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), UC = /* @__PURE__ */ B("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = NI), dt.init(e, t);
});
function LC(e, t = null) {
  try {
    const n = e.split(".");
    if (n.length !== 3)
      return !1;
    const [i] = n;
    if (!i)
      return !1;
    const r = JSON.parse(atob(i));
    return !("typ" in r && r?.typ !== "JWT" || !r.alg || t && (!("alg" in r) || r.alg !== t));
  } catch {
    return !1;
  }
}
const BC = /* @__PURE__ */ B("$ZodJWT", (e, t) => {
  dt.init(e, t), e._zod.check = (n) => {
    LC(n.value, t.alg) || n.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), ZC = /* @__PURE__ */ B("$ZodCustomStringFormat", (e, t) => {
  dt.init(e, t), e._zod.check = (n) => {
    t.fn(n.value) || n.issues.push({
      code: "invalid_format",
      format: t.format,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Zy = /* @__PURE__ */ B("$ZodNumber", (e, t) => {
  Ne.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? VI, e._zod.parse = (n, i) => {
    if (t.coerce)
      try {
        n.value = Number(n.value);
      } catch {
      }
    const r = n.value;
    if (typeof r == "number" && !Number.isNaN(r) && Number.isFinite(r))
      return n;
    const s = typeof r == "number" ? Number.isNaN(r) ? "NaN" : Number.isFinite(r) ? void 0 : "Infinity" : void 0;
    return n.issues.push({
      expected: "number",
      code: "invalid_type",
      input: r,
      inst: e,
      ...s ? { received: s } : {}
    }), n;
  };
}), VC = /* @__PURE__ */ B("$ZodNumber", (e, t) => {
  WI.init(e, t), Zy.init(e, t);
}), Vy = /* @__PURE__ */ B("$ZodBoolean", (e, t) => {
  Ne.init(e, t), e._zod.pattern = FI, e._zod.parse = (n, i) => {
    if (t.coerce)
      try {
        n.value = !!n.value;
      } catch {
      }
    const r = n.value;
    return typeof r == "boolean" || n.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: r,
      inst: e
    }), n;
  };
}), Fy = /* @__PURE__ */ B("$ZodBigInt", (e, t) => {
  Ne.init(e, t), e._zod.pattern = BI, e._zod.parse = (n, i) => {
    if (t.coerce)
      try {
        n.value = BigInt(n.value);
      } catch {
      }
    return typeof n.value == "bigint" || n.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: n.value,
      inst: e
    }), n;
  };
}), FC = /* @__PURE__ */ B("$ZodBigInt", (e, t) => {
  QI.init(e, t), Fy.init(e, t);
}), HC = /* @__PURE__ */ B("$ZodSymbol", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => {
    const r = n.value;
    return typeof r == "symbol" || n.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input: r,
      inst: e
    }), n;
  };
}), qC = /* @__PURE__ */ B("$ZodUndefined", (e, t) => {
  Ne.init(e, t), e._zod.pattern = qI, e._zod.values = /* @__PURE__ */ new Set([void 0]), e._zod.optin = "optional", e._zod.optout = "optional", e._zod.parse = (n, i) => {
    const r = n.value;
    return typeof r > "u" || n.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input: r,
      inst: e
    }), n;
  };
}), GC = /* @__PURE__ */ B("$ZodNull", (e, t) => {
  Ne.init(e, t), e._zod.pattern = HI, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (n, i) => {
    const r = n.value;
    return r === null || n.issues.push({
      expected: "null",
      code: "invalid_type",
      input: r,
      inst: e
    }), n;
  };
}), YC = /* @__PURE__ */ B("$ZodAny", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n) => n;
}), JC = /* @__PURE__ */ B("$ZodUnknown", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n) => n;
}), XC = /* @__PURE__ */ B("$ZodNever", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => (n.issues.push({
    expected: "never",
    code: "invalid_type",
    input: n.value,
    inst: e
  }), n);
}), KC = /* @__PURE__ */ B("$ZodVoid", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => {
    const r = n.value;
    return typeof r > "u" || n.issues.push({
      expected: "void",
      code: "invalid_type",
      input: r,
      inst: e
    }), n;
  };
}), WC = /* @__PURE__ */ B("$ZodDate", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => {
    if (t.coerce)
      try {
        n.value = new Date(n.value);
      } catch {
      }
    const r = n.value, s = r instanceof Date;
    return s && !Number.isNaN(r.getTime()) || n.issues.push({
      expected: "date",
      code: "invalid_type",
      input: r,
      ...s ? { received: "Invalid Date" } : {},
      inst: e
    }), n;
  };
});
function zk(e, t, n) {
  e.issues.length && t.issues.push(...wr(n, e.issues)), t.value[n] = e.value;
}
const QC = /* @__PURE__ */ B("$ZodArray", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => {
    const r = n.value;
    if (!Array.isArray(r))
      return n.issues.push({
        expected: "array",
        code: "invalid_type",
        input: r,
        inst: e
      }), n;
    n.value = Array(r.length);
    const s = [];
    for (let l = 0; l < r.length; l++) {
      const c = r[l], f = t.element._zod.run({
        value: c,
        issues: []
      }, i);
      f instanceof Promise ? s.push(f.then((h) => zk(h, n, l))) : zk(f, n, l);
    }
    return s.length ? Promise.all(s).then(() => n) : n;
  };
});
function df(e, t, n, i) {
  e.issues.length && t.issues.push(...wr(n, e.issues)), e.value === void 0 ? n in i && (t.value[n] = void 0) : t.value[n] = e.value;
}
function eO(e) {
  const t = Object.keys(e.shape);
  for (const i of t)
    if (!e.shape[i]._zod.traits.has("$ZodType"))
      throw new Error(`Invalid element at key "${i}": expected a Zod schema`);
  const n = eI(e.shape);
  return {
    ...e,
    keys: t,
    keySet: new Set(t),
    numKeys: t.length,
    optionalKeys: new Set(n)
  };
}
function tO(e, t, n, i, r, s) {
  const l = [], c = r.keySet, f = r.catchall._zod, h = f.def.type;
  for (const p of Object.keys(t)) {
    if (c.has(p))
      continue;
    if (h === "never") {
      l.push(p);
      continue;
    }
    const m = f.run({ value: t[p], issues: [] }, i);
    m instanceof Promise ? e.push(m.then((y) => df(y, n, p, t))) : df(m, n, p, t);
  }
  return l.length && n.issues.push({
    code: "unrecognized_keys",
    keys: l,
    input: t,
    inst: s
  }), e.length ? Promise.all(e).then(() => n) : n;
}
const nO = /* @__PURE__ */ B("$ZodObject", (e, t) => {
  Ne.init(e, t);
  const n = Iu(() => eO(t));
  He(e._zod, "propValues", () => {
    const l = t.shape, c = {};
    for (const f in l) {
      const h = l[f]._zod;
      if (h.values) {
        c[f] ?? (c[f] = /* @__PURE__ */ new Set());
        for (const p of h.values)
          c[f].add(p);
      }
    }
    return c;
  });
  const i = uo, r = t.catchall;
  let s;
  e._zod.parse = (l, c) => {
    s ?? (s = n.value);
    const f = l.value;
    if (!i(f))
      return l.issues.push({
        expected: "object",
        code: "invalid_type",
        input: f,
        inst: e
      }), l;
    l.value = {};
    const h = [], p = s.shape;
    for (const m of s.keys) {
      const b = p[m]._zod.run({ value: f[m], issues: [] }, c);
      b instanceof Promise ? h.push(b.then((x) => df(x, l, m, f))) : df(b, l, m, f);
    }
    return r ? tO(h, f, l, c, n.value, e) : h.length ? Promise.all(h).then(() => l) : l;
  };
}), rO = /* @__PURE__ */ B("$ZodObjectJIT", (e, t) => {
  nO.init(e, t);
  const n = e._zod.parse, i = Iu(() => eO(t)), r = (y) => {
    const b = new mC(["shape", "payload", "ctx"]), x = i.value, w = (z) => {
      const O = Jg(z);
      return `shape[${O}]._zod.run({ value: input[${O}], issues: [] }, ctx)`;
    };
    b.write("const input = payload.value;");
    const k = /* @__PURE__ */ Object.create(null);
    let T = 0;
    for (const z of x.keys)
      k[z] = `key_${T++}`;
    b.write("const newResult = {}");
    for (const z of x.keys) {
      const O = k[z], M = Jg(z);
      b.write(`const ${O} = ${w(z)};`), b.write(`
        if (${O}.issues.length) {
          payload.issues = payload.issues.concat(${O}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${M}, ...iss.path] : [${M}]
          })));
        }
        
        if (${O}.value === undefined) {
          if (${M} in input) {
            newResult[${M}] = undefined;
          }
        } else {
          newResult[${M}] = ${O}.value;
        }
      `);
    }
    b.write("payload.value = newResult;"), b.write("return payload;");
    const A = b.compile();
    return (z, O) => A(y, z, O);
  };
  let s;
  const l = uo, c = !lf.jitless, h = c && Wz.value, p = t.catchall;
  let m;
  e._zod.parse = (y, b) => {
    m ?? (m = i.value);
    const x = y.value;
    return l(x) ? c && h && b?.async === !1 && b.jitless !== !0 ? (s || (s = r(t.shape)), y = s(y, b), p ? tO([], x, y, b, m, e) : y) : n(y, b) : (y.issues.push({
      expected: "object",
      code: "invalid_type",
      input: x,
      inst: e
    }), y);
  };
});
function Ik(e, t, n, i) {
  for (const s of e)
    if (s.issues.length === 0)
      return t.value = s.value, t;
  const r = e.filter((s) => !Pa(s));
  return r.length === 1 ? (t.value = r[0].value, r[0]) : (t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: n,
    errors: e.map((s) => s.issues.map((l) => $r(l, i, vn())))
  }), t);
}
const Hy = /* @__PURE__ */ B("$ZodUnion", (e, t) => {
  Ne.init(e, t), He(e._zod, "optin", () => t.options.some((r) => r._zod.optin === "optional") ? "optional" : void 0), He(e._zod, "optout", () => t.options.some((r) => r._zod.optout === "optional") ? "optional" : void 0), He(e._zod, "values", () => {
    if (t.options.every((r) => r._zod.values))
      return new Set(t.options.flatMap((r) => Array.from(r._zod.values)));
  }), He(e._zod, "pattern", () => {
    if (t.options.every((r) => r._zod.pattern)) {
      const r = t.options.map((s) => s._zod.pattern);
      return new RegExp(`^(${r.map((s) => Bf(s.source)).join("|")})$`);
    }
  });
  const n = t.options.length === 1, i = t.options[0]._zod.run;
  e._zod.parse = (r, s) => {
    if (n)
      return i(r, s);
    let l = !1;
    const c = [];
    for (const f of t.options) {
      const h = f._zod.run({
        value: r.value,
        issues: []
      }, s);
      if (h instanceof Promise)
        c.push(h), l = !0;
      else {
        if (h.issues.length === 0)
          return h;
        c.push(h);
      }
    }
    return l ? Promise.all(c).then((f) => Ik(f, r, e, s)) : Ik(c, r, e, s);
  };
}), iO = /* @__PURE__ */ B("$ZodDiscriminatedUnion", (e, t) => {
  Hy.init(e, t);
  const n = e._zod.parse;
  He(e._zod, "propValues", () => {
    const r = {};
    for (const s of t.options) {
      const l = s._zod.propValues;
      if (!l || Object.keys(l).length === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(s)}"`);
      for (const [c, f] of Object.entries(l)) {
        r[c] || (r[c] = /* @__PURE__ */ new Set());
        for (const h of f)
          r[c].add(h);
      }
    }
    return r;
  });
  const i = Iu(() => {
    const r = t.options, s = /* @__PURE__ */ new Map();
    for (const l of r) {
      const c = l._zod.propValues?.[t.discriminator];
      if (!c || c.size === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(l)}"`);
      for (const f of c) {
        if (s.has(f))
          throw new Error(`Duplicate discriminator value "${String(f)}"`);
        s.set(f, l);
      }
    }
    return s;
  });
  e._zod.parse = (r, s) => {
    const l = r.value;
    if (!uo(l))
      return r.issues.push({
        code: "invalid_type",
        expected: "object",
        input: l,
        inst: e
      }), r;
    const c = i.value.get(l?.[t.discriminator]);
    return c ? c._zod.run(r, s) : t.unionFallback ? n(r, s) : (r.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: t.discriminator,
      input: l,
      path: [t.discriminator],
      inst: e
    }), r);
  };
}), aO = /* @__PURE__ */ B("$ZodIntersection", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => {
    const r = n.value, s = t.left._zod.run({ value: r, issues: [] }, i), l = t.right._zod.run({ value: r, issues: [] }, i);
    return s instanceof Promise || l instanceof Promise ? Promise.all([s, l]).then(([f, h]) => Ck(n, f, h)) : Ck(n, s, l);
  };
});
function Wg(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (Ga(e) && Ga(t)) {
    const n = Object.keys(t), i = Object.keys(e).filter((s) => n.indexOf(s) !== -1), r = { ...e, ...t };
    for (const s of i) {
      const l = Wg(e[s], t[s]);
      if (!l.valid)
        return {
          valid: !1,
          mergeErrorPath: [s, ...l.mergeErrorPath]
        };
      r[s] = l.data;
    }
    return { valid: !0, data: r };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const n = [];
    for (let i = 0; i < e.length; i++) {
      const r = e[i], s = t[i], l = Wg(r, s);
      if (!l.valid)
        return {
          valid: !1,
          mergeErrorPath: [i, ...l.mergeErrorPath]
        };
      n.push(l.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function Ck(e, t, n) {
  if (t.issues.length && e.issues.push(...t.issues), n.issues.length && e.issues.push(...n.issues), Pa(e))
    return e;
  const i = Wg(t.value, n.value);
  if (!i.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(i.mergeErrorPath)}`);
  return e.value = i.data, e;
}
const qy = /* @__PURE__ */ B("$ZodTuple", (e, t) => {
  Ne.init(e, t);
  const n = t.items, i = n.length - [...n].reverse().findIndex((r) => r._zod.optin !== "optional");
  e._zod.parse = (r, s) => {
    const l = r.value;
    if (!Array.isArray(l))
      return r.issues.push({
        input: l,
        inst: e,
        expected: "tuple",
        code: "invalid_type"
      }), r;
    r.value = [];
    const c = [];
    if (!t.rest) {
      const h = l.length > n.length, p = l.length < i - 1;
      if (h || p)
        return r.issues.push({
          ...h ? { code: "too_big", maximum: n.length } : { code: "too_small", minimum: n.length },
          input: l,
          inst: e,
          origin: "array"
        }), r;
    }
    let f = -1;
    for (const h of n) {
      if (f++, f >= l.length && f >= i)
        continue;
      const p = h._zod.run({
        value: l[f],
        issues: []
      }, s);
      p instanceof Promise ? c.push(p.then((m) => wd(m, r, f))) : wd(p, r, f);
    }
    if (t.rest) {
      const h = l.slice(n.length);
      for (const p of h) {
        f++;
        const m = t.rest._zod.run({
          value: p,
          issues: []
        }, s);
        m instanceof Promise ? c.push(m.then((y) => wd(y, r, f))) : wd(m, r, f);
      }
    }
    return c.length ? Promise.all(c).then(() => r) : r;
  };
});
function wd(e, t, n) {
  e.issues.length && t.issues.push(...wr(n, e.issues)), t.value[n] = e.value;
}
const sO = /* @__PURE__ */ B("$ZodRecord", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => {
    const r = n.value;
    if (!Ga(r))
      return n.issues.push({
        expected: "record",
        code: "invalid_type",
        input: r,
        inst: e
      }), n;
    const s = [];
    if (t.keyType._zod.values) {
      const l = t.keyType._zod.values;
      n.value = {};
      for (const f of l)
        if (typeof f == "string" || typeof f == "number" || typeof f == "symbol") {
          const h = t.valueType._zod.run({ value: r[f], issues: [] }, i);
          h instanceof Promise ? s.push(h.then((p) => {
            p.issues.length && n.issues.push(...wr(f, p.issues)), n.value[f] = p.value;
          })) : (h.issues.length && n.issues.push(...wr(f, h.issues)), n.value[f] = h.value);
        }
      let c;
      for (const f in r)
        l.has(f) || (c = c ?? [], c.push(f));
      c && c.length > 0 && n.issues.push({
        code: "unrecognized_keys",
        input: r,
        inst: e,
        keys: c
      });
    } else {
      n.value = {};
      for (const l of Reflect.ownKeys(r)) {
        if (l === "__proto__")
          continue;
        const c = t.keyType._zod.run({ value: l, issues: [] }, i);
        if (c instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (c.issues.length) {
          n.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: c.issues.map((h) => $r(h, i, vn())),
            input: l,
            path: [l],
            inst: e
          }), n.value[c.value] = c.value;
          continue;
        }
        const f = t.valueType._zod.run({ value: r[l], issues: [] }, i);
        f instanceof Promise ? s.push(f.then((h) => {
          h.issues.length && n.issues.push(...wr(l, h.issues)), n.value[c.value] = h.value;
        })) : (f.issues.length && n.issues.push(...wr(l, f.issues)), n.value[c.value] = f.value);
      }
    }
    return s.length ? Promise.all(s).then(() => n) : n;
  };
}), oO = /* @__PURE__ */ B("$ZodMap", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => {
    const r = n.value;
    if (!(r instanceof Map))
      return n.issues.push({
        expected: "map",
        code: "invalid_type",
        input: r,
        inst: e
      }), n;
    const s = [];
    n.value = /* @__PURE__ */ new Map();
    for (const [l, c] of r) {
      const f = t.keyType._zod.run({ value: l, issues: [] }, i), h = t.valueType._zod.run({ value: c, issues: [] }, i);
      f instanceof Promise || h instanceof Promise ? s.push(Promise.all([f, h]).then(([p, m]) => {
        Ok(p, m, n, l, r, e, i);
      })) : Ok(f, h, n, l, r, e, i);
    }
    return s.length ? Promise.all(s).then(() => n) : n;
  };
});
function Ok(e, t, n, i, r, s, l) {
  e.issues.length && (cf.has(typeof i) ? n.issues.push(...wr(i, e.issues)) : n.issues.push({
    code: "invalid_key",
    origin: "map",
    input: r,
    inst: s,
    issues: e.issues.map((c) => $r(c, l, vn()))
  })), t.issues.length && (cf.has(typeof i) ? n.issues.push(...wr(i, t.issues)) : n.issues.push({
    origin: "map",
    code: "invalid_element",
    input: r,
    inst: s,
    key: i,
    issues: t.issues.map((c) => $r(c, l, vn()))
  })), n.value.set(e.value, t.value);
}
const lO = /* @__PURE__ */ B("$ZodSet", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => {
    const r = n.value;
    if (!(r instanceof Set))
      return n.issues.push({
        input: r,
        inst: e,
        expected: "set",
        code: "invalid_type"
      }), n;
    const s = [];
    n.value = /* @__PURE__ */ new Set();
    for (const l of r) {
      const c = t.valueType._zod.run({ value: l, issues: [] }, i);
      c instanceof Promise ? s.push(c.then((f) => Rk(f, n))) : Rk(c, n);
    }
    return s.length ? Promise.all(s).then(() => n) : n;
  };
});
function Rk(e, t) {
  e.issues.length && t.issues.push(...e.issues), t.value.add(e.value);
}
const uO = /* @__PURE__ */ B("$ZodEnum", (e, t) => {
  Ne.init(e, t);
  const n = Sy(t.entries), i = new Set(n);
  e._zod.values = i, e._zod.pattern = new RegExp(`^(${n.filter((r) => cf.has(typeof r)).map((r) => typeof r == "string" ? aa(r) : r.toString()).join("|")})$`), e._zod.parse = (r, s) => {
    const l = r.value;
    return i.has(l) || r.issues.push({
      code: "invalid_value",
      values: n,
      input: l,
      inst: e
    }), r;
  };
}), cO = /* @__PURE__ */ B("$ZodLiteral", (e, t) => {
  if (Ne.init(e, t), t.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  e._zod.values = new Set(t.values), e._zod.pattern = new RegExp(`^(${t.values.map((n) => typeof n == "string" ? aa(n) : n ? aa(n.toString()) : String(n)).join("|")})$`), e._zod.parse = (n, i) => {
    const r = n.value;
    return e._zod.values.has(r) || n.issues.push({
      code: "invalid_value",
      values: t.values,
      input: r,
      inst: e
    }), n;
  };
}), dO = /* @__PURE__ */ B("$ZodFile", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => {
    const r = n.value;
    return r instanceof File || n.issues.push({
      expected: "file",
      code: "invalid_type",
      input: r,
      inst: e
    }), n;
  };
}), fO = /* @__PURE__ */ B("$ZodTransform", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => {
    if (i.direction === "backward")
      throw new Lf(e.constructor.name);
    const r = t.transform(n.value, n);
    if (i.async)
      return (r instanceof Promise ? r : Promise.resolve(r)).then((l) => (n.value = l, n));
    if (r instanceof Promise)
      throw new Va();
    return n.value = r, n;
  };
});
function Nk(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
const hO = /* @__PURE__ */ B("$ZodOptional", (e, t) => {
  Ne.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", He(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), He(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${Bf(n.source)})?$`) : void 0;
  }), e._zod.parse = (n, i) => {
    if (t.innerType._zod.optin === "optional") {
      const r = t.innerType._zod.run(n, i);
      return r instanceof Promise ? r.then((s) => Nk(s, n.value)) : Nk(r, n.value);
    }
    return n.value === void 0 ? n : t.innerType._zod.run(n, i);
  };
}), pO = /* @__PURE__ */ B("$ZodNullable", (e, t) => {
  Ne.init(e, t), He(e._zod, "optin", () => t.innerType._zod.optin), He(e._zod, "optout", () => t.innerType._zod.optout), He(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${Bf(n.source)}|null)$`) : void 0;
  }), He(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (n, i) => n.value === null ? n : t.innerType._zod.run(n, i);
}), mO = /* @__PURE__ */ B("$ZodDefault", (e, t) => {
  Ne.init(e, t), e._zod.optin = "optional", He(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, i) => {
    if (i.direction === "backward")
      return t.innerType._zod.run(n, i);
    if (n.value === void 0)
      return n.value = t.defaultValue, n;
    const r = t.innerType._zod.run(n, i);
    return r instanceof Promise ? r.then((s) => Mk(s, t)) : Mk(r, t);
  };
});
function Mk(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const gO = /* @__PURE__ */ B("$ZodPrefault", (e, t) => {
  Ne.init(e, t), e._zod.optin = "optional", He(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, i) => (i.direction === "backward" || n.value === void 0 && (n.value = t.defaultValue), t.innerType._zod.run(n, i));
}), vO = /* @__PURE__ */ B("$ZodNonOptional", (e, t) => {
  Ne.init(e, t), He(e._zod, "values", () => {
    const n = t.innerType._zod.values;
    return n ? new Set([...n].filter((i) => i !== void 0)) : void 0;
  }), e._zod.parse = (n, i) => {
    const r = t.innerType._zod.run(n, i);
    return r instanceof Promise ? r.then((s) => Dk(s, e)) : Dk(r, e);
  };
});
function Dk(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const yO = /* @__PURE__ */ B("$ZodSuccess", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => {
    if (i.direction === "backward")
      throw new Lf("ZodSuccess");
    const r = t.innerType._zod.run(n, i);
    return r instanceof Promise ? r.then((s) => (n.value = s.issues.length === 0, n)) : (n.value = r.issues.length === 0, n);
  };
}), bO = /* @__PURE__ */ B("$ZodCatch", (e, t) => {
  Ne.init(e, t), He(e._zod, "optin", () => t.innerType._zod.optin), He(e._zod, "optout", () => t.innerType._zod.optout), He(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, i) => {
    if (i.direction === "backward")
      return t.innerType._zod.run(n, i);
    const r = t.innerType._zod.run(n, i);
    return r instanceof Promise ? r.then((s) => (n.value = s.value, s.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: s.issues.map((l) => $r(l, i, vn()))
      },
      input: n.value
    }), n.issues = []), n)) : (n.value = r.value, r.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: r.issues.map((s) => $r(s, i, vn()))
      },
      input: n.value
    }), n.issues = []), n);
  };
}), xO = /* @__PURE__ */ B("$ZodNaN", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => ((typeof n.value != "number" || !Number.isNaN(n.value)) && n.issues.push({
    input: n.value,
    inst: e,
    expected: "nan",
    code: "invalid_type"
  }), n);
}), wO = /* @__PURE__ */ B("$ZodPipe", (e, t) => {
  Ne.init(e, t), He(e._zod, "values", () => t.in._zod.values), He(e._zod, "optin", () => t.in._zod.optin), He(e._zod, "optout", () => t.out._zod.optout), He(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (n, i) => {
    if (i.direction === "backward") {
      const s = t.out._zod.run(n, i);
      return s instanceof Promise ? s.then((l) => _d(l, t.in, i)) : _d(s, t.in, i);
    }
    const r = t.in._zod.run(n, i);
    return r instanceof Promise ? r.then((s) => _d(s, t.out, i)) : _d(r, t.out, i);
  };
});
function _d(e, t, n) {
  return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, n);
}
const Gy = /* @__PURE__ */ B("$ZodCodec", (e, t) => {
  Ne.init(e, t), He(e._zod, "values", () => t.in._zod.values), He(e._zod, "optin", () => t.in._zod.optin), He(e._zod, "optout", () => t.out._zod.optout), He(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (n, i) => {
    if ((i.direction || "forward") === "forward") {
      const s = t.in._zod.run(n, i);
      return s instanceof Promise ? s.then((l) => Sd(l, t, i)) : Sd(s, t, i);
    } else {
      const s = t.out._zod.run(n, i);
      return s instanceof Promise ? s.then((l) => Sd(l, t, i)) : Sd(s, t, i);
    }
  };
});
function Sd(e, t, n) {
  if (e.issues.length)
    return e.aborted = !0, e;
  if ((n.direction || "forward") === "forward") {
    const r = t.transform(e.value, e);
    return r instanceof Promise ? r.then((s) => kd(e, s, t.out, n)) : kd(e, r, t.out, n);
  } else {
    const r = t.reverseTransform(e.value, e);
    return r instanceof Promise ? r.then((s) => kd(e, s, t.in, n)) : kd(e, r, t.in, n);
  }
}
function kd(e, t, n, i) {
  return e.issues.length ? (e.aborted = !0, e) : n._zod.run({ value: t, issues: e.issues }, i);
}
const _O = /* @__PURE__ */ B("$ZodReadonly", (e, t) => {
  Ne.init(e, t), He(e._zod, "propValues", () => t.innerType._zod.propValues), He(e._zod, "values", () => t.innerType._zod.values), He(e._zod, "optin", () => t.innerType._zod.optin), He(e._zod, "optout", () => t.innerType._zod.optout), e._zod.parse = (n, i) => {
    if (i.direction === "backward")
      return t.innerType._zod.run(n, i);
    const r = t.innerType._zod.run(n, i);
    return r instanceof Promise ? r.then(jk) : jk(r);
  };
});
function jk(e) {
  return e.value = Object.freeze(e.value), e;
}
const SO = /* @__PURE__ */ B("$ZodTemplateLiteral", (e, t) => {
  Ne.init(e, t);
  const n = [];
  for (const i of t.parts)
    if (typeof i == "object" && i !== null) {
      if (!i._zod.pattern)
        throw new Error(`Invalid template literal part, no pattern found: ${[...i._zod.traits].shift()}`);
      const r = i._zod.pattern instanceof RegExp ? i._zod.pattern.source : i._zod.pattern;
      if (!r)
        throw new Error(`Invalid template literal part: ${i._zod.traits}`);
      const s = r.startsWith("^") ? 1 : 0, l = r.endsWith("$") ? r.length - 1 : r.length;
      n.push(r.slice(s, l));
    } else if (i === null || Qz.has(typeof i))
      n.push(aa(`${i}`));
    else
      throw new Error(`Invalid template literal part: ${i}`);
  e._zod.pattern = new RegExp(`^${n.join("")}$`), e._zod.parse = (i, r) => typeof i.value != "string" ? (i.issues.push({
    input: i.value,
    inst: e,
    expected: "template_literal",
    code: "invalid_type"
  }), i) : (e._zod.pattern.lastIndex = 0, e._zod.pattern.test(i.value) || i.issues.push({
    input: i.value,
    inst: e,
    code: "invalid_format",
    format: t.format ?? "template_literal",
    pattern: e._zod.pattern.source
  }), i);
}), kO = /* @__PURE__ */ B("$ZodFunction", (e, t) => (Ne.init(e, t), e._def = t, e._zod.def = t, e.implement = (n) => {
  if (typeof n != "function")
    throw new Error("implement() must be called with a function");
  return function(...i) {
    const r = e._def.input ? Xg(e._def.input, i) : i, s = Reflect.apply(n, this, r);
    return e._def.output ? Xg(e._def.output, s) : s;
  };
}, e.implementAsync = (n) => {
  if (typeof n != "function")
    throw new Error("implementAsync() must be called with a function");
  return async function(...i) {
    const r = e._def.input ? await Kg(e._def.input, i) : i, s = await Reflect.apply(n, this, r);
    return e._def.output ? await Kg(e._def.output, s) : s;
  };
}, e._zod.parse = (n, i) => typeof n.value != "function" ? (n.issues.push({
  code: "invalid_type",
  expected: "function",
  input: n.value,
  inst: e
}), n) : (e._def.output && e._def.output._zod.def.type === "promise" ? n.value = e.implementAsync(n.value) : n.value = e.implement(n.value), n), e.input = (...n) => {
  const i = e.constructor;
  return Array.isArray(n[0]) ? new i({
    type: "function",
    input: new qy({
      type: "tuple",
      items: n[0],
      rest: n[1]
    }),
    output: e._def.output
  }) : new i({
    type: "function",
    input: n[0],
    output: e._def.output
  });
}, e.output = (n) => {
  const i = e.constructor;
  return new i({
    type: "function",
    input: e._def.input,
    output: n
  });
}, e)), TO = /* @__PURE__ */ B("$ZodPromise", (e, t) => {
  Ne.init(e, t), e._zod.parse = (n, i) => Promise.resolve(n.value).then((r) => t.innerType._zod.run({ value: r, issues: [] }, i));
}), EO = /* @__PURE__ */ B("$ZodLazy", (e, t) => {
  Ne.init(e, t), He(e._zod, "innerType", () => t.getter()), He(e._zod, "pattern", () => e._zod.innerType._zod.pattern), He(e._zod, "propValues", () => e._zod.innerType._zod.propValues), He(e._zod, "optin", () => e._zod.innerType._zod.optin ?? void 0), He(e._zod, "optout", () => e._zod.innerType._zod.optout ?? void 0), e._zod.parse = (n, i) => e._zod.innerType._zod.run(n, i);
}), $O = /* @__PURE__ */ B("$ZodCustom", (e, t) => {
  At.init(e, t), Ne.init(e, t), e._zod.parse = (n, i) => n, e._zod.check = (n) => {
    const i = n.value, r = t.fn(i);
    if (r instanceof Promise)
      return r.then((s) => Pk(s, n, i, e));
    Pk(r, n, i, e);
  };
});
function Pk(e, t, n, i) {
  if (!e) {
    const r = {
      code: "custom",
      input: n,
      inst: i,
      // incorporates params.error into issue reporting
      path: [...i._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !i._zod.def.abort
      // params: inst._zod.def.params,
    };
    i._zod.def.params && (r.params = i._zod.def.params), t.issues.push(co(r));
  }
}
const KH = () => {
  const e = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(r))
          return "array";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: " ",
    url: "",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: "  ISO",
    time: "  ISO",
    duration: "  ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: "   IPv4",
    cidrv6: "   IPv6",
    base64: "  base64-encoded",
    base64url: "  base64url-encoded",
    json_string: "   JSON",
    e164: "   E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `  :   ${r.expected}    ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `  :   ${Re(r.values[0])}` : `  :     : ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `   :    ${r.origin ?? ""} ${s} ${r.maximum.toString()} ${l.unit ?? ""}` : `  :    ${r.origin ?? ""} ${s} ${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `  :   ${r.origin}   ${s} ${r.minimum.toString()} ${l.unit}` : `  :   ${r.origin}   ${s} ${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `  :     "${r.prefix}"` : s.format === "ends_with" ? `  :     "${s.suffix}"` : s.format === "includes" ? `  :    "${s.includes}"` : s.format === "regex" ? `  :     ${s.pattern}` : `${i[s.format] ?? r.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${r.divisor}`;
      case "unrecognized_keys":
        return `${r.keys.length > 1 ? "" : ""} ${r.keys.length > 1 ? "" : ""}: ${de(r.keys, " ")}`;
      case "invalid_key":
        return `    ${r.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${r.origin}`;
      default:
        return "  ";
    }
  };
};
function WH() {
  return {
    localeError: KH()
  };
}
const QH = () => {
  const e = {
    string: { unit: "simvol", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "element", verb: "olmaldr" },
    set: { unit: "element", verb: "olmaldr" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(r))
          return "array";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Yanl dyr: gzlniln ${r.expected}, daxil olan ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Yanl dyr: gzlniln ${Re(r.values[0])}` : `Yanl seim: aadaklardan biri olmaldr: ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `ox byk: gzlniln ${r.origin ?? "dyr"} ${s}${r.maximum.toString()} ${l.unit ?? "element"}` : `ox byk: gzlniln ${r.origin ?? "dyr"} ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `ox kiik: gzlniln ${r.origin} ${s}${r.minimum.toString()} ${l.unit}` : `ox kiik: gzlniln ${r.origin} ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Yanl mtn: "${s.prefix}" il balamaldr` : s.format === "ends_with" ? `Yanl mtn: "${s.suffix}" il bitmlidir` : s.format === "includes" ? `Yanl mtn: "${s.includes}" daxil olmaldr` : s.format === "regex" ? `Yanl mtn: ${s.pattern} ablonuna uyun olmaldr` : `Yanl ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${r.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${r.keys.length > 1 ? "lar" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `${r.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${r.origin} daxilind yanl dyr`;
      default:
        return "Yanl dyr";
    }
  };
};
function eq() {
  return {
    localeError: QH()
  };
}
function Uk(e, t, n, i) {
  const r = Math.abs(e), s = r % 10, l = r % 100;
  return l >= 11 && l <= 19 ? i : s === 1 ? t : s >= 2 && s <= 4 ? n : i;
}
const tq = () => {
  const e = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "";
      case "object": {
        if (Array.isArray(r))
          return "";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return ` :  ${r.expected},  ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? ` :  ${Re(r.values[0])}` : ` :    ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        if (l) {
          const c = Number(r.maximum), f = Uk(c, l.unit.one, l.unit.few, l.unit.many);
          return ` : ,  ${r.origin ?? ""}  ${l.verb} ${s}${r.maximum.toString()} ${f}`;
        }
        return ` : ,  ${r.origin ?? ""}   ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        if (l) {
          const c = Number(r.minimum), f = Uk(c, l.unit.one, l.unit.few, l.unit.many);
          return ` : ,  ${r.origin}  ${l.verb} ${s}${r.minimum.toString()} ${f}`;
        }
        return ` : ,  ${r.origin}   ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? ` :    "${s.prefix}"` : s.format === "ends_with" ? ` :    "${s.suffix}"` : s.format === "includes" ? ` :   "${s.includes}"` : s.format === "regex" ? ` :    ${s.pattern}` : ` ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return ` :    ${r.divisor}`;
      case "unrecognized_keys":
        return ` ${r.keys.length > 1 ? "" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `   ${r.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${r.origin}`;
      default:
        return " ";
    }
  };
};
function nq() {
  return {
    localeError: tq()
  };
}
const rq = () => {
  const e = {
    string: { unit: "carcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(r))
          return "array";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "entrada",
    email: "adrea electrnica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adrea IPv4",
    ipv6: "adrea IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Tipus invlid: s'esperava ${r.expected}, s'ha rebut ${n(r.input)}`;
      // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Valor invlid: s'esperava ${Re(r.values[0])}` : `Opci invlida: s'esperava una de ${de(r.values, " o ")}`;
      case "too_big": {
        const s = r.inclusive ? "com a mxim" : "menys de", l = t(r.origin);
        return l ? `Massa gran: s'esperava que ${r.origin ?? "el valor"} contingus ${s} ${r.maximum.toString()} ${l.unit ?? "elements"}` : `Massa gran: s'esperava que ${r.origin ?? "el valor"} fos ${s} ${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? "com a mnim" : "ms de", l = t(r.origin);
        return l ? `Massa petit: s'esperava que ${r.origin} contingus ${s} ${r.minimum.toString()} ${l.unit}` : `Massa petit: s'esperava que ${r.origin} fos ${s} ${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Format invlid: ha de comenar amb "${s.prefix}"` : s.format === "ends_with" ? `Format invlid: ha d'acabar amb "${s.suffix}"` : s.format === "includes" ? `Format invlid: ha d'incloure "${s.includes}"` : s.format === "regex" ? `Format invlid: ha de coincidir amb el patr ${s.pattern}` : `Format invlid per a ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${r.divisor}`;
      case "unrecognized_keys":
        return `Clau${r.keys.length > 1 ? "s" : ""} no reconeguda${r.keys.length > 1 ? "s" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${r.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element invlid a ${r.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function iq() {
  return {
    localeError: rq()
  };
}
const aq = () => {
  const e = {
    string: { unit: "znak", verb: "mt" },
    file: { unit: "bajt", verb: "mt" },
    array: { unit: "prvk", verb: "mt" },
    set: { unit: "prvk", verb: "mt" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "slo";
      case "string":
        return "etzec";
      case "boolean":
        return "boolean";
      case "bigint":
        return "bigint";
      case "function":
        return "funkce";
      case "symbol":
        return "symbol";
      case "undefined":
        return "undefined";
      case "object": {
        if (Array.isArray(r))
          return "pole";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "regulrn vraz",
    email: "e-mailov adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a as ve formtu ISO",
    date: "datum ve formtu ISO",
    time: "as ve formtu ISO",
    duration: "doba trvn ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "etzec zakdovan ve formtu base64",
    base64url: "etzec zakdovan ve formtu base64url",
    json_string: "etzec ve formtu JSON",
    e164: "slo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Neplatn vstup: oekvno ${r.expected}, obdreno ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Neplatn vstup: oekvno ${Re(r.values[0])}` : `Neplatn monost: oekvna jedna z hodnot ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Hodnota je pli velk: ${r.origin ?? "hodnota"} mus mt ${s}${r.maximum.toString()} ${l.unit ?? "prvk"}` : `Hodnota je pli velk: ${r.origin ?? "hodnota"} mus bt ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Hodnota je pli mal: ${r.origin ?? "hodnota"} mus mt ${s}${r.minimum.toString()} ${l.unit ?? "prvk"}` : `Hodnota je pli mal: ${r.origin ?? "hodnota"} mus bt ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Neplatn etzec: mus zanat na "${s.prefix}"` : s.format === "ends_with" ? `Neplatn etzec: mus konit na "${s.suffix}"` : s.format === "includes" ? `Neplatn etzec: mus obsahovat "${s.includes}"` : s.format === "regex" ? `Neplatn etzec: mus odpovdat vzoru ${s.pattern}` : `Neplatn formt ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${r.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${r.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${r.origin}`;
      default:
        return "Neplatn vstup";
    }
  };
};
function sq() {
  return {
    localeError: aq()
  };
}
const oq = () => {
  const e = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  }, t = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "st",
    file: "fil"
  };
  function n(l) {
    return e[l] ?? null;
  }
  function i(l) {
    return t[l] ?? l;
  }
  const r = (l) => {
    const c = typeof l;
    switch (c) {
      case "number":
        return Number.isNaN(l) ? "NaN" : "tal";
      case "object":
        return Array.isArray(l) ? "liste" : l === null ? "null" : Object.getPrototypeOf(l) !== Object.prototype && l.constructor ? l.constructor.name : "objekt";
    }
    return c;
  }, s = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslt",
    date: "ISO-dato",
    time: "ISO-klokkeslt",
    duration: "ISO-varighed",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (l) => {
    switch (l.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${i(l.expected)}, fik ${i(r(l.input))}`;
      case "invalid_value":
        return l.values.length === 1 ? `Ugyldig vrdi: forventede ${Re(l.values[0])}` : `Ugyldigt valg: forventede en af flgende ${de(l.values, "|")}`;
      case "too_big": {
        const c = l.inclusive ? "<=" : "<", f = n(l.origin), h = i(l.origin);
        return f ? `For stor: forventede ${h ?? "value"} ${f.verb} ${c} ${l.maximum.toString()} ${f.unit ?? "elementer"}` : `For stor: forventede ${h ?? "value"} havde ${c} ${l.maximum.toString()}`;
      }
      case "too_small": {
        const c = l.inclusive ? ">=" : ">", f = n(l.origin), h = i(l.origin);
        return f ? `For lille: forventede ${h} ${f.verb} ${c} ${l.minimum.toString()} ${f.unit}` : `For lille: forventede ${h} havde ${c} ${l.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = l;
        return c.format === "starts_with" ? `Ugyldig streng: skal starte med "${c.prefix}"` : c.format === "ends_with" ? `Ugyldig streng: skal ende med "${c.suffix}"` : c.format === "includes" ? `Ugyldig streng: skal indeholde "${c.includes}"` : c.format === "regex" ? `Ugyldig streng: skal matche mnsteret ${c.pattern}` : `Ugyldig ${s[c.format] ?? l.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${l.divisor}`;
      case "unrecognized_keys":
        return `${l.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${de(l.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${l.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${l.origin}`;
      default:
        return "Ugyldigt input";
    }
  };
};
function lq() {
  return {
    localeError: oq()
  };
}
const uq = () => {
  const e = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "Zahl";
      case "object": {
        if (Array.isArray(r))
          return "Array";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Ungltige Eingabe: erwartet ${r.expected}, erhalten ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Ungltige Eingabe: erwartet ${Re(r.values[0])}` : `Ungltige Option: erwartet eine von ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Zu gro: erwartet, dass ${r.origin ?? "Wert"} ${s}${r.maximum.toString()} ${l.unit ?? "Elemente"} hat` : `Zu gro: erwartet, dass ${r.origin ?? "Wert"} ${s}${r.maximum.toString()} ist`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Zu klein: erwartet, dass ${r.origin} ${s}${r.minimum.toString()} ${l.unit} hat` : `Zu klein: erwartet, dass ${r.origin} ${s}${r.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Ungltiger String: muss mit "${s.prefix}" beginnen` : s.format === "ends_with" ? `Ungltiger String: muss mit "${s.suffix}" enden` : s.format === "includes" ? `Ungltiger String: muss "${s.includes}" enthalten` : s.format === "regex" ? `Ungltiger String: muss dem Muster ${s.pattern} entsprechen` : `Ungltig: ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${r.divisor} sein`;
      case "unrecognized_keys":
        return `${r.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${r.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${r.origin}`;
      default:
        return "Ungltige Eingabe";
    }
  };
};
function cq() {
  return {
    localeError: uq()
  };
}
const dq = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "number";
    case "object": {
      if (Array.isArray(e))
        return "array";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, fq = () => {
  const e = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function t(i) {
    return e[i] ?? null;
  }
  const n = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Invalid input: expected ${i.expected}, received ${dq(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Invalid input: expected ${Re(i.values[0])}` : `Invalid option: expected one of ${de(i.values, "|")}`;
      case "too_big": {
        const r = i.inclusive ? "<=" : "<", s = t(i.origin);
        return s ? `Too big: expected ${i.origin ?? "value"} to have ${r}${i.maximum.toString()} ${s.unit ?? "elements"}` : `Too big: expected ${i.origin ?? "value"} to be ${r}${i.maximum.toString()}`;
      }
      case "too_small": {
        const r = i.inclusive ? ">=" : ">", s = t(i.origin);
        return s ? `Too small: expected ${i.origin} to have ${r}${i.minimum.toString()} ${s.unit}` : `Too small: expected ${i.origin} to be ${r}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const r = i;
        return r.format === "starts_with" ? `Invalid string: must start with "${r.prefix}"` : r.format === "ends_with" ? `Invalid string: must end with "${r.suffix}"` : r.format === "includes" ? `Invalid string: must include "${r.includes}"` : r.format === "regex" ? `Invalid string: must match pattern ${r.pattern}` : `Invalid ${n[r.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${i.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${i.keys.length > 1 ? "s" : ""}: ${de(i.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${i.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${i.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function AO() {
  return {
    localeError: fq()
  };
}
const hq = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "nombro";
    case "object": {
      if (Array.isArray(e))
        return "tabelo";
      if (e === null)
        return "senvalora";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, pq = () => {
  const e = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function t(i) {
    return e[i] ?? null;
  }
  const n = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiis ${i.expected}, riceviis ${hq(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Nevalida enigo: atendiis ${Re(i.values[0])}` : `Nevalida opcio: atendiis unu el ${de(i.values, "|")}`;
      case "too_big": {
        const r = i.inclusive ? "<=" : "<", s = t(i.origin);
        return s ? `Tro granda: atendiis ke ${i.origin ?? "valoro"} havu ${r}${i.maximum.toString()} ${s.unit ?? "elementojn"}` : `Tro granda: atendiis ke ${i.origin ?? "valoro"} havu ${r}${i.maximum.toString()}`;
      }
      case "too_small": {
        const r = i.inclusive ? ">=" : ">", s = t(i.origin);
        return s ? `Tro malgranda: atendiis ke ${i.origin} havu ${r}${i.minimum.toString()} ${s.unit}` : `Tro malgranda: atendiis ke ${i.origin} estu ${r}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const r = i;
        return r.format === "starts_with" ? `Nevalida karaktraro: devas komencii per "${r.prefix}"` : r.format === "ends_with" ? `Nevalida karaktraro: devas finii per "${r.suffix}"` : r.format === "includes" ? `Nevalida karaktraro: devas inkluzivi "${r.includes}"` : r.format === "regex" ? `Nevalida karaktraro: devas kongrui kun la modelo ${r.pattern}` : `Nevalida ${n[r.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${i.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${i.keys.length > 1 ? "j" : ""} losilo${i.keys.length > 1 ? "j" : ""}: ${de(i.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${i.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${i.origin}`;
      default:
        return "Nevalida enigo";
    }
  };
};
function mq() {
  return {
    localeError: pq()
  };
}
const gq = () => {
  const e = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "nmero";
      case "object": {
        if (Array.isArray(r))
          return "arreglo";
        if (r === null)
          return "nulo";
        if (Object.getPrototypeOf(r) !== Object.prototype)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "entrada",
    email: "direccin de correo electrnico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duracin ISO",
    ipv4: "direccin IPv4",
    ipv6: "direccin IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Entrada invlida: se esperaba ${r.expected}, recibido ${n(r.input)}`;
      // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Entrada invlida: se esperaba ${Re(r.values[0])}` : `Opcin invlida: se esperaba una de ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Demasiado grande: se esperaba que ${r.origin ?? "valor"} tuviera ${s}${r.maximum.toString()} ${l.unit ?? "elementos"}` : `Demasiado grande: se esperaba que ${r.origin ?? "valor"} fuera ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Demasiado pequeo: se esperaba que ${r.origin} tuviera ${s}${r.minimum.toString()} ${l.unit}` : `Demasiado pequeo: se esperaba que ${r.origin} fuera ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Cadena invlida: debe comenzar con "${s.prefix}"` : s.format === "ends_with" ? `Cadena invlida: debe terminar en "${s.suffix}"` : s.format === "includes" ? `Cadena invlida: debe incluir "${s.includes}"` : s.format === "regex" ? `Cadena invlida: debe coincidir con el patrn ${s.pattern}` : `Invlido ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${r.divisor}`;
      case "unrecognized_keys":
        return `Llave${r.keys.length > 1 ? "s" : ""} desconocida${r.keys.length > 1 ? "s" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${r.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${r.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function vq() {
  return {
    localeError: gq()
  };
}
const yq = () => {
  const e = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "";
      case "object": {
        if (Array.isArray(r))
          return "";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ",
    date: " ",
    time: " ",
    duration: "  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return ` :  ${r.expected}  ${n(r.input)}  `;
      case "invalid_value":
        return r.values.length === 1 ? ` :  ${Re(r.values[0])} ` : ` :    ${de(r.values, "|")} `;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? ` : ${r.origin ?? ""}  ${s}${r.maximum.toString()} ${l.unit ?? ""} ` : ` : ${r.origin ?? ""}  ${s}${r.maximum.toString()} `;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? ` : ${r.origin}  ${s}${r.minimum.toString()} ${l.unit} ` : ` : ${r.origin}  ${s}${r.minimum.toString()} `;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? ` :   "${s.prefix}"  ` : s.format === "ends_with" ? ` :   "${s.suffix}"  ` : s.format === "includes" ? ` :   "${s.includes}" ` : s.format === "regex" ? ` :    ${s.pattern}   ` : `${i[s.format] ?? r.format} `;
      }
      case "not_multiple_of":
        return ` :   ${r.divisor} `;
      case "unrecognized_keys":
        return `${r.keys.length > 1 ? "" : ""} : ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `   ${r.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${r.origin}`;
      default:
        return " ";
    }
  };
};
function bq() {
  return {
    localeError: yq()
  };
}
const xq = () => {
  const e = {
    string: { unit: "merkki", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "pivmrn" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(r))
          return "array";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "snnllinen lauseke",
    email: "shkpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-pivmr",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${r.expected}, oli ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Virheellinen syte: tytyy olla ${Re(r.values[0])}` : `Virheellinen valinta: tytyy olla yksi seuraavista: ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Liian suuri: ${l.subject} tytyy olla ${s}${r.maximum.toString()} ${l.unit}`.trim() : `Liian suuri: arvon tytyy olla ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Liian pieni: ${l.subject} tytyy olla ${s}${r.minimum.toString()} ${l.unit}`.trim() : `Liian pieni: arvon tytyy olla ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Virheellinen syte: tytyy alkaa "${s.prefix}"` : s.format === "ends_with" ? `Virheellinen syte: tytyy loppua "${s.suffix}"` : s.format === "includes" ? `Virheellinen syte: tytyy sislt "${s.includes}"` : s.format === "regex" ? `Virheellinen syte: tytyy vastata snnllist lauseketta ${s.pattern}` : `Virheellinen ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${r.divisor} monikerta`;
      case "unrecognized_keys":
        return `${r.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen syte";
    }
  };
};
function wq() {
  return {
    localeError: xq()
  };
}
const _q = () => {
  const e = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "nombre";
      case "object": {
        if (Array.isArray(r))
          return "tableau";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "entre",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Entre invalide : ${r.expected} attendu, ${n(r.input)} reu`;
      case "invalid_value":
        return r.values.length === 1 ? `Entre invalide : ${Re(r.values[0])} attendu` : `Option invalide : une valeur parmi ${de(r.values, "|")} attendue`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Trop grand : ${r.origin ?? "valeur"} doit ${l.verb} ${s}${r.maximum.toString()} ${l.unit ?? "lment(s)"}` : `Trop grand : ${r.origin ?? "valeur"} doit tre ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Trop petit : ${r.origin} doit ${l.verb} ${s}${r.minimum.toString()} ${l.unit}` : `Trop petit : ${r.origin} doit tre ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Chane invalide : doit commencer par "${s.prefix}"` : s.format === "ends_with" ? `Chane invalide : doit se terminer par "${s.suffix}"` : s.format === "includes" ? `Chane invalide : doit inclure "${s.includes}"` : s.format === "regex" ? `Chane invalide : doit correspondre au modle ${s.pattern}` : `${i[s.format] ?? r.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${r.divisor}`;
      case "unrecognized_keys":
        return `Cl${r.keys.length > 1 ? "s" : ""} non reconnue${r.keys.length > 1 ? "s" : ""} : ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${r.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${r.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function Sq() {
  return {
    localeError: _q()
  };
}
const kq = () => {
  const e = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(r))
          return "array";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "entre",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Entre invalide : attendu ${r.expected}, reu ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Entre invalide : attendu ${Re(r.values[0])}` : `Option invalide : attendu l'une des valeurs suivantes ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "" : "<", l = t(r.origin);
        return l ? `Trop grand : attendu que ${r.origin ?? "la valeur"} ait ${s}${r.maximum.toString()} ${l.unit}` : `Trop grand : attendu que ${r.origin ?? "la valeur"} soit ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? "" : ">", l = t(r.origin);
        return l ? `Trop petit : attendu que ${r.origin} ait ${s}${r.minimum.toString()} ${l.unit}` : `Trop petit : attendu que ${r.origin} soit ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Chane invalide : doit commencer par "${s.prefix}"` : s.format === "ends_with" ? `Chane invalide : doit se terminer par "${s.suffix}"` : s.format === "includes" ? `Chane invalide : doit inclure "${s.includes}"` : s.format === "regex" ? `Chane invalide : doit correspondre au motif ${s.pattern}` : `${i[s.format] ?? r.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${r.divisor}`;
      case "unrecognized_keys":
        return `Cl${r.keys.length > 1 ? "s" : ""} non reconnue${r.keys.length > 1 ? "s" : ""} : ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${r.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${r.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function Tq() {
  return {
    localeError: kq()
  };
}
const Eq = () => {
  const e = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(r))
          return "array";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: " ",
    url: " ",
    emoji: "'",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ISO",
    date: " ISO",
    time: " ISO",
    duration: "  ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: "  64",
    base64url: "  64  ",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `  :  ${r.expected},  ${n(r.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `  :  ${Re(r.values[0])}` : `  :     ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? ` : ${r.origin ?? "value"}   ${s}${r.maximum.toString()} ${l.unit ?? "elements"}` : ` : ${r.origin ?? "value"}   ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? ` : ${r.origin}   ${s}${r.minimum.toString()} ${l.unit}` : ` : ${r.origin}   ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `  :   "${s.prefix}"` : s.format === "ends_with" ? `  :    "${s.suffix}"` : s.format === "includes" ? `  :   "${s.includes}"` : s.format === "regex" ? `  :    ${s.pattern}` : `${i[s.format] ?? r.format}  `;
      }
      case "not_multiple_of":
        return `  :     ${r.divisor}`;
      case "unrecognized_keys":
        return `${r.keys.length > 1 ? "" : ""}  ${r.keys.length > 1 ? "" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `   ${r.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${r.origin}`;
      default:
        return "  ";
    }
  };
};
function $q() {
  return {
    localeError: Eq()
  };
}
const Aq = () => {
  const e = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "szm";
      case "object": {
        if (Array.isArray(r))
          return "tmb";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "bemenet",
    email: "email cm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO idblyeg",
    date: "ISO dtum",
    time: "ISO id",
    duration: "ISO idintervallum",
    ipv4: "IPv4 cm",
    ipv6: "IPv6 cm",
    cidrv4: "IPv4 tartomny",
    cidrv6: "IPv6 tartomny",
    base64: "base64-kdolt string",
    base64url: "base64url-kdolt string",
    json_string: "JSON string",
    e164: "E.164 szm",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `rvnytelen bemenet: a vrt rtk ${r.expected}, a kapott rtk ${n(r.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `rvnytelen bemenet: a vrt rtk ${Re(r.values[0])}` : `rvnytelen opci: valamelyik rtk vrt ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Tl nagy: ${r.origin ?? "rtk"} mrete tl nagy ${s}${r.maximum.toString()} ${l.unit ?? "elem"}` : `Tl nagy: a bemeneti rtk ${r.origin ?? "rtk"} tl nagy: ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Tl kicsi: a bemeneti rtk ${r.origin} mrete tl kicsi ${s}${r.minimum.toString()} ${l.unit}` : `Tl kicsi: a bemeneti rtk ${r.origin} tl kicsi ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `rvnytelen string: "${s.prefix}" rtkkel kell kezddnie` : s.format === "ends_with" ? `rvnytelen string: "${s.suffix}" rtkkel kell vgzdnie` : s.format === "includes" ? `rvnytelen string: "${s.includes}" rtket kell tartalmaznia` : s.format === "regex" ? `rvnytelen string: ${s.pattern} mintnak kell megfelelnie` : `rvnytelen ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${r.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${r.keys.length > 1 ? "s" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${r.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${r.origin}`;
      default:
        return "rvnytelen bemenet";
    }
  };
};
function zq() {
  return {
    localeError: Aq()
  };
}
const Iq = () => {
  const e = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(r))
          return "array";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${r.expected}, diterima ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Input tidak valid: diharapkan ${Re(r.values[0])}` : `Pilihan tidak valid: diharapkan salah satu dari ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Terlalu besar: diharapkan ${r.origin ?? "value"} memiliki ${s}${r.maximum.toString()} ${l.unit ?? "elemen"}` : `Terlalu besar: diharapkan ${r.origin ?? "value"} menjadi ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Terlalu kecil: diharapkan ${r.origin} memiliki ${s}${r.minimum.toString()} ${l.unit}` : `Terlalu kecil: diharapkan ${r.origin} menjadi ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `String tidak valid: harus dimulai dengan "${s.prefix}"` : s.format === "ends_with" ? `String tidak valid: harus berakhir dengan "${s.suffix}"` : s.format === "includes" ? `String tidak valid: harus menyertakan "${s.includes}"` : s.format === "regex" ? `String tidak valid: harus sesuai pola ${s.pattern}` : `${i[s.format] ?? r.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${r.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${r.keys.length > 1 ? "s" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${r.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${r.origin}`;
      default:
        return "Input tidak valid";
    }
  };
};
function Cq() {
  return {
    localeError: Iq()
  };
}
const Oq = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "nmer";
    case "object": {
      if (Array.isArray(e))
        return "fylki";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, Rq = () => {
  const e = {
    string: { unit: "stafi", verb: "a hafa" },
    file: { unit: "bti", verb: "a hafa" },
    array: { unit: "hluti", verb: "a hafa" },
    set: { unit: "hluti", verb: "a hafa" }
  };
  function t(i) {
    return e[i] ?? null;
  }
  const n = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og tmi",
    date: "ISO dagsetning",
    time: "ISO tmi",
    duration: "ISO tmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 tlugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Rangt gildi:  slst inn ${Oq(i.input)} ar sem  a vera ${i.expected}`;
      case "invalid_value":
        return i.values.length === 1 ? `Rangt gildi: gert r fyrir ${Re(i.values[0])}` : `gilt val: m vera eitt af eftirfarandi ${de(i.values, "|")}`;
      case "too_big": {
        const r = i.inclusive ? "<=" : "<", s = t(i.origin);
        return s ? `Of strt: gert er r fyrir a ${i.origin ?? "gildi"} hafi ${r}${i.maximum.toString()} ${s.unit ?? "hluti"}` : `Of strt: gert er r fyrir a ${i.origin ?? "gildi"} s ${r}${i.maximum.toString()}`;
      }
      case "too_small": {
        const r = i.inclusive ? ">=" : ">", s = t(i.origin);
        return s ? `Of lti: gert er r fyrir a ${i.origin} hafi ${r}${i.minimum.toString()} ${s.unit}` : `Of lti: gert er r fyrir a ${i.origin} s ${r}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const r = i;
        return r.format === "starts_with" ? `gildur strengur: verur a byrja  "${r.prefix}"` : r.format === "ends_with" ? `gildur strengur: verur a enda  "${r.suffix}"` : r.format === "includes" ? `gildur strengur: verur a innihalda "${r.includes}"` : r.format === "regex" ? `gildur strengur: verur a fylgja mynstri ${r.pattern}` : `Rangt ${n[r.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${i.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${i.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${de(i.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${i.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${i.origin}`;
      default:
        return "Rangt gildi";
    }
  };
};
function Nq() {
  return {
    localeError: Rq()
  };
}
const Mq = () => {
  const e = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "numero";
      case "object": {
        if (Array.isArray(r))
          return "vettore";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Input non valido: atteso ${r.expected}, ricevuto ${n(r.input)}`;
      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Input non valido: atteso ${Re(r.values[0])}` : `Opzione non valida: atteso uno tra ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Troppo grande: ${r.origin ?? "valore"} deve avere ${s}${r.maximum.toString()} ${l.unit ?? "elementi"}` : `Troppo grande: ${r.origin ?? "valore"} deve essere ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Troppo piccolo: ${r.origin} deve avere ${s}${r.minimum.toString()} ${l.unit}` : `Troppo piccolo: ${r.origin} deve essere ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Stringa non valida: deve iniziare con "${s.prefix}"` : s.format === "ends_with" ? `Stringa non valida: deve terminare con "${s.suffix}"` : s.format === "includes" ? `Stringa non valida: deve includere "${s.includes}"` : s.format === "regex" ? `Stringa non valida: deve corrispondere al pattern ${s.pattern}` : `Invalid ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${r.divisor}`;
      case "unrecognized_keys":
        return `Chiav${r.keys.length > 1 ? "i" : "e"} non riconosciut${r.keys.length > 1 ? "e" : "a"}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${r.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${r.origin}`;
      default:
        return "Input non valido";
    }
  };
};
function Dq() {
  return {
    localeError: Mq()
  };
}
const jq = () => {
  const e = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "";
      case "object": {
        if (Array.isArray(r))
          return "";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `: ${r.expected}${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `: ${Re(r.values[0])}` : `: ${de(r.values, "")}`;
      case "too_big": {
        const s = r.inclusive ? "" : "", l = t(r.origin);
        return l ? `: ${r.origin ?? ""}${r.maximum.toString()}${l.unit ?? ""}${s}` : `: ${r.origin ?? ""}${r.maximum.toString()}${s}`;
      }
      case "too_small": {
        const s = r.inclusive ? "" : "", l = t(r.origin);
        return l ? `: ${r.origin}${r.minimum.toString()}${l.unit}${s}` : `: ${r.origin}${r.minimum.toString()}${s}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `: "${s.prefix}"` : s.format === "ends_with" ? `: "${s.suffix}"` : s.format === "includes" ? `: "${s.includes}"` : s.format === "regex" ? `: ${s.pattern}` : `${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `: ${r.divisor}`;
      case "unrecognized_keys":
        return `${r.keys.length > 1 ? "" : ""}: ${de(r.keys, "")}`;
      case "invalid_key":
        return `${r.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${r.origin}`;
      default:
        return "";
    }
  };
};
function Pq() {
  return {
    localeError: jq()
  };
}
const Uq = () => {
  const e = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? " (NaN)" : "";
      case "object": {
        if (Array.isArray(r))
          return " (Array)";
        if (r === null)
          return " (null)";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: " base64",
    base64url: " base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `  ${r.expected}  ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `  ${Re(r.values[0])}` : `  ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `  ${r.origin ?? ""} ${s} ${r.maximum.toString()} ${l.unit ?? ""}` : `  ${r.origin ?? ""} ${s} ${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `  ${r.origin} ${s} ${r.minimum.toString()} ${l.unit}` : `  ${r.origin} ${s} ${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `  "${s.prefix}"` : s.format === "ends_with" ? `  "${s.suffix}"` : s.format === "includes" ? `  "${s.includes}"` : s.format === "regex" ? `  ${s.pattern}` : ` ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `  ${r.divisor}`;
      case "unrecognized_keys":
        return ` ${de(r.keys, ", ")}`;
      case "invalid_key":
        return ` ${r.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return ` ${r.origin}`;
      default:
        return "";
    }
  };
};
function Lq() {
  return {
    localeError: Uq()
  };
}
const Bq = () => {
  const e = {
    string: { unit: "", verb: "to have" },
    file: { unit: "", verb: "to have" },
    array: { unit: "", verb: "to have" },
    set: { unit: "", verb: "to have" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(r))
          return "array";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64  ",
    base64url: "base64url  ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return ` :   ${r.expected},   ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? ` :  ${Re(r.values[0])}  ` : ` : ${de(r.values, " ")}   `;
      case "too_big": {
        const s = r.inclusive ? "" : "", l = s === "" ? " " : " ", c = t(r.origin), f = c?.unit ?? "";
        return c ? `${r.origin ?? ""}  : ${r.maximum.toString()}${f} ${s}${l}` : `${r.origin ?? ""}  : ${r.maximum.toString()} ${s}${l}`;
      }
      case "too_small": {
        const s = r.inclusive ? "" : "", l = s === "" ? " " : " ", c = t(r.origin), f = c?.unit ?? "";
        return c ? `${r.origin ?? ""}  : ${r.minimum.toString()}${f} ${s}${l}` : `${r.origin ?? ""}  : ${r.minimum.toString()} ${s}${l}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? ` : "${s.prefix}"()  ` : s.format === "ends_with" ? ` : "${s.suffix}"()  ` : s.format === "includes" ? ` : "${s.includes}"()  ` : s.format === "regex" ? ` :  ${s.pattern}   ` : ` ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return ` : ${r.divisor}  `;
      case "unrecognized_keys":
        return `   : ${de(r.keys, ", ")}`;
      case "invalid_key":
        return ` : ${r.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return ` : ${r.origin}`;
      default:
        return " ";
    }
  };
};
function Zq() {
  return {
    localeError: Bq()
  };
}
const Vq = () => {
  const e = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "";
      case "object": {
        if (Array.isArray(r))
          return "";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: "  -",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return ` :   ${r.expected},  ${n(r.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Invalid input: expected ${Re(r.values[0])}` : ` :    ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? ` :   ${r.origin ?? ""}   ${s}${r.maximum.toString()} ${l.unit ?? ""}` : ` :   ${r.origin ?? ""}   ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? ` :   ${r.origin}   ${s}${r.minimum.toString()} ${l.unit}` : ` :   ${r.origin}   ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? ` :     "${s.prefix}"` : s.format === "ends_with" ? ` :     "${s.suffix}"` : s.format === "includes" ? ` :    "${s.includes}"` : s.format === "regex" ? ` :      ${s.pattern}` : `Invalid ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return ` :      ${r.divisor}`;
      case "unrecognized_keys":
        return `${r.keys.length > 1 ? " " : " "}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `   ${r.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${r.origin}`;
      default:
        return " ";
    }
  };
};
function Fq() {
  return {
    localeError: Vq()
  };
}
const Hq = () => {
  const e = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "nombor";
      case "object": {
        if (Array.isArray(r))
          return "array";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${r.expected}, diterima ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Input tidak sah: dijangka ${Re(r.values[0])}` : `Pilihan tidak sah: dijangka salah satu daripada ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Terlalu besar: dijangka ${r.origin ?? "nilai"} ${l.verb} ${s}${r.maximum.toString()} ${l.unit ?? "elemen"}` : `Terlalu besar: dijangka ${r.origin ?? "nilai"} adalah ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Terlalu kecil: dijangka ${r.origin} ${l.verb} ${s}${r.minimum.toString()} ${l.unit}` : `Terlalu kecil: dijangka ${r.origin} adalah ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `String tidak sah: mesti bermula dengan "${s.prefix}"` : s.format === "ends_with" ? `String tidak sah: mesti berakhir dengan "${s.suffix}"` : s.format === "includes" ? `String tidak sah: mesti mengandungi "${s.includes}"` : s.format === "regex" ? `String tidak sah: mesti sepadan dengan corak ${s.pattern}` : `${i[s.format] ?? r.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${r.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${r.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${r.origin}`;
      default:
        return "Input tidak sah";
    }
  };
};
function qq() {
  return {
    localeError: Hq()
  };
}
const Gq = () => {
  const e = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "getal";
      case "object": {
        if (Array.isArray(r))
          return "array";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${r.expected}, ontving ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Ongeldige invoer: verwacht ${Re(r.values[0])}` : `Ongeldige optie: verwacht n van ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Te lang: verwacht dat ${r.origin ?? "waarde"} ${s}${r.maximum.toString()} ${l.unit ?? "elementen"} bevat` : `Te lang: verwacht dat ${r.origin ?? "waarde"} ${s}${r.maximum.toString()} is`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Te kort: verwacht dat ${r.origin} ${s}${r.minimum.toString()} ${l.unit} bevat` : `Te kort: verwacht dat ${r.origin} ${s}${r.minimum.toString()} is`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Ongeldige tekst: moet met "${s.prefix}" beginnen` : s.format === "ends_with" ? `Ongeldige tekst: moet op "${s.suffix}" eindigen` : s.format === "includes" ? `Ongeldige tekst: moet "${s.includes}" bevatten` : s.format === "regex" ? `Ongeldige tekst: moet overeenkomen met patroon ${s.pattern}` : `Ongeldig: ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${r.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${r.keys.length > 1 ? "s" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${r.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${r.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
};
function Yq() {
  return {
    localeError: Gq()
  };
}
const Jq = () => {
  const e = {
    string: { unit: "tegn", verb: " ha" },
    file: { unit: "bytes", verb: " ha" },
    array: { unit: "elementer", verb: " inneholde" },
    set: { unit: "elementer", verb: " inneholde" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "tall";
      case "object": {
        if (Array.isArray(r))
          return "liste";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${r.expected}, fikk ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Ugyldig verdi: forventet ${Re(r.values[0])}` : `Ugyldig valg: forventet en av ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `For stor(t): forventet ${r.origin ?? "value"} til  ha ${s}${r.maximum.toString()} ${l.unit ?? "elementer"}` : `For stor(t): forventet ${r.origin ?? "value"} til  ha ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `For lite(n): forventet ${r.origin} til  ha ${s}${r.minimum.toString()} ${l.unit}` : `For lite(n): forventet ${r.origin} til  ha ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Ugyldig streng: m starte med "${s.prefix}"` : s.format === "ends_with" ? `Ugyldig streng: m ende med "${s.suffix}"` : s.format === "includes" ? `Ugyldig streng: m inneholde "${s.includes}"` : s.format === "regex" ? `Ugyldig streng: m matche mnsteret ${s.pattern}` : `Ugyldig ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${r.divisor}`;
      case "unrecognized_keys":
        return `${r.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${r.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${r.origin}`;
      default:
        return "Ugyldig input";
    }
  };
};
function Xq() {
  return {
    localeError: Jq()
  };
}
const Kq = () => {
  const e = {
    string: { unit: "harf", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "unsur", verb: "olmaldr" },
    set: { unit: "unsur", verb: "olmaldr" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "numara";
      case "object": {
        if (Array.isArray(r))
          return "saf";
        if (r === null)
          return "gayb";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "giren",
    email: "epostagh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengm",
    date: "ISO tarihi",
    time: "ISO zaman",
    duration: "ISO mddeti",
    ipv4: "IPv4 nin",
    ipv6: "IPv6 nin",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-ifreli metin",
    base64url: "base64url-ifreli metin",
    json_string: "JSON metin",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Fsit giren: umulan ${r.expected}, alnan ${n(r.input)}`;
      // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Fsit giren: umulan ${Re(r.values[0])}` : `Fsit tercih: mteberler ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Fazla byk: ${r.origin ?? "value"}, ${s}${r.maximum.toString()} ${l.unit ?? "elements"} sahip olmalyd.` : `Fazla byk: ${r.origin ?? "value"}, ${s}${r.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Fazla kk: ${r.origin}, ${s}${r.minimum.toString()} ${l.unit} sahip olmalyd.` : `Fazla kk: ${r.origin}, ${s}${r.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Fsit metin: "${s.prefix}" ile balamal.` : s.format === "ends_with" ? `Fsit metin: "${s.suffix}" ile bitmeli.` : s.format === "includes" ? `Fsit metin: "${s.includes}" ihtiv etmeli.` : s.format === "regex" ? `Fsit metin: ${s.pattern} nakna uymal.` : `Fsit ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${r.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${r.keys.length > 1 ? "s" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `${r.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${r.origin} iin tannmayan kymet var.`;
      default:
        return "Kymet tannamad.";
    }
  };
};
function Wq() {
  return {
    localeError: Kq()
  };
}
const Qq = () => {
  const e = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "";
      case "object": {
        if (Array.isArray(r))
          return "";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: "",
    url: "  ",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ",
    date: "",
    time: "",
    duration: "",
    ipv4: " IPv4 ",
    ipv6: " IPv6 ",
    cidrv4: " IPv4 ",
    cidrv6: " IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: " E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return ` :  ${r.expected} ,  ${n(r.input)}  `;
      case "invalid_value":
        return r.values.length === 1 ? ` :  ${Re(r.values[0])} ` : ` :    ${de(r.values, "|")}  `;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? ` : ${r.origin ?? ""}  ${s}${r.maximum.toString()} ${l.unit ?? ""} ` : ` : ${r.origin ?? ""}  ${s}${r.maximum.toString()} `;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? ` : ${r.origin}  ${s}${r.minimum.toString()} ${l.unit} ` : ` : ${r.origin}  ${s}${r.minimum.toString()} `;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? ` :   "${s.prefix}"   ` : s.format === "ends_with" ? ` :   "${s.suffix}"    ` : s.format === "includes" ? ` :  "${s.includes}" ` : s.format === "regex" ? ` :   ${s.pattern}   ` : `${i[s.format] ?? r.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${r.divisor}  `;
      case "unrecognized_keys":
        return ` ${r.keys.length > 1 ? "" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `   ${r.origin} `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${r.origin} `;
      default:
        return " ";
    }
  };
};
function e2() {
  return {
    localeError: Qq()
  };
}
const t2 = () => {
  const e = {
    string: { unit: "znakw", verb: "mie" },
    file: { unit: "bajtw", verb: "mie" },
    array: { unit: "elementw", verb: "mie" },
    set: { unit: "elementw", verb: "mie" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "liczba";
      case "object": {
        if (Array.isArray(r))
          return "tablica";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "wyraenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "cig znakw zakodowany w formacie base64",
    base64url: "cig znakw zakodowany w formacie base64url",
    json_string: "cig znakw w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejcie"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Nieprawidowe dane wejciowe: oczekiwano ${r.expected}, otrzymano ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Nieprawidowe dane wejciowe: oczekiwano ${Re(r.values[0])}` : `Nieprawidowa opcja: oczekiwano jednej z wartoci ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Za dua warto: oczekiwano, e ${r.origin ?? "warto"} bdzie mie ${s}${r.maximum.toString()} ${l.unit ?? "elementw"}` : `Zbyt du(y/a/e): oczekiwano, e ${r.origin ?? "warto"} bdzie wynosi ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Za maa warto: oczekiwano, e ${r.origin ?? "warto"} bdzie mie ${s}${r.minimum.toString()} ${l.unit ?? "elementw"}` : `Zbyt ma(y/a/e): oczekiwano, e ${r.origin ?? "warto"} bdzie wynosi ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Nieprawidowy cig znakw: musi zaczyna si od "${s.prefix}"` : s.format === "ends_with" ? `Nieprawidowy cig znakw: musi koczy si na "${s.suffix}"` : s.format === "includes" ? `Nieprawidowy cig znakw: musi zawiera "${s.includes}"` : s.format === "regex" ? `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${s.pattern}` : `Nieprawidow(y/a/e) ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${r.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${r.keys.length > 1 ? "s" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${r.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${r.origin}`;
      default:
        return "Nieprawidowe dane wejciowe";
    }
  };
};
function n2() {
  return {
    localeError: t2()
  };
}
const r2 = () => {
  const e = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "nmero";
      case "object": {
        if (Array.isArray(r))
          return "array";
        if (r === null)
          return "nulo";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "padro",
    email: "endereo de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durao ISO",
    ipv4: "endereo IPv4",
    ipv6: "endereo IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Tipo invlido: esperado ${r.expected}, recebido ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Entrada invlida: esperado ${Re(r.values[0])}` : `Opo invlida: esperada uma das ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Muito grande: esperado que ${r.origin ?? "valor"} tivesse ${s}${r.maximum.toString()} ${l.unit ?? "elementos"}` : `Muito grande: esperado que ${r.origin ?? "valor"} fosse ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Muito pequeno: esperado que ${r.origin} tivesse ${s}${r.minimum.toString()} ${l.unit}` : `Muito pequeno: esperado que ${r.origin} fosse ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Texto invlido: deve comear com "${s.prefix}"` : s.format === "ends_with" ? `Texto invlido: deve terminar com "${s.suffix}"` : s.format === "includes" ? `Texto invlido: deve incluir "${s.includes}"` : s.format === "regex" ? `Texto invlido: deve corresponder ao padro ${s.pattern}` : `${i[s.format] ?? r.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${r.divisor}`;
      case "unrecognized_keys":
        return `Chave${r.keys.length > 1 ? "s" : ""} desconhecida${r.keys.length > 1 ? "s" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${r.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${r.origin}`;
      default:
        return "Campo invlido";
    }
  };
};
function i2() {
  return {
    localeError: r2()
  };
}
function Lk(e, t, n, i) {
  const r = Math.abs(e), s = r % 10, l = r % 100;
  return l >= 11 && l <= 19 ? i : s === 1 ? t : s >= 2 && s <= 4 ? n : i;
}
const a2 = () => {
  const e = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "";
      case "object": {
        if (Array.isArray(r))
          return "";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return ` :  ${r.expected},  ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? ` :  ${Re(r.values[0])}` : ` :    ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        if (l) {
          const c = Number(r.maximum), f = Lk(c, l.unit.one, l.unit.few, l.unit.many);
          return `  : ,  ${r.origin ?? ""}   ${s}${r.maximum.toString()} ${f}`;
        }
        return `  : ,  ${r.origin ?? ""}  ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        if (l) {
          const c = Number(r.minimum), f = Lk(c, l.unit.one, l.unit.few, l.unit.many);
          return `  : ,  ${r.origin}   ${s}${r.minimum.toString()} ${f}`;
        }
        return `  : ,  ${r.origin}  ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? ` :    "${s.prefix}"` : s.format === "ends_with" ? ` :    "${s.suffix}"` : s.format === "includes" ? ` :   "${s.includes}"` : s.format === "regex" ? ` :    ${s.pattern}` : ` ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return ` :    ${r.divisor}`;
      case "unrecognized_keys":
        return `${r.keys.length > 1 ? "" : ""} ${r.keys.length > 1 ? "" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `   ${r.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${r.origin}`;
      default:
        return "  ";
    }
  };
};
function s2() {
  return {
    localeError: a2()
  };
}
const o2 = () => {
  const e = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "tevilo";
      case "object": {
        if (Array.isArray(r))
          return "tabela";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "vnos",
    email: "e-potni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in as",
    date: "ISO datum",
    time: "ISO as",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Neveljaven vnos: priakovano ${r.expected}, prejeto ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Neveljaven vnos: priakovano ${Re(r.values[0])}` : `Neveljavna monost: priakovano eno izmed ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Preveliko: priakovano, da bo ${r.origin ?? "vrednost"} imelo ${s}${r.maximum.toString()} ${l.unit ?? "elementov"}` : `Preveliko: priakovano, da bo ${r.origin ?? "vrednost"} ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Premajhno: priakovano, da bo ${r.origin} imelo ${s}${r.minimum.toString()} ${l.unit}` : `Premajhno: priakovano, da bo ${r.origin} ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Neveljaven niz: mora se zaeti z "${s.prefix}"` : s.format === "ends_with" ? `Neveljaven niz: mora se konati z "${s.suffix}"` : s.format === "includes" ? `Neveljaven niz: mora vsebovati "${s.includes}"` : s.format === "regex" ? `Neveljaven niz: mora ustrezati vzorcu ${s.pattern}` : `Neveljaven ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${r.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${r.keys.length > 1 ? "i kljui" : " klju"}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${r.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${r.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function l2() {
  return {
    localeError: o2()
  };
}
const u2 = () => {
  const e = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehlla" },
    set: { unit: "objekt", verb: "att innehlla" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "antal";
      case "object": {
        if (Array.isArray(r))
          return "lista";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "reguljrt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad strng",
    base64url: "base64url-kodad strng",
    json_string: "JSON-strng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Ogiltig inmatning: frvntat ${r.expected}, fick ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Ogiltig inmatning: frvntat ${Re(r.values[0])}` : `Ogiltigt val: frvntade en av ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Fr stor(t): frvntade ${r.origin ?? "vrdet"} att ha ${s}${r.maximum.toString()} ${l.unit ?? "element"}` : `Fr stor(t): frvntat ${r.origin ?? "vrdet"} att ha ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Fr lite(t): frvntade ${r.origin ?? "vrdet"} att ha ${s}${r.minimum.toString()} ${l.unit}` : `Fr lite(t): frvntade ${r.origin ?? "vrdet"} att ha ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Ogiltig strng: mste brja med "${s.prefix}"` : s.format === "ends_with" ? `Ogiltig strng: mste sluta med "${s.suffix}"` : s.format === "includes" ? `Ogiltig strng: mste innehlla "${s.includes}"` : s.format === "regex" ? `Ogiltig strng: mste matcha mnstret "${s.pattern}"` : `Ogiltig(t) ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${r.divisor}`;
      case "unrecognized_keys":
        return `${r.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${r.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${r.origin ?? "vrdet"}`;
      default:
        return "Ogiltig input";
    }
  };
};
function c2() {
  return {
    localeError: u2()
  };
}
const d2 = () => {
  const e = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? " " : "";
      case "object": {
        if (Array.isArray(r))
          return "";
        if (r === null)
          return "";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO  ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: "input"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return ` :  ${r.expected},  ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? ` :  ${Re(r.values[0])}` : ` :  ${de(r.values, "|")}  `;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? ` :  ${r.origin ?? ""} ${s}${r.maximum.toString()} ${l.unit ?? ""}   ` : ` :  ${r.origin ?? ""} ${s}${r.maximum.toString()}   `;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? ` :  ${r.origin} ${s}${r.minimum.toString()} ${l.unit}   ` : ` :  ${r.origin} ${s}${r.minimum.toString()}   `;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? ` : "${s.prefix}"   ` : s.format === "ends_with" ? ` : "${s.suffix}"   ` : s.format === "includes" ? ` : "${s.includes}"   ` : s.format === "regex" ? ` : ${s.pattern}   ` : ` ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return ` : ${r.divisor}    `;
      case "unrecognized_keys":
        return `  ${r.keys.length > 1 ? "" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `${r.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${r.origin}   `;
      default:
        return " ";
    }
  };
};
function f2() {
  return {
    localeError: d2()
  };
}
const h2 = () => {
  const e = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? " (NaN)" : "";
      case "object": {
        if (Array.isArray(r))
          return " (Array)";
        if (r === null)
          return " (null)";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: " ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IP  IPv4",
    cidrv6: " IP  IPv6",
    base64: " Base64",
    base64url: " Base64  URL",
    json_string: " JSON",
    e164: " (E.164)",
    jwt: " JWT",
    template_literal: ""
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `:  ${r.expected}  ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `:  ${Re(r.values[0])}` : `:  ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "" : "", l = t(r.origin);
        return l ? `: ${r.origin ?? ""} ${s} ${r.maximum.toString()} ${l.unit ?? ""}` : `: ${r.origin ?? ""} ${s} ${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? "" : "", l = t(r.origin);
        return l ? `: ${r.origin} ${s} ${r.minimum.toString()} ${l.unit}` : `: ${r.origin} ${s} ${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `:  "${s.prefix}"` : s.format === "ends_with" ? `:  "${s.suffix}"` : s.format === "includes" ? `:  "${s.includes}" ` : s.format === "regex" ? `:  ${s.pattern}` : `: ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `:  ${r.divisor} `;
      case "unrecognized_keys":
        return `: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return ` ${r.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${r.origin}`;
      default:
        return "";
    }
  };
};
function p2() {
  return {
    localeError: h2()
  };
}
const m2 = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "number";
    case "object": {
      if (Array.isArray(e))
        return "array";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, g2 = () => {
  const e = {
    string: { unit: "karakter", verb: "olmal" },
    file: { unit: "bayt", verb: "olmal" },
    array: { unit: "e", verb: "olmal" },
    set: { unit: "e", verb: "olmal" }
  };
  function t(i) {
    return e[i] ?? null;
  }
  const n = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO sre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral",
    cidrv6: "IPv6 aral",
    base64: "base64 ile ifrelenmi metin",
    base64url: "base64url ile ifrelenmi metin",
    json_string: "JSON dizesi",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "ablon dizesi"
  };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Geersiz deer: beklenen ${i.expected}, alnan ${m2(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Geersiz deer: beklenen ${Re(i.values[0])}` : `Geersiz seenek: aadakilerden biri olmal: ${de(i.values, "|")}`;
      case "too_big": {
        const r = i.inclusive ? "<=" : "<", s = t(i.origin);
        return s ? `ok byk: beklenen ${i.origin ?? "deer"} ${r}${i.maximum.toString()} ${s.unit ?? "e"}` : `ok byk: beklenen ${i.origin ?? "deer"} ${r}${i.maximum.toString()}`;
      }
      case "too_small": {
        const r = i.inclusive ? ">=" : ">", s = t(i.origin);
        return s ? `ok kk: beklenen ${i.origin} ${r}${i.minimum.toString()} ${s.unit}` : `ok kk: beklenen ${i.origin} ${r}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const r = i;
        return r.format === "starts_with" ? `Geersiz metin: "${r.prefix}" ile balamal` : r.format === "ends_with" ? `Geersiz metin: "${r.suffix}" ile bitmeli` : r.format === "includes" ? `Geersiz metin: "${r.includes}" iermeli` : r.format === "regex" ? `Geersiz metin: ${r.pattern} desenine uymal` : `Geersiz ${n[r.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${i.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${i.keys.length > 1 ? "lar" : ""}: ${de(i.keys, ", ")}`;
      case "invalid_key":
        return `${i.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${i.origin} iinde geersiz deer`;
      default:
        return "Geersiz deer";
    }
  };
};
function v2() {
  return {
    localeError: g2()
  };
}
const y2 = () => {
  const e = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "";
      case "object": {
        if (Array.isArray(r))
          return "";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: " ",
    email: "  ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: "   base64",
    base64url: "   base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: " "
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `  :  ${r.expected},  ${n(r.input)}`;
      // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `  :  ${Re(r.values[0])}` : ` :    ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? ` : ,  ${r.origin ?? ""} ${l.verb} ${s}${r.maximum.toString()} ${l.unit ?? ""}` : ` : ,  ${r.origin ?? ""}  ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? ` : ,  ${r.origin} ${l.verb} ${s}${r.minimum.toString()} ${l.unit}` : ` : ,  ${r.origin}  ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? ` :    "${s.prefix}"` : s.format === "ends_with" ? ` :    "${s.suffix}"` : s.format === "includes" ? ` :   "${s.includes}"` : s.format === "regex" ? ` :    ${s.pattern}` : ` ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return ` :    ${r.divisor}`;
      case "unrecognized_keys":
        return ` ${r.keys.length > 1 ? "" : ""}: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `   ${r.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${r.origin}`;
      default:
        return "  ";
    }
  };
};
function b2() {
  return {
    localeError: y2()
  };
}
const x2 = () => {
  const e = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "";
      case "object": {
        if (Array.isArray(r))
          return "";
        if (r === null)
          return "";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: " ",
    email: "  ",
    url: "  ",
    emoji: "",
    uuid: "   ",
    uuidv4: "     4",
    uuidv6: "     6",
    nanoid: "  ",
    guid: "   ",
    cuid: "   ",
    cuid2: "    2",
    ulid: "   ",
    xid: "  ",
    ksuid: "    ",
    datetime: "    ",
    date: "   ",
    time: "   ",
    duration: "   ",
    ipv4: "   4 ",
    ipv6: "   6 ",
    cidrv4: "   4 ",
    cidrv6: "   6 ",
    base64: " 64   ",
    base64url: " 64      ",
    json_string: "    ",
    e164: " 164 ",
    jwt: "  ",
    template_literal: " "
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `  : ${r.expected}   ${n(r.input)}  `;
      case "invalid_value":
        return r.values.length === 1 ? `  : ${Re(r.values[0])}  ` : ` : ${de(r.values, "|")}     `;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? ` : ${r.origin ?? ""}  ${s}${r.maximum.toString()} ${l.unit ?? ""}   ` : ` : ${r.origin ?? ""}  ${s}${r.maximum.toString()}   `;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? ` : ${r.origin}  ${s}${r.minimum.toString()} ${l.unit}   ` : ` : ${r.origin}  ${s}${r.minimum.toString()}   `;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? ` : "${s.prefix}"    ` : s.format === "ends_with" ? ` : "${s.suffix}"    ` : s.format === "includes" ? ` : "${s.includes}"   ` : s.format === "regex" ? ` :  ${s.pattern}    ` : ` ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return ` : ${r.divisor}    `;
      case "unrecognized_keys":
        return `   ${r.keys.length > 1 ? "" : ""}: ${de(r.keys, " ")}`;
      case "invalid_key":
        return `${r.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${r.origin}   `;
      default:
        return "  ";
    }
  };
};
function w2() {
  return {
    localeError: x2()
  };
}
const _2 = () => {
  const e = {
    string: { unit: "k t", verb: "c" },
    file: { unit: "byte", verb: "c" },
    array: { unit: "phn t", verb: "c" },
    set: { unit: "phn t", verb: "c" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "s";
      case "object": {
        if (Array.isArray(r))
          return "mng";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "u vo",
    email: "a ch email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngy gi ISO",
    date: "ngy ISO",
    time: "gi ISO",
    duration: "khong thi gian ISO",
    ipv4: "a ch IPv4",
    ipv6: "a ch IPv6",
    cidrv4: "di IPv4",
    cidrv6: "di IPv6",
    base64: "chui m ha base64",
    base64url: "chui m ha base64url",
    json_string: "chui JSON",
    e164: "s E.164",
    jwt: "JWT",
    template_literal: "u vo"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `u vo khng hp l: mong i ${r.expected}, nhn c ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `u vo khng hp l: mong i ${Re(r.values[0])}` : `Ty chn khng hp l: mong i mt trong cc gi tr ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `Qu ln: mong i ${r.origin ?? "gi tr"} ${l.verb} ${s}${r.maximum.toString()} ${l.unit ?? "phn t"}` : `Qu ln: mong i ${r.origin ?? "gi tr"} ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Qu nh: mong i ${r.origin} ${l.verb} ${s}${r.minimum.toString()} ${l.unit}` : `Qu nh: mong i ${r.origin} ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `Chui khng hp l: phi bt u bng "${s.prefix}"` : s.format === "ends_with" ? `Chui khng hp l: phi kt thc bng "${s.suffix}"` : s.format === "includes" ? `Chui khng hp l: phi bao gm "${s.includes}"` : s.format === "regex" ? `Chui khng hp l: phi khp vi mu ${s.pattern}` : `${i[s.format] ?? r.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${r.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${r.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${r.origin}`;
      default:
        return "u vo khng hp l";
    }
  };
};
function S2() {
  return {
    localeError: _2()
  };
}
const k2 = () => {
  const e = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "(NaN)" : "";
      case "object": {
        if (Array.isArray(r))
          return "";
        if (r === null)
          return "(null)";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return ` ${r.expected} ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? ` ${Re(r.values[0])}` : ` ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? ` ${r.origin ?? ""} ${s}${r.maximum.toString()} ${l.unit ?? ""}` : ` ${r.origin ?? ""} ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? ` ${r.origin} ${s}${r.minimum.toString()} ${l.unit}` : ` ${r.origin} ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? ` "${s.prefix}" ` : s.format === "ends_with" ? ` "${s.suffix}" ` : s.format === "includes" ? ` "${s.includes}"` : s.format === "regex" ? ` ${s.pattern}` : `${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return ` ${r.divisor} `;
      case "unrecognized_keys":
        return `(key): ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `${r.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${r.origin} (value)`;
      default:
        return "";
    }
  };
};
function T2() {
  return {
    localeError: k2()
  };
}
const E2 = () => {
  const e = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(r))
          return "array";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64 ",
    base64url: "base64url ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return ` ${r.expected} ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? ` ${Re(r.values[0])}` : ` ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? ` ${r.origin ?? ""}  ${s}${r.maximum.toString()} ${l.unit ?? ""}` : ` ${r.origin ?? ""}  ${s}${r.maximum.toString()}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? ` ${r.origin}  ${s}${r.minimum.toString()} ${l.unit}` : ` ${r.origin}  ${s}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? ` "${s.prefix}" ` : s.format === "ends_with" ? ` "${s.suffix}" ` : s.format === "includes" ? ` "${s.includes}"` : s.format === "regex" ? ` ${s.pattern}` : ` ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return ` ${r.divisor} `;
      case "unrecognized_keys":
        return `${r.keys.length > 1 ? "" : ""}${de(r.keys, "")}`;
      case "invalid_key":
        return `${r.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${r.origin} `;
      default:
        return "";
    }
  };
};
function $2() {
  return {
    localeError: E2()
  };
}
const A2 = () => {
  const e = {
    string: { unit: "mi", verb: "n" },
    file: { unit: "bytes", verb: "n" },
    array: { unit: "nkan", verb: "n" },
    set: { unit: "nkan", verb: "n" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const n = (r) => {
    const s = typeof r;
    switch (s) {
      case "number":
        return Number.isNaN(r) ? "NaN" : "nmb";
      case "object": {
        if (Array.isArray(r))
          return "akop";
        if (r === null)
          return "null";
        if (Object.getPrototypeOf(r) !== Object.prototype && r.constructor)
          return r.constructor.name;
      }
    }
    return s;
  }, i = {
    regex: "r bwl",
    email: "drs ml",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "kk ISO",
    date: "j ISO",
    time: "kk ISO",
    duration: "kk t p ISO",
    ipv4: "drs IPv4",
    ipv6: "drs IPv6",
    cidrv4: "gbgb IPv4",
    cidrv6: "gbgb IPv6",
    base64: "r t a k n base64",
    base64url: "r base64url",
    json_string: "r JSON",
    e164: "nmb E.164",
    jwt: "JWT",
    template_literal: "r bwl"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `bwl ae: a n lti fi ${r.expected}, m a r ${n(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `bwl ae: a n lti fi ${Re(r.values[0])}` : `yn ae: yan kan lra ${de(r.values, "|")}`;
      case "too_big": {
        const s = r.inclusive ? "<=" : "<", l = t(r.origin);
        return l ? `T p j: a n lti j p ${r.origin ?? "iye"} ${l.verb} ${s}${r.maximum} ${l.unit}` : `T p j: a n lti j ${s}${r.maximum}`;
      }
      case "too_small": {
        const s = r.inclusive ? ">=" : ">", l = t(r.origin);
        return l ? `Kr ju: a n lti j p ${r.origin} ${l.verb} ${s}${r.minimum} ${l.unit}` : `Kr ju: a n lti j ${s}${r.minimum}`;
      }
      case "invalid_format": {
        const s = r;
        return s.format === "starts_with" ? `r ae: gbd br pl "${s.prefix}"` : s.format === "ends_with" ? `r ae: gbd par pl "${s.suffix}"` : s.format === "includes" ? `r ae: gbd n "${s.includes}"` : s.format === "regex" ? `r ae: gbd b pr mu ${s.pattern}` : `Ae: ${i[s.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${r.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${de(r.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${r.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${r.origin}`;
      default:
        return "bwl ae";
    }
  };
};
function z2() {
  return {
    localeError: A2()
  };
}
const zO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ar: WH,
  az: eq,
  be: nq,
  ca: iq,
  cs: sq,
  da: lq,
  de: cq,
  en: AO,
  eo: mq,
  es: vq,
  fa: bq,
  fi: wq,
  fr: Sq,
  frCA: Tq,
  he: $q,
  hu: zq,
  id: Cq,
  is: Nq,
  it: Dq,
  ja: Pq,
  kh: Lq,
  ko: Zq,
  mk: Fq,
  ms: qq,
  nl: Yq,
  no: Xq,
  ota: Wq,
  pl: n2,
  ps: e2,
  pt: i2,
  ru: s2,
  sl: l2,
  sv: c2,
  ta: f2,
  th: p2,
  tr: v2,
  ua: b2,
  ur: w2,
  vi: S2,
  yo: z2,
  zhCN: T2,
  zhTW: $2
}, Symbol.toStringTag, { value: "Module" })), IO = Symbol("ZodOutput"), CO = Symbol("ZodInput");
class Yy {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...n) {
    const i = n[0];
    if (this._map.set(t, i), i && typeof i == "object" && "id" in i) {
      if (this._idmap.has(i.id))
        throw new Error(`ID ${i.id} already exists in the registry`);
      this._idmap.set(i.id, t);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const n = this._map.get(t);
    return n && typeof n == "object" && "id" in n && this._idmap.delete(n.id), this._map.delete(t), this;
  }
  get(t) {
    const n = t._zod.parent;
    if (n) {
      const i = { ...this.get(n) ?? {} };
      delete i.id;
      const r = { ...i, ...this._map.get(t) };
      return Object.keys(r).length ? r : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function Jy() {
  return new Yy();
}
const Ua = /* @__PURE__ */ Jy();
function OO(e, t) {
  return new e({
    type: "string",
    ...ne(t)
  });
}
function RO(e, t) {
  return new e({
    type: "string",
    coerce: !0,
    ...ne(t)
  });
}
function Xy(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function ff(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function Ky(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function Wy(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...ne(t)
  });
}
function Qy(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...ne(t)
  });
}
function eb(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...ne(t)
  });
}
function qf(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function tb(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function nb(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function rb(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function ib(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function ab(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function sb(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function ob(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function lb(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function ub(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function cb(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function db(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function fb(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function hb(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function pb(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
function mb(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...ne(t)
  });
}
const NO = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function MO(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...ne(t)
  });
}
function DO(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...ne(t)
  });
}
function jO(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...ne(t)
  });
}
function PO(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...ne(t)
  });
}
function UO(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...ne(t)
  });
}
function LO(e, t) {
  return new e({
    type: "number",
    coerce: !0,
    checks: [],
    ...ne(t)
  });
}
function BO(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...ne(t)
  });
}
function ZO(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float32",
    ...ne(t)
  });
}
function VO(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float64",
    ...ne(t)
  });
}
function FO(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "int32",
    ...ne(t)
  });
}
function HO(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "uint32",
    ...ne(t)
  });
}
function qO(e, t) {
  return new e({
    type: "boolean",
    ...ne(t)
  });
}
function GO(e, t) {
  return new e({
    type: "boolean",
    coerce: !0,
    ...ne(t)
  });
}
function YO(e, t) {
  return new e({
    type: "bigint",
    ...ne(t)
  });
}
function JO(e, t) {
  return new e({
    type: "bigint",
    coerce: !0,
    ...ne(t)
  });
}
function XO(e, t) {
  return new e({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "int64",
    ...ne(t)
  });
}
function KO(e, t) {
  return new e({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "uint64",
    ...ne(t)
  });
}
function WO(e, t) {
  return new e({
    type: "symbol",
    ...ne(t)
  });
}
function QO(e, t) {
  return new e({
    type: "undefined",
    ...ne(t)
  });
}
function eR(e, t) {
  return new e({
    type: "null",
    ...ne(t)
  });
}
function tR(e) {
  return new e({
    type: "any"
  });
}
function nR(e) {
  return new e({
    type: "unknown"
  });
}
function rR(e, t) {
  return new e({
    type: "never",
    ...ne(t)
  });
}
function iR(e, t) {
  return new e({
    type: "void",
    ...ne(t)
  });
}
function aR(e, t) {
  return new e({
    type: "date",
    ...ne(t)
  });
}
function sR(e, t) {
  return new e({
    type: "date",
    coerce: !0,
    ...ne(t)
  });
}
function oR(e, t) {
  return new e({
    type: "nan",
    ...ne(t)
  });
}
function Ya(e, t) {
  return new Uy({
    check: "less_than",
    ...ne(t),
    value: e,
    inclusive: !1
  });
}
function _r(e, t) {
  return new Uy({
    check: "less_than",
    ...ne(t),
    value: e,
    inclusive: !0
  });
}
function Ja(e, t) {
  return new Ly({
    check: "greater_than",
    ...ne(t),
    value: e,
    inclusive: !1
  });
}
function Zn(e, t) {
  return new Ly({
    check: "greater_than",
    ...ne(t),
    value: e,
    inclusive: !0
  });
}
function lR(e) {
  return Ja(0, e);
}
function uR(e) {
  return Ya(0, e);
}
function cR(e) {
  return _r(0, e);
}
function dR(e) {
  return Zn(0, e);
}
function lu(e, t) {
  return new KI({
    check: "multiple_of",
    ...ne(t),
    value: e
  });
}
function Gf(e, t) {
  return new eC({
    check: "max_size",
    ...ne(t),
    maximum: e
  });
}
function uu(e, t) {
  return new tC({
    check: "min_size",
    ...ne(t),
    minimum: e
  });
}
function gb(e, t) {
  return new nC({
    check: "size_equals",
    ...ne(t),
    size: e
  });
}
function Yf(e, t) {
  return new rC({
    check: "max_length",
    ...ne(t),
    maximum: e
  });
}
function ho(e, t) {
  return new iC({
    check: "min_length",
    ...ne(t),
    minimum: e
  });
}
function Jf(e, t) {
  return new aC({
    check: "length_equals",
    ...ne(t),
    length: e
  });
}
function vb(e, t) {
  return new sC({
    check: "string_format",
    format: "regex",
    ...ne(t),
    pattern: e
  });
}
function yb(e) {
  return new oC({
    check: "string_format",
    format: "lowercase",
    ...ne(e)
  });
}
function bb(e) {
  return new lC({
    check: "string_format",
    format: "uppercase",
    ...ne(e)
  });
}
function xb(e, t) {
  return new uC({
    check: "string_format",
    format: "includes",
    ...ne(t),
    includes: e
  });
}
function wb(e, t) {
  return new cC({
    check: "string_format",
    format: "starts_with",
    ...ne(t),
    prefix: e
  });
}
function _b(e, t) {
  return new dC({
    check: "string_format",
    format: "ends_with",
    ...ne(t),
    suffix: e
  });
}
function fR(e, t, n) {
  return new fC({
    check: "property",
    property: e,
    schema: t,
    ...ne(n)
  });
}
function Sb(e, t) {
  return new hC({
    check: "mime_type",
    mime: e,
    ...ne(t)
  });
}
function ts(e) {
  return new pC({
    check: "overwrite",
    tx: e
  });
}
function kb(e) {
  return ts((t) => t.normalize(e));
}
function Tb() {
  return ts((e) => e.trim());
}
function Eb() {
  return ts((e) => e.toLowerCase());
}
function $b() {
  return ts((e) => e.toUpperCase());
}
function hR(e, t, n) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...ne(n)
  });
}
function I2(e, t, n) {
  return new e({
    type: "union",
    options: t,
    ...ne(n)
  });
}
function C2(e, t, n, i) {
  return new e({
    type: "union",
    options: n,
    discriminator: t,
    ...ne(i)
  });
}
function O2(e, t, n) {
  return new e({
    type: "intersection",
    left: t,
    right: n
  });
}
function R2(e, t, n, i) {
  const r = n instanceof Ne, s = r ? i : n, l = r ? n : null;
  return new e({
    type: "tuple",
    items: t,
    rest: l,
    ...ne(s)
  });
}
function N2(e, t, n, i) {
  return new e({
    type: "record",
    keyType: t,
    valueType: n,
    ...ne(i)
  });
}
function M2(e, t, n, i) {
  return new e({
    type: "map",
    keyType: t,
    valueType: n,
    ...ne(i)
  });
}
function D2(e, t, n) {
  return new e({
    type: "set",
    valueType: t,
    ...ne(n)
  });
}
function j2(e, t, n) {
  const i = Array.isArray(t) ? Object.fromEntries(t.map((r) => [r, r])) : t;
  return new e({
    type: "enum",
    entries: i,
    ...ne(n)
  });
}
function P2(e, t, n) {
  return new e({
    type: "enum",
    entries: t,
    ...ne(n)
  });
}
function U2(e, t, n) {
  return new e({
    type: "literal",
    values: Array.isArray(t) ? t : [t],
    ...ne(n)
  });
}
function pR(e, t) {
  return new e({
    type: "file",
    ...ne(t)
  });
}
function L2(e, t) {
  return new e({
    type: "transform",
    transform: t
  });
}
function B2(e, t) {
  return new e({
    type: "optional",
    innerType: t
  });
}
function Z2(e, t) {
  return new e({
    type: "nullable",
    innerType: t
  });
}
function V2(e, t, n) {
  return new e({
    type: "default",
    innerType: t,
    get defaultValue() {
      return typeof n == "function" ? n() : Vf(n);
    }
  });
}
function F2(e, t, n) {
  return new e({
    type: "nonoptional",
    innerType: t,
    ...ne(n)
  });
}
function H2(e, t) {
  return new e({
    type: "success",
    innerType: t
  });
}
function q2(e, t, n) {
  return new e({
    type: "catch",
    innerType: t,
    catchValue: typeof n == "function" ? n : () => n
  });
}
function G2(e, t, n) {
  return new e({
    type: "pipe",
    in: t,
    out: n
  });
}
function Y2(e, t) {
  return new e({
    type: "readonly",
    innerType: t
  });
}
function J2(e, t, n) {
  return new e({
    type: "template_literal",
    parts: t,
    ...ne(n)
  });
}
function X2(e, t) {
  return new e({
    type: "lazy",
    getter: t
  });
}
function K2(e, t) {
  return new e({
    type: "promise",
    innerType: t
  });
}
function mR(e, t, n) {
  const i = ne(n);
  return i.abort ?? (i.abort = !0), new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...i
  });
}
function gR(e, t, n) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...ne(n)
  });
}
function vR(e) {
  const t = yR((n) => (n.addIssue = (i) => {
    if (typeof i == "string")
      n.issues.push(co(i, n.value, t._zod.def));
    else {
      const r = i;
      r.fatal && (r.continue = !1), r.code ?? (r.code = "custom"), r.input ?? (r.input = n.value), r.inst ?? (r.inst = t), r.continue ?? (r.continue = !t._zod.def.abort), n.issues.push(co(r));
    }
  }, e(n.value, n)));
  return t;
}
function yR(e, t) {
  const n = new At({
    check: "custom",
    ...ne(t)
  });
  return n._zod.check = e, n;
}
function bR(e, t) {
  const n = ne(t);
  let i = n.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], r = n.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  n.case !== "sensitive" && (i = i.map((b) => typeof b == "string" ? b.toLowerCase() : b), r = r.map((b) => typeof b == "string" ? b.toLowerCase() : b));
  const s = new Set(i), l = new Set(r), c = e.Codec ?? Gy, f = e.Boolean ?? Vy, h = e.String ?? Pu, p = new h({ type: "string", error: n.error }), m = new f({ type: "boolean", error: n.error }), y = new c({
    type: "pipe",
    in: p,
    out: m,
    transform: ((b, x) => {
      let w = b;
      return n.case !== "sensitive" && (w = w.toLowerCase()), s.has(w) ? !0 : l.has(w) ? !1 : (x.issues.push({
        code: "invalid_value",
        expected: "stringbool",
        values: [...s, ...l],
        input: x.value,
        inst: y,
        continue: !1
      }), {});
    }),
    reverseTransform: ((b, x) => b === !0 ? i[0] || "true" : r[0] || "false"),
    error: n.error
  });
  return y;
}
function Uu(e, t, n, i = {}) {
  const r = ne(i), s = {
    ...ne(i),
    check: "string_format",
    type: "string",
    format: t,
    fn: typeof n == "function" ? n : (c) => n.test(c),
    ...r
  };
  return n instanceof RegExp && (s.pattern = n), new e(s);
}
class Qg {
  constructor(t) {
    this.counter = 0, this.metadataRegistry = t?.metadata ?? Ua, this.target = t?.target ?? "draft-2020-12", this.unrepresentable = t?.unrepresentable ?? "throw", this.override = t?.override ?? (() => {
    }), this.io = t?.io ?? "output", this.seen = /* @__PURE__ */ new Map();
  }
  process(t, n = { path: [], schemaPath: [] }) {
    var i;
    const r = t._zod.def, s = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    }, l = this.seen.get(t);
    if (l)
      return l.count++, n.schemaPath.includes(t) && (l.cycle = n.path), l.schema;
    const c = { schema: {}, count: 1, cycle: void 0, path: n.path };
    this.seen.set(t, c);
    const f = t._zod.toJSONSchema?.();
    if (f)
      c.schema = f;
    else {
      const m = {
        ...n,
        schemaPath: [...n.schemaPath, t],
        path: n.path
      }, y = t._zod.parent;
      if (y)
        c.ref = y, this.process(y, m), this.seen.get(y).isParent = !0;
      else {
        const b = c.schema;
        switch (r.type) {
          case "string": {
            const x = b;
            x.type = "string";
            const { minimum: w, maximum: k, format: T, patterns: A, contentEncoding: z } = t._zod.bag;
            if (typeof w == "number" && (x.minLength = w), typeof k == "number" && (x.maxLength = k), T && (x.format = s[T] ?? T, x.format === "" && delete x.format), z && (x.contentEncoding = z), A && A.size > 0) {
              const O = [...A];
              O.length === 1 ? x.pattern = O[0].source : O.length > 1 && (c.schema.allOf = [
                ...O.map((M) => ({
                  ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                  pattern: M.source
                }))
              ]);
            }
            break;
          }
          case "number": {
            const x = b, { minimum: w, maximum: k, format: T, multipleOf: A, exclusiveMaximum: z, exclusiveMinimum: O } = t._zod.bag;
            typeof T == "string" && T.includes("int") ? x.type = "integer" : x.type = "number", typeof O == "number" && (this.target === "draft-4" ? (x.minimum = O, x.exclusiveMinimum = !0) : x.exclusiveMinimum = O), typeof w == "number" && (x.minimum = w, typeof O == "number" && this.target !== "draft-4" && (O >= w ? delete x.minimum : delete x.exclusiveMinimum)), typeof z == "number" && (this.target === "draft-4" ? (x.maximum = z, x.exclusiveMaximum = !0) : x.exclusiveMaximum = z), typeof k == "number" && (x.maximum = k, typeof z == "number" && this.target !== "draft-4" && (z <= k ? delete x.maximum : delete x.exclusiveMaximum)), typeof A == "number" && (x.multipleOf = A);
            break;
          }
          case "boolean": {
            const x = b;
            x.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw")
              throw new Error("BigInt cannot be represented in JSON Schema");
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw")
              throw new Error("Symbols cannot be represented in JSON Schema");
            break;
          }
          case "null": {
            b.type = "null";
            break;
          }
          case "any":
            break;
          case "unknown":
            break;
          case "undefined": {
            if (this.unrepresentable === "throw")
              throw new Error("Undefined cannot be represented in JSON Schema");
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw")
              throw new Error("Void cannot be represented in JSON Schema");
            break;
          }
          case "never": {
            b.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw")
              throw new Error("Date cannot be represented in JSON Schema");
            break;
          }
          case "array": {
            const x = b, { minimum: w, maximum: k } = t._zod.bag;
            typeof w == "number" && (x.minItems = w), typeof k == "number" && (x.maxItems = k), x.type = "array", x.items = this.process(r.element, { ...m, path: [...m.path, "items"] });
            break;
          }
          case "object": {
            const x = b;
            x.type = "object", x.properties = {};
            const w = r.shape;
            for (const A in w)
              x.properties[A] = this.process(w[A], {
                ...m,
                path: [...m.path, "properties", A]
              });
            const k = new Set(Object.keys(w)), T = new Set([...k].filter((A) => {
              const z = r.shape[A]._zod;
              return this.io === "input" ? z.optin === void 0 : z.optout === void 0;
            }));
            T.size > 0 && (x.required = Array.from(T)), r.catchall?._zod.def.type === "never" ? x.additionalProperties = !1 : r.catchall ? r.catchall && (x.additionalProperties = this.process(r.catchall, {
              ...m,
              path: [...m.path, "additionalProperties"]
            })) : this.io === "output" && (x.additionalProperties = !1);
            break;
          }
          case "union": {
            const x = b, w = r.options.map((k, T) => this.process(k, {
              ...m,
              path: [...m.path, "anyOf", T]
            }));
            if (this.target === "openapi-3.0") {
              const k = w.filter((A) => A.type !== "null"), T = k.length !== w.length;
              k.length === 1 ? Object.assign(x, k[0]) : x.anyOf = k, T && (x.nullable = !0);
            } else
              x.anyOf = w;
            break;
          }
          case "intersection": {
            const x = b, w = this.process(r.left, {
              ...m,
              path: [...m.path, "allOf", 0]
            }), k = this.process(r.right, {
              ...m,
              path: [...m.path, "allOf", 1]
            }), T = (z) => "allOf" in z && Object.keys(z).length === 1, A = [
              ...T(w) ? w.allOf : [w],
              ...T(k) ? k.allOf : [k]
            ];
            x.allOf = A;
            break;
          }
          case "tuple": {
            const x = b;
            x.type = "array";
            const w = r.items.map((A, z) => this.process(A, { ...m, path: [...m.path, "prefixItems", z] }));
            if (this.target === "draft-2020-12" ? x.prefixItems = w : x.items = w, r.rest) {
              const A = this.process(r.rest, {
                ...m,
                path: [...m.path, "items"]
              });
              this.target === "draft-2020-12" ? x.items = A : x.additionalItems = A;
            }
            r.rest && (x.items = this.process(r.rest, {
              ...m,
              path: [...m.path, "items"]
            }));
            const { minimum: k, maximum: T } = t._zod.bag;
            typeof k == "number" && (x.minItems = k), typeof T == "number" && (x.maxItems = T);
            break;
          }
          case "record": {
            const x = b;
            x.type = "object", this.target !== "draft-4" && (x.propertyNames = this.process(r.keyType, {
              ...m,
              path: [...m.path, "propertyNames"]
            })), x.additionalProperties = this.process(r.valueType, {
              ...m,
              path: [...m.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw")
              throw new Error("Map cannot be represented in JSON Schema");
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw")
              throw new Error("Set cannot be represented in JSON Schema");
            break;
          }
          case "enum": {
            const x = b, w = Sy(r.entries);
            w.every((k) => typeof k == "number") && (x.type = "number"), w.every((k) => typeof k == "string") && (x.type = "string"), x.enum = w;
            break;
          }
          case "literal": {
            const x = b, w = [];
            for (const k of r.values)
              if (k === void 0) {
                if (this.unrepresentable === "throw")
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
              } else if (typeof k == "bigint") {
                if (this.unrepresentable === "throw")
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                w.push(Number(k));
              } else
                w.push(k);
            if (w.length !== 0) if (w.length === 1) {
              const k = w[0];
              x.type = k === null ? "null" : typeof k, this.target === "draft-4" || this.target === "openapi-3.0" ? x.enum = [k] : x.const = k;
            } else
              w.every((k) => typeof k == "number") && (x.type = "number"), w.every((k) => typeof k == "string") && (x.type = "string"), w.every((k) => typeof k == "boolean") && (x.type = "string"), w.every((k) => k === null) && (x.type = "null"), x.enum = w;
            break;
          }
          case "file": {
            const x = b, w = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            }, { minimum: k, maximum: T, mime: A } = t._zod.bag;
            k !== void 0 && (w.minLength = k), T !== void 0 && (w.maxLength = T), A ? A.length === 1 ? (w.contentMediaType = A[0], Object.assign(x, w)) : x.anyOf = A.map((z) => ({ ...w, contentMediaType: z })) : Object.assign(x, w);
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw")
              throw new Error("Transforms cannot be represented in JSON Schema");
            break;
          }
          case "nullable": {
            const x = this.process(r.innerType, m);
            this.target === "openapi-3.0" ? (Object.assign(b, x), b.nullable = !0, c.ref = r.innerType) : b.anyOf = [x, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(r.innerType, m), c.ref = r.innerType;
            break;
          }
          case "success": {
            const x = b;
            x.type = "boolean";
            break;
          }
          case "default": {
            this.process(r.innerType, m), c.ref = r.innerType, b.default = JSON.parse(JSON.stringify(r.defaultValue));
            break;
          }
          case "prefault": {
            this.process(r.innerType, m), c.ref = r.innerType, this.io === "input" && (b._prefault = JSON.parse(JSON.stringify(r.defaultValue)));
            break;
          }
          case "catch": {
            this.process(r.innerType, m), c.ref = r.innerType;
            let x;
            try {
              x = r.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            b.default = x;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw")
              throw new Error("NaN cannot be represented in JSON Schema");
            break;
          }
          case "template_literal": {
            const x = b, w = t._zod.pattern;
            if (!w)
              throw new Error("Pattern not found in template literal");
            x.type = "string", x.pattern = w.source;
            break;
          }
          case "pipe": {
            const x = this.io === "input" ? r.in._zod.def.type === "transform" ? r.out : r.in : r.out;
            this.process(x, m), c.ref = x;
            break;
          }
          case "readonly": {
            this.process(r.innerType, m), c.ref = r.innerType, b.readOnly = !0;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(r.innerType, m), c.ref = r.innerType;
            break;
          }
          case "optional": {
            this.process(r.innerType, m), c.ref = r.innerType;
            break;
          }
          case "lazy": {
            const x = t._zod.innerType;
            this.process(x, m), c.ref = x;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw")
              throw new Error("Custom types cannot be represented in JSON Schema");
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw")
              throw new Error("Function types cannot be represented in JSON Schema");
            break;
          }
        }
      }
    }
    const h = this.metadataRegistry.get(t);
    return h && Object.assign(c.schema, h), this.io === "input" && Zt(t) && (delete c.schema.examples, delete c.schema.default), this.io === "input" && c.schema._prefault && ((i = c.schema).default ?? (i.default = c.schema._prefault)), delete c.schema._prefault, this.seen.get(t).schema;
  }
  emit(t, n) {
    const i = {
      cycles: n?.cycles ?? "ref",
      reused: n?.reused ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: n?.external ?? void 0
    }, r = this.seen.get(t);
    if (!r)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const s = (p) => {
      const m = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (i.external) {
        const w = i.external.registry.get(p[0])?.id, k = i.external.uri ?? ((A) => A);
        if (w)
          return { ref: k(w) };
        const T = p[1].defId ?? p[1].schema.id ?? `schema${this.counter++}`;
        return p[1].defId = T, { defId: T, ref: `${k("__shared")}#/${m}/${T}` };
      }
      if (p[1] === r)
        return { ref: "#" };
      const b = `#/${m}/`, x = p[1].schema.id ?? `__schema${this.counter++}`;
      return { defId: x, ref: b + x };
    }, l = (p) => {
      if (p[1].schema.$ref)
        return;
      const m = p[1], { ref: y, defId: b } = s(p);
      m.def = { ...m.schema }, b && (m.defId = b);
      const x = m.schema;
      for (const w in x)
        delete x[w];
      x.$ref = y;
    };
    if (i.cycles === "throw")
      for (const p of this.seen.entries()) {
        const m = p[1];
        if (m.cycle)
          throw new Error(`Cycle detected: #/${m.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    for (const p of this.seen.entries()) {
      const m = p[1];
      if (t === p[0]) {
        l(p);
        continue;
      }
      if (i.external) {
        const b = i.external.registry.get(p[0])?.id;
        if (t !== p[0] && b) {
          l(p);
          continue;
        }
      }
      if (this.metadataRegistry.get(p[0])?.id) {
        l(p);
        continue;
      }
      if (m.cycle) {
        l(p);
        continue;
      }
      if (m.count > 1 && i.reused === "ref") {
        l(p);
        continue;
      }
    }
    const c = (p, m) => {
      const y = this.seen.get(p), b = y.def ?? y.schema, x = { ...b };
      if (y.ref === null)
        return;
      const w = y.ref;
      if (y.ref = null, w) {
        c(w, m);
        const k = this.seen.get(w).schema;
        k.$ref && (m.target === "draft-7" || m.target === "draft-4" || m.target === "openapi-3.0") ? (b.allOf = b.allOf ?? [], b.allOf.push(k)) : (Object.assign(b, k), Object.assign(b, x));
      }
      y.isParent || this.override({
        zodSchema: p,
        jsonSchema: b,
        path: y.path ?? []
      });
    };
    for (const p of [...this.seen.entries()].reverse())
      c(p[0], { target: this.target });
    const f = {};
    if (this.target === "draft-2020-12" ? f.$schema = "https://json-schema.org/draft/2020-12/schema" : this.target === "draft-7" ? f.$schema = "http://json-schema.org/draft-07/schema#" : this.target === "draft-4" ? f.$schema = "http://json-schema.org/draft-04/schema#" : this.target === "openapi-3.0" || console.warn(`Invalid target: ${this.target}`), i.external?.uri) {
      const p = i.external.registry.get(t)?.id;
      if (!p)
        throw new Error("Schema is missing an `id` property");
      f.$id = i.external.uri(p);
    }
    Object.assign(f, r.def);
    const h = i.external?.defs ?? {};
    for (const p of this.seen.entries()) {
      const m = p[1];
      m.def && m.defId && (h[m.defId] = m.def);
    }
    i.external || Object.keys(h).length > 0 && (this.target === "draft-2020-12" ? f.$defs = h : f.definitions = h);
    try {
      return JSON.parse(JSON.stringify(f));
    } catch {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function xR(e, t) {
  if (e instanceof Yy) {
    const i = new Qg(t), r = {};
    for (const c of e._idmap.entries()) {
      const [f, h] = c;
      i.process(h);
    }
    const s = {}, l = {
      registry: e,
      uri: t?.uri,
      defs: r
    };
    for (const c of e._idmap.entries()) {
      const [f, h] = c;
      s[f] = i.emit(h, {
        ...t,
        external: l
      });
    }
    if (Object.keys(r).length > 0) {
      const c = i.target === "draft-2020-12" ? "$defs" : "definitions";
      s.__shared = {
        [c]: r
      };
    }
    return { schemas: s };
  }
  const n = new Qg(t);
  return n.process(e), n.emit(e, t);
}
function Zt(e, t) {
  const n = t ?? { seen: /* @__PURE__ */ new Set() };
  if (n.seen.has(e))
    return !1;
  n.seen.add(e);
  const r = e._zod.def;
  switch (r.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return !1;
    case "array":
      return Zt(r.element, n);
    case "object": {
      for (const s in r.shape)
        if (Zt(r.shape[s], n))
          return !0;
      return !1;
    }
    case "union": {
      for (const s of r.options)
        if (Zt(s, n))
          return !0;
      return !1;
    }
    case "intersection":
      return Zt(r.left, n) || Zt(r.right, n);
    case "tuple": {
      for (const s of r.items)
        if (Zt(s, n))
          return !0;
      return !!(r.rest && Zt(r.rest, n));
    }
    case "record":
      return Zt(r.keyType, n) || Zt(r.valueType, n);
    case "map":
      return Zt(r.keyType, n) || Zt(r.valueType, n);
    case "set":
      return Zt(r.valueType, n);
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return Zt(r.innerType, n);
    case "lazy":
      return Zt(r.getter(), n);
    case "default":
      return Zt(r.innerType, n);
    case "prefault":
      return Zt(r.innerType, n);
    case "custom":
      return !1;
    case "transform":
      return !0;
    case "pipe":
      return Zt(r.in, n) || Zt(r.out, n);
    case "success":
      return !1;
    case "catch":
      return !1;
    case "function":
      return !1;
  }
  throw new Error(`Unknown schema type: ${r.type}`);
}
const W2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Q2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $ZodAny: YC,
  $ZodArray: QC,
  $ZodAsyncError: Va,
  $ZodBase64: DC,
  $ZodBase64URL: PC,
  $ZodBigInt: Fy,
  $ZodBigIntFormat: FC,
  $ZodBoolean: Vy,
  $ZodCIDRv4: NC,
  $ZodCIDRv6: MC,
  $ZodCUID: SC,
  $ZodCUID2: kC,
  $ZodCatch: bO,
  $ZodCheck: At,
  $ZodCheckBigIntFormat: QI,
  $ZodCheckEndsWith: dC,
  $ZodCheckGreaterThan: Ly,
  $ZodCheckIncludes: uC,
  $ZodCheckLengthEquals: aC,
  $ZodCheckLessThan: Uy,
  $ZodCheckLowerCase: oC,
  $ZodCheckMaxLength: rC,
  $ZodCheckMaxSize: eC,
  $ZodCheckMimeType: hC,
  $ZodCheckMinLength: iC,
  $ZodCheckMinSize: tC,
  $ZodCheckMultipleOf: KI,
  $ZodCheckNumberFormat: WI,
  $ZodCheckOverwrite: pC,
  $ZodCheckProperty: fC,
  $ZodCheckRegex: sC,
  $ZodCheckSizeEquals: nC,
  $ZodCheckStartsWith: cC,
  $ZodCheckStringFormat: ju,
  $ZodCheckUpperCase: lC,
  $ZodCodec: Gy,
  $ZodCustom: $O,
  $ZodCustomStringFormat: ZC,
  $ZodDate: WC,
  $ZodDefault: mO,
  $ZodDiscriminatedUnion: iO,
  $ZodE164: UC,
  $ZodEmail: bC,
  $ZodEmoji: wC,
  $ZodEncodeError: Lf,
  $ZodEnum: uO,
  $ZodError: Ty,
  $ZodFile: dO,
  $ZodFunction: kO,
  $ZodGUID: vC,
  $ZodIPv4: OC,
  $ZodIPv6: RC,
  $ZodISODate: zC,
  $ZodISODateTime: AC,
  $ZodISODuration: CC,
  $ZodISOTime: IC,
  $ZodIntersection: aO,
  $ZodJWT: BC,
  $ZodKSUID: $C,
  $ZodLazy: EO,
  $ZodLiteral: cO,
  $ZodMap: oO,
  $ZodNaN: xO,
  $ZodNanoID: _C,
  $ZodNever: XC,
  $ZodNonOptional: vO,
  $ZodNull: GC,
  $ZodNullable: pO,
  $ZodNumber: Zy,
  $ZodNumberFormat: VC,
  $ZodObject: nO,
  $ZodObjectJIT: rO,
  $ZodOptional: hO,
  $ZodPipe: wO,
  $ZodPrefault: gO,
  $ZodPromise: TO,
  $ZodReadonly: _O,
  $ZodRealError: Gn,
  $ZodRecord: sO,
  $ZodRegistry: Yy,
  $ZodSet: lO,
  $ZodString: Pu,
  $ZodStringFormat: dt,
  $ZodSuccess: yO,
  $ZodSymbol: HC,
  $ZodTemplateLiteral: SO,
  $ZodTransform: fO,
  $ZodTuple: qy,
  $ZodType: Ne,
  $ZodULID: TC,
  $ZodURL: xC,
  $ZodUUID: yC,
  $ZodUndefined: qC,
  $ZodUnion: Hy,
  $ZodUnknown: JC,
  $ZodVoid: KC,
  $ZodXID: EC,
  $brand: Xz,
  $constructor: B,
  $input: CO,
  $output: IO,
  Doc: mC,
  JSONSchema: W2,
  JSONSchemaGenerator: Qg,
  NEVER: Jz,
  TimePrecision: NO,
  _any: tR,
  _array: hR,
  _base64: fb,
  _base64url: hb,
  _bigint: YO,
  _boolean: qO,
  _catch: q2,
  _check: yR,
  _cidrv4: cb,
  _cidrv6: db,
  _coercedBigint: JO,
  _coercedBoolean: GO,
  _coercedDate: sR,
  _coercedNumber: LO,
  _coercedString: RO,
  _cuid: rb,
  _cuid2: ib,
  _custom: mR,
  _date: aR,
  _decode: zy,
  _decodeAsync: Cy,
  _default: V2,
  _discriminatedUnion: C2,
  _e164: pb,
  _email: Xy,
  _emoji: tb,
  _encode: Ay,
  _encodeAsync: Iy,
  _endsWith: _b,
  _enum: j2,
  _file: pR,
  _float32: ZO,
  _float64: VO,
  _gt: Ja,
  _gte: Zn,
  _guid: ff,
  _includes: xb,
  _int: BO,
  _int32: FO,
  _int64: XO,
  _intersection: O2,
  _ipv4: lb,
  _ipv6: ub,
  _isoDate: DO,
  _isoDateTime: MO,
  _isoDuration: PO,
  _isoTime: jO,
  _jwt: mb,
  _ksuid: ob,
  _lazy: X2,
  _length: Jf,
  _literal: U2,
  _lowercase: yb,
  _lt: Ya,
  _lte: _r,
  _map: M2,
  _max: _r,
  _maxLength: Yf,
  _maxSize: Gf,
  _mime: Sb,
  _min: Zn,
  _minLength: ho,
  _minSize: uu,
  _multipleOf: lu,
  _nan: oR,
  _nanoid: nb,
  _nativeEnum: P2,
  _negative: uR,
  _never: rR,
  _nonnegative: dR,
  _nonoptional: F2,
  _nonpositive: cR,
  _normalize: kb,
  _null: eR,
  _nullable: Z2,
  _number: UO,
  _optional: B2,
  _overwrite: ts,
  _parse: Cu,
  _parseAsync: Ou,
  _pipe: G2,
  _positive: lR,
  _promise: K2,
  _property: fR,
  _readonly: Y2,
  _record: N2,
  _refine: gR,
  _regex: vb,
  _safeDecode: Ry,
  _safeDecodeAsync: My,
  _safeEncode: Oy,
  _safeEncodeAsync: Ny,
  _safeParse: Ru,
  _safeParseAsync: Nu,
  _set: D2,
  _size: gb,
  _startsWith: wb,
  _string: OO,
  _stringFormat: Uu,
  _stringbool: bR,
  _success: H2,
  _superRefine: vR,
  _symbol: WO,
  _templateLiteral: J2,
  _toLowerCase: Eb,
  _toUpperCase: $b,
  _transform: L2,
  _trim: Tb,
  _tuple: R2,
  _uint32: HO,
  _uint64: KO,
  _ulid: ab,
  _undefined: QO,
  _union: I2,
  _unknown: nR,
  _uppercase: bb,
  _url: qf,
  _uuid: Ky,
  _uuidv4: Wy,
  _uuidv6: Qy,
  _uuidv7: eb,
  _void: iR,
  _xid: sb,
  clone: dr,
  config: vn,
  decode: bH,
  decodeAsync: wH,
  encode: yH,
  encodeAsync: xH,
  flattenError: Ey,
  formatError: $y,
  globalConfig: lf,
  globalRegistry: Ua,
  isValidBase64: By,
  isValidBase64URL: jC,
  isValidJWT: LC,
  locales: zO,
  parse: Xg,
  parseAsync: Kg,
  prettifyError: mI,
  regexes: Py,
  registry: Jy,
  safeDecode: SH,
  safeDecodeAsync: TH,
  safeEncode: _H,
  safeEncodeAsync: kH,
  safeParse: gI,
  safeParseAsync: vI,
  toDotPath: pI,
  toJSONSchema: xR,
  treeifyError: hI,
  util: vH,
  version: gC
}, Symbol.toStringTag, { value: "Module" })), Ab = /* @__PURE__ */ B("ZodISODateTime", (e, t) => {
  AC.init(e, t), mt.init(e, t);
});
function wR(e) {
  return MO(Ab, e);
}
const zb = /* @__PURE__ */ B("ZodISODate", (e, t) => {
  zC.init(e, t), mt.init(e, t);
});
function _R(e) {
  return DO(zb, e);
}
const Ib = /* @__PURE__ */ B("ZodISOTime", (e, t) => {
  IC.init(e, t), mt.init(e, t);
});
function SR(e) {
  return jO(Ib, e);
}
const Cb = /* @__PURE__ */ B("ZodISODuration", (e, t) => {
  CC.init(e, t), mt.init(e, t);
});
function kR(e) {
  return PO(Cb, e);
}
const eG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ZodISODate: zb,
  ZodISODateTime: Ab,
  ZodISODuration: Cb,
  ZodISOTime: Ib,
  date: _R,
  datetime: wR,
  duration: kR,
  time: SR
}, Symbol.toStringTag, { value: "Module" })), TR = (e, t) => {
  Ty.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (n) => $y(e, n)
      // enumerable: false,
    },
    flatten: {
      value: (n) => Ey(e, n)
      // enumerable: false,
    },
    addIssue: {
      value: (n) => {
        e.issues.push(n), e.message = JSON.stringify(e.issues, uf, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (n) => {
        e.issues.push(...n), e.message = JSON.stringify(e.issues, uf, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, tG = /* @__PURE__ */ B("ZodError", TR), Yn = /* @__PURE__ */ B("ZodError", TR, {
  Parent: Error
}), ER = /* @__PURE__ */ Cu(Yn), $R = /* @__PURE__ */ Ou(Yn), AR = /* @__PURE__ */ Ru(Yn), zR = /* @__PURE__ */ Nu(Yn), IR = /* @__PURE__ */ Ay(Yn), CR = /* @__PURE__ */ zy(Yn), OR = /* @__PURE__ */ Iy(Yn), RR = /* @__PURE__ */ Cy(Yn), NR = /* @__PURE__ */ Oy(Yn), MR = /* @__PURE__ */ Ry(Yn), DR = /* @__PURE__ */ Ny(Yn), jR = /* @__PURE__ */ My(Yn), je = /* @__PURE__ */ B("ZodType", (e, t) => (Ne.init(e, t), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone(
  {
    ...t,
    checks: [
      ...t.checks ?? [],
      ...n.map((i) => typeof i == "function" ? { _zod: { check: i, def: { check: "custom" }, onattach: [] } } : i)
    ]
  }
  // { parent: true }
), e.clone = (n, i) => dr(e, n, i), e.brand = () => e, e.register = ((n, i) => (n.add(e, i), e)), e.parse = (n, i) => ER(e, n, i, { callee: e.parse }), e.safeParse = (n, i) => AR(e, n, i), e.parseAsync = async (n, i) => $R(e, n, i, { callee: e.parseAsync }), e.safeParseAsync = async (n, i) => zR(e, n, i), e.spa = e.safeParseAsync, e.encode = (n, i) => IR(e, n, i), e.decode = (n, i) => CR(e, n, i), e.encodeAsync = async (n, i) => OR(e, n, i), e.decodeAsync = async (n, i) => RR(e, n, i), e.safeEncode = (n, i) => NR(e, n, i), e.safeDecode = (n, i) => MR(e, n, i), e.safeEncodeAsync = async (n, i) => DR(e, n, i), e.safeDecodeAsync = async (n, i) => jR(e, n, i), e.refine = (n, i) => e.check(SN(n, i)), e.superRefine = (n) => e.check(kN(n)), e.overwrite = (n) => e.check(ts(n)), e.optional = () => pf(e), e.nullable = () => mf(e), e.nullish = () => pf(mf(e)), e.nonoptional = (n) => dN(e, n), e.array = () => th(e), e.or = (n) => Qb([e, n]), e.and = (n) => KR(e, n), e.transform = (n) => gf(e, nx(n)), e.default = (n) => lN(e, n), e.prefault = (n) => cN(e, n), e.catch = (n) => pN(e, n), e.pipe = (n) => gf(e, n), e.readonly = () => vN(e), e.describe = (n) => {
  const i = e.clone();
  return Ua.add(i, { description: n }), i;
}, Object.defineProperty(e, "description", {
  get() {
    return Ua.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...n) => {
  if (n.length === 0)
    return Ua.get(e);
  const i = e.clone();
  return Ua.add(i, n[0]), i;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e)), Ob = /* @__PURE__ */ B("_ZodString", (e, t) => {
  Pu.init(e, t), je.init(e, t);
  const n = e._zod.bag;
  e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...i) => e.check(vb(...i)), e.includes = (...i) => e.check(xb(...i)), e.startsWith = (...i) => e.check(wb(...i)), e.endsWith = (...i) => e.check(_b(...i)), e.min = (...i) => e.check(ho(...i)), e.max = (...i) => e.check(Yf(...i)), e.length = (...i) => e.check(Jf(...i)), e.nonempty = (...i) => e.check(ho(1, ...i)), e.lowercase = (i) => e.check(yb(i)), e.uppercase = (i) => e.check(bb(i)), e.trim = () => e.check(Tb()), e.normalize = (...i) => e.check(kb(...i)), e.toLowerCase = () => e.check(Eb()), e.toUpperCase = () => e.check($b());
}), Xf = /* @__PURE__ */ B("ZodString", (e, t) => {
  Pu.init(e, t), Ob.init(e, t), e.email = (n) => e.check(Xy(Rb, n)), e.url = (n) => e.check(qf(Kf, n)), e.jwt = (n) => e.check(mb(Yb, n)), e.emoji = (n) => e.check(tb(Nb, n)), e.guid = (n) => e.check(ff(hf, n)), e.uuid = (n) => e.check(Ky(mi, n)), e.uuidv4 = (n) => e.check(Wy(mi, n)), e.uuidv6 = (n) => e.check(Qy(mi, n)), e.uuidv7 = (n) => e.check(eb(mi, n)), e.nanoid = (n) => e.check(nb(Mb, n)), e.guid = (n) => e.check(ff(hf, n)), e.cuid = (n) => e.check(rb(Db, n)), e.cuid2 = (n) => e.check(ib(jb, n)), e.ulid = (n) => e.check(ab(Pb, n)), e.base64 = (n) => e.check(fb(Hb, n)), e.base64url = (n) => e.check(hb(qb, n)), e.xid = (n) => e.check(sb(Ub, n)), e.ksuid = (n) => e.check(ob(Lb, n)), e.ipv4 = (n) => e.check(lb(Bb, n)), e.ipv6 = (n) => e.check(ub(Zb, n)), e.cidrv4 = (n) => e.check(cb(Vb, n)), e.cidrv6 = (n) => e.check(db(Fb, n)), e.e164 = (n) => e.check(pb(Gb, n)), e.datetime = (n) => e.check(wR(n)), e.date = (n) => e.check(_R(n)), e.time = (n) => e.check(SR(n)), e.duration = (n) => e.check(kR(n));
});
function ev(e) {
  return OO(Xf, e);
}
const mt = /* @__PURE__ */ B("ZodStringFormat", (e, t) => {
  dt.init(e, t), Ob.init(e, t);
}), Rb = /* @__PURE__ */ B("ZodEmail", (e, t) => {
  bC.init(e, t), mt.init(e, t);
});
function nG(e) {
  return Xy(Rb, e);
}
const hf = /* @__PURE__ */ B("ZodGUID", (e, t) => {
  vC.init(e, t), mt.init(e, t);
});
function rG(e) {
  return ff(hf, e);
}
const mi = /* @__PURE__ */ B("ZodUUID", (e, t) => {
  yC.init(e, t), mt.init(e, t);
});
function iG(e) {
  return Ky(mi, e);
}
function aG(e) {
  return Wy(mi, e);
}
function sG(e) {
  return Qy(mi, e);
}
function oG(e) {
  return eb(mi, e);
}
const Kf = /* @__PURE__ */ B("ZodURL", (e, t) => {
  xC.init(e, t), mt.init(e, t);
});
function lG(e) {
  return qf(Kf, e);
}
function uG(e) {
  return qf(Kf, {
    protocol: /^https?$/,
    hostname: RI,
    ...ne(e)
  });
}
const Nb = /* @__PURE__ */ B("ZodEmoji", (e, t) => {
  wC.init(e, t), mt.init(e, t);
});
function cG(e) {
  return tb(Nb, e);
}
const Mb = /* @__PURE__ */ B("ZodNanoID", (e, t) => {
  _C.init(e, t), mt.init(e, t);
});
function dG(e) {
  return nb(Mb, e);
}
const Db = /* @__PURE__ */ B("ZodCUID", (e, t) => {
  SC.init(e, t), mt.init(e, t);
});
function fG(e) {
  return rb(Db, e);
}
const jb = /* @__PURE__ */ B("ZodCUID2", (e, t) => {
  kC.init(e, t), mt.init(e, t);
});
function hG(e) {
  return ib(jb, e);
}
const Pb = /* @__PURE__ */ B("ZodULID", (e, t) => {
  TC.init(e, t), mt.init(e, t);
});
function pG(e) {
  return ab(Pb, e);
}
const Ub = /* @__PURE__ */ B("ZodXID", (e, t) => {
  EC.init(e, t), mt.init(e, t);
});
function mG(e) {
  return sb(Ub, e);
}
const Lb = /* @__PURE__ */ B("ZodKSUID", (e, t) => {
  $C.init(e, t), mt.init(e, t);
});
function gG(e) {
  return ob(Lb, e);
}
const Bb = /* @__PURE__ */ B("ZodIPv4", (e, t) => {
  OC.init(e, t), mt.init(e, t);
});
function vG(e) {
  return lb(Bb, e);
}
const Zb = /* @__PURE__ */ B("ZodIPv6", (e, t) => {
  RC.init(e, t), mt.init(e, t);
});
function yG(e) {
  return ub(Zb, e);
}
const Vb = /* @__PURE__ */ B("ZodCIDRv4", (e, t) => {
  NC.init(e, t), mt.init(e, t);
});
function bG(e) {
  return cb(Vb, e);
}
const Fb = /* @__PURE__ */ B("ZodCIDRv6", (e, t) => {
  MC.init(e, t), mt.init(e, t);
});
function xG(e) {
  return db(Fb, e);
}
const Hb = /* @__PURE__ */ B("ZodBase64", (e, t) => {
  DC.init(e, t), mt.init(e, t);
});
function wG(e) {
  return fb(Hb, e);
}
const qb = /* @__PURE__ */ B("ZodBase64URL", (e, t) => {
  PC.init(e, t), mt.init(e, t);
});
function _G(e) {
  return hb(qb, e);
}
const Gb = /* @__PURE__ */ B("ZodE164", (e, t) => {
  UC.init(e, t), mt.init(e, t);
});
function SG(e) {
  return pb(Gb, e);
}
const Yb = /* @__PURE__ */ B("ZodJWT", (e, t) => {
  BC.init(e, t), mt.init(e, t);
});
function kG(e) {
  return mb(Yb, e);
}
const Lu = /* @__PURE__ */ B("ZodCustomStringFormat", (e, t) => {
  ZC.init(e, t), mt.init(e, t);
});
function TG(e, t, n = {}) {
  return Uu(Lu, e, t, n);
}
function EG(e) {
  return Uu(Lu, "hostname", jy, e);
}
function $G(e) {
  return Uu(Lu, "hex", JI, e);
}
function AG(e, t) {
  const n = t?.enc ?? "hex", i = `${e}_${n}`, r = Py[i];
  if (!r)
    throw new Error(`Unrecognized hash format: ${i}`);
  return Uu(Lu, i, r, t);
}
const Wf = /* @__PURE__ */ B("ZodNumber", (e, t) => {
  Zy.init(e, t), je.init(e, t), e.gt = (i, r) => e.check(Ja(i, r)), e.gte = (i, r) => e.check(Zn(i, r)), e.min = (i, r) => e.check(Zn(i, r)), e.lt = (i, r) => e.check(Ya(i, r)), e.lte = (i, r) => e.check(_r(i, r)), e.max = (i, r) => e.check(_r(i, r)), e.int = (i) => e.check(tv(i)), e.safe = (i) => e.check(tv(i)), e.positive = (i) => e.check(Ja(0, i)), e.nonnegative = (i) => e.check(Zn(0, i)), e.negative = (i) => e.check(Ya(0, i)), e.nonpositive = (i) => e.check(_r(0, i)), e.multipleOf = (i, r) => e.check(lu(i, r)), e.step = (i, r) => e.check(lu(i, r)), e.finite = () => e;
  const n = e._zod.bag;
  e.minValue = Math.max(n.minimum ?? Number.NEGATIVE_INFINITY, n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(n.maximum ?? Number.POSITIVE_INFINITY, n.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (n.format ?? "").includes("int") || Number.isSafeInteger(n.multipleOf ?? 0.5), e.isFinite = !0, e.format = n.format ?? null;
});
function PR(e) {
  return UO(Wf, e);
}
const ko = /* @__PURE__ */ B("ZodNumberFormat", (e, t) => {
  VC.init(e, t), Wf.init(e, t);
});
function tv(e) {
  return BO(ko, e);
}
function zG(e) {
  return ZO(ko, e);
}
function IG(e) {
  return VO(ko, e);
}
function CG(e) {
  return FO(ko, e);
}
function OG(e) {
  return HO(ko, e);
}
const Qf = /* @__PURE__ */ B("ZodBoolean", (e, t) => {
  Vy.init(e, t), je.init(e, t);
});
function UR(e) {
  return qO(Qf, e);
}
const eh = /* @__PURE__ */ B("ZodBigInt", (e, t) => {
  Fy.init(e, t), je.init(e, t), e.gte = (i, r) => e.check(Zn(i, r)), e.min = (i, r) => e.check(Zn(i, r)), e.gt = (i, r) => e.check(Ja(i, r)), e.gte = (i, r) => e.check(Zn(i, r)), e.min = (i, r) => e.check(Zn(i, r)), e.lt = (i, r) => e.check(Ya(i, r)), e.lte = (i, r) => e.check(_r(i, r)), e.max = (i, r) => e.check(_r(i, r)), e.positive = (i) => e.check(Ja(BigInt(0), i)), e.negative = (i) => e.check(Ya(BigInt(0), i)), e.nonpositive = (i) => e.check(_r(BigInt(0), i)), e.nonnegative = (i) => e.check(Zn(BigInt(0), i)), e.multipleOf = (i, r) => e.check(lu(i, r));
  const n = e._zod.bag;
  e.minValue = n.minimum ?? null, e.maxValue = n.maximum ?? null, e.format = n.format ?? null;
});
function RG(e) {
  return YO(eh, e);
}
const Jb = /* @__PURE__ */ B("ZodBigIntFormat", (e, t) => {
  FC.init(e, t), eh.init(e, t);
});
function NG(e) {
  return XO(Jb, e);
}
function MG(e) {
  return KO(Jb, e);
}
const LR = /* @__PURE__ */ B("ZodSymbol", (e, t) => {
  HC.init(e, t), je.init(e, t);
});
function DG(e) {
  return WO(LR, e);
}
const BR = /* @__PURE__ */ B("ZodUndefined", (e, t) => {
  qC.init(e, t), je.init(e, t);
});
function jG(e) {
  return QO(BR, e);
}
const ZR = /* @__PURE__ */ B("ZodNull", (e, t) => {
  GC.init(e, t), je.init(e, t);
});
function VR(e) {
  return eR(ZR, e);
}
const FR = /* @__PURE__ */ B("ZodAny", (e, t) => {
  YC.init(e, t), je.init(e, t);
});
function PG() {
  return tR(FR);
}
const HR = /* @__PURE__ */ B("ZodUnknown", (e, t) => {
  JC.init(e, t), je.init(e, t);
});
function po() {
  return nR(HR);
}
const qR = /* @__PURE__ */ B("ZodNever", (e, t) => {
  XC.init(e, t), je.init(e, t);
});
function Xb(e) {
  return rR(qR, e);
}
const GR = /* @__PURE__ */ B("ZodVoid", (e, t) => {
  KC.init(e, t), je.init(e, t);
});
function UG(e) {
  return iR(GR, e);
}
const Kb = /* @__PURE__ */ B("ZodDate", (e, t) => {
  WC.init(e, t), je.init(e, t), e.min = (i, r) => e.check(Zn(i, r)), e.max = (i, r) => e.check(_r(i, r));
  const n = e._zod.bag;
  e.minDate = n.minimum ? new Date(n.minimum) : null, e.maxDate = n.maximum ? new Date(n.maximum) : null;
});
function LG(e) {
  return aR(Kb, e);
}
const YR = /* @__PURE__ */ B("ZodArray", (e, t) => {
  QC.init(e, t), je.init(e, t), e.element = t.element, e.min = (n, i) => e.check(ho(n, i)), e.nonempty = (n) => e.check(ho(1, n)), e.max = (n, i) => e.check(Yf(n, i)), e.length = (n, i) => e.check(Jf(n, i)), e.unwrap = () => e.element;
});
function th(e, t) {
  return hR(YR, e, t);
}
function BG(e) {
  const t = e._zod.def.shape;
  return tx(Object.keys(t));
}
const nh = /* @__PURE__ */ B("ZodObject", (e, t) => {
  rO.init(e, t), je.init(e, t), He(e, "shape", () => t.shape), e.keyof = () => tx(Object.keys(e._zod.def.shape)), e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: po() }), e.loose = () => e.clone({ ...e._zod.def, catchall: po() }), e.strict = () => e.clone({ ...e._zod.def, catchall: Xb() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (n) => aI(e, n), e.safeExtend = (n) => sI(e, n), e.merge = (n) => oI(e, n), e.pick = (n) => rI(e, n), e.omit = (n) => iI(e, n), e.partial = (...n) => lI(rx, e, n[0]), e.required = (...n) => uI(ix, e, n[0]);
});
function ZG(e, t) {
  const n = {
    type: "object",
    get shape() {
      return Ir(this, "shape", e ? Zf(e) : {}), this.shape;
    },
    ...ne(t)
  };
  return new nh(n);
}
function VG(e, t) {
  return new nh({
    type: "object",
    get shape() {
      return Ir(this, "shape", Zf(e)), this.shape;
    },
    catchall: Xb(),
    ...ne(t)
  });
}
function FG(e, t) {
  return new nh({
    type: "object",
    get shape() {
      return Ir(this, "shape", Zf(e)), this.shape;
    },
    catchall: po(),
    ...ne(t)
  });
}
const Wb = /* @__PURE__ */ B("ZodUnion", (e, t) => {
  Hy.init(e, t), je.init(e, t), e.options = t.options;
});
function Qb(e, t) {
  return new Wb({
    type: "union",
    options: e,
    ...ne(t)
  });
}
const JR = /* @__PURE__ */ B("ZodDiscriminatedUnion", (e, t) => {
  Wb.init(e, t), iO.init(e, t);
});
function HG(e, t, n) {
  return new JR({
    type: "union",
    options: t,
    discriminator: e,
    ...ne(n)
  });
}
const XR = /* @__PURE__ */ B("ZodIntersection", (e, t) => {
  aO.init(e, t), je.init(e, t);
});
function KR(e, t) {
  return new XR({
    type: "intersection",
    left: e,
    right: t
  });
}
const WR = /* @__PURE__ */ B("ZodTuple", (e, t) => {
  qy.init(e, t), je.init(e, t), e.rest = (n) => e.clone({
    ...e._zod.def,
    rest: n
  });
});
function QR(e, t, n) {
  const i = t instanceof Ne, r = i ? n : t, s = i ? t : null;
  return new WR({
    type: "tuple",
    items: e,
    rest: s,
    ...ne(r)
  });
}
const ex = /* @__PURE__ */ B("ZodRecord", (e, t) => {
  sO.init(e, t), je.init(e, t), e.keyType = t.keyType, e.valueType = t.valueType;
});
function eN(e, t, n) {
  return new ex({
    type: "record",
    keyType: e,
    valueType: t,
    ...ne(n)
  });
}
function qG(e, t, n) {
  const i = dr(e);
  return i._zod.values = void 0, new ex({
    type: "record",
    keyType: i,
    valueType: t,
    ...ne(n)
  });
}
const tN = /* @__PURE__ */ B("ZodMap", (e, t) => {
  oO.init(e, t), je.init(e, t), e.keyType = t.keyType, e.valueType = t.valueType;
});
function GG(e, t, n) {
  return new tN({
    type: "map",
    keyType: e,
    valueType: t,
    ...ne(n)
  });
}
const nN = /* @__PURE__ */ B("ZodSet", (e, t) => {
  lO.init(e, t), je.init(e, t), e.min = (...n) => e.check(uu(...n)), e.nonempty = (n) => e.check(uu(1, n)), e.max = (...n) => e.check(Gf(...n)), e.size = (...n) => e.check(gb(...n));
});
function YG(e, t) {
  return new nN({
    type: "set",
    valueType: e,
    ...ne(t)
  });
}
const cu = /* @__PURE__ */ B("ZodEnum", (e, t) => {
  uO.init(e, t), je.init(e, t), e.enum = t.entries, e.options = Object.values(t.entries);
  const n = new Set(Object.keys(t.entries));
  e.extract = (i, r) => {
    const s = {};
    for (const l of i)
      if (n.has(l))
        s[l] = t.entries[l];
      else
        throw new Error(`Key ${l} not found in enum`);
    return new cu({
      ...t,
      checks: [],
      ...ne(r),
      entries: s
    });
  }, e.exclude = (i, r) => {
    const s = { ...t.entries };
    for (const l of i)
      if (n.has(l))
        delete s[l];
      else
        throw new Error(`Key ${l} not found in enum`);
    return new cu({
      ...t,
      checks: [],
      ...ne(r),
      entries: s
    });
  };
});
function tx(e, t) {
  const n = Array.isArray(e) ? Object.fromEntries(e.map((i) => [i, i])) : e;
  return new cu({
    type: "enum",
    entries: n,
    ...ne(t)
  });
}
function JG(e, t) {
  return new cu({
    type: "enum",
    entries: e,
    ...ne(t)
  });
}
const rN = /* @__PURE__ */ B("ZodLiteral", (e, t) => {
  cO.init(e, t), je.init(e, t), e.values = new Set(t.values), Object.defineProperty(e, "value", {
    get() {
      if (t.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return t.values[0];
    }
  });
});
function XG(e, t) {
  return new rN({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...ne(t)
  });
}
const iN = /* @__PURE__ */ B("ZodFile", (e, t) => {
  dO.init(e, t), je.init(e, t), e.min = (n, i) => e.check(uu(n, i)), e.max = (n, i) => e.check(Gf(n, i)), e.mime = (n, i) => e.check(Sb(Array.isArray(n) ? n : [n], i));
});
function KG(e) {
  return pR(iN, e);
}
const aN = /* @__PURE__ */ B("ZodTransform", (e, t) => {
  fO.init(e, t), je.init(e, t), e._zod.parse = (n, i) => {
    if (i.direction === "backward")
      throw new Lf(e.constructor.name);
    n.addIssue = (s) => {
      if (typeof s == "string")
        n.issues.push(co(s, n.value, t));
      else {
        const l = s;
        l.fatal && (l.continue = !1), l.code ?? (l.code = "custom"), l.input ?? (l.input = n.value), l.inst ?? (l.inst = e), n.issues.push(co(l));
      }
    };
    const r = t.transform(n.value, n);
    return r instanceof Promise ? r.then((s) => (n.value = s, n)) : (n.value = r, n);
  };
});
function nx(e) {
  return new aN({
    type: "transform",
    transform: e
  });
}
const rx = /* @__PURE__ */ B("ZodOptional", (e, t) => {
  hO.init(e, t), je.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function pf(e) {
  return new rx({
    type: "optional",
    innerType: e
  });
}
const sN = /* @__PURE__ */ B("ZodNullable", (e, t) => {
  pO.init(e, t), je.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function mf(e) {
  return new sN({
    type: "nullable",
    innerType: e
  });
}
function WG(e) {
  return pf(mf(e));
}
const oN = /* @__PURE__ */ B("ZodDefault", (e, t) => {
  mO.init(e, t), je.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function lN(e, t) {
  return new oN({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : Vf(t);
    }
  });
}
const uN = /* @__PURE__ */ B("ZodPrefault", (e, t) => {
  gO.init(e, t), je.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function cN(e, t) {
  return new uN({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : Vf(t);
    }
  });
}
const ix = /* @__PURE__ */ B("ZodNonOptional", (e, t) => {
  vO.init(e, t), je.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function dN(e, t) {
  return new ix({
    type: "nonoptional",
    innerType: e,
    ...ne(t)
  });
}
const fN = /* @__PURE__ */ B("ZodSuccess", (e, t) => {
  yO.init(e, t), je.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function QG(e) {
  return new fN({
    type: "success",
    innerType: e
  });
}
const hN = /* @__PURE__ */ B("ZodCatch", (e, t) => {
  bO.init(e, t), je.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function pN(e, t) {
  return new hN({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const mN = /* @__PURE__ */ B("ZodNaN", (e, t) => {
  xO.init(e, t), je.init(e, t);
});
function eY(e) {
  return oR(mN, e);
}
const ax = /* @__PURE__ */ B("ZodPipe", (e, t) => {
  wO.init(e, t), je.init(e, t), e.in = t.in, e.out = t.out;
});
function gf(e, t) {
  return new ax({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const sx = /* @__PURE__ */ B("ZodCodec", (e, t) => {
  ax.init(e, t), Gy.init(e, t);
});
function tY(e, t, n) {
  return new sx({
    type: "pipe",
    in: e,
    out: t,
    transform: n.decode,
    reverseTransform: n.encode
  });
}
const gN = /* @__PURE__ */ B("ZodReadonly", (e, t) => {
  _O.init(e, t), je.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function vN(e) {
  return new gN({
    type: "readonly",
    innerType: e
  });
}
const yN = /* @__PURE__ */ B("ZodTemplateLiteral", (e, t) => {
  SO.init(e, t), je.init(e, t);
});
function nY(e, t) {
  return new yN({
    type: "template_literal",
    parts: e,
    ...ne(t)
  });
}
const bN = /* @__PURE__ */ B("ZodLazy", (e, t) => {
  EO.init(e, t), je.init(e, t), e.unwrap = () => e._zod.def.getter();
});
function xN(e) {
  return new bN({
    type: "lazy",
    getter: e
  });
}
const wN = /* @__PURE__ */ B("ZodPromise", (e, t) => {
  TO.init(e, t), je.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function rY(e) {
  return new wN({
    type: "promise",
    innerType: e
  });
}
const _N = /* @__PURE__ */ B("ZodFunction", (e, t) => {
  kO.init(e, t), je.init(e, t);
});
function Bk(e) {
  return new _N({
    type: "function",
    input: Array.isArray(e?.input) ? QR(e?.input) : e?.input ?? th(po()),
    output: e?.output ?? po()
  });
}
const rh = /* @__PURE__ */ B("ZodCustom", (e, t) => {
  $O.init(e, t), je.init(e, t);
});
function iY(e) {
  const t = new At({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  return t._zod.check = e, t;
}
function aY(e, t) {
  return mR(rh, e ?? (() => !0), t);
}
function SN(e, t = {}) {
  return gR(rh, e, t);
}
function kN(e) {
  return vR(e);
}
function sY(e, t = {
  error: `Input not instance of ${e.name}`
}) {
  const n = new rh({
    type: "custom",
    check: "custom",
    fn: (i) => i instanceof e,
    abort: !0,
    ...ne(t)
  });
  return n._zod.bag.Class = e, n;
}
const oY = (...e) => bR({
  Codec: sx,
  Boolean: Qf,
  String: Xf
}, ...e);
function lY(e) {
  const t = xN(() => Qb([ev(e), PR(), UR(), VR(), th(t), eN(ev(), t)]));
  return t;
}
function uY(e, t) {
  return gf(nx(e), t);
}
const cY = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function dY(e) {
  vn({
    customError: e
  });
}
function fY() {
  return vn().customError;
}
var nv;
nv || (nv = {});
function hY(e) {
  return RO(Xf, e);
}
function pY(e) {
  return LO(Wf, e);
}
function mY(e) {
  return GO(Qf, e);
}
function gY(e) {
  return JO(eh, e);
}
function vY(e) {
  return sR(Kb, e);
}
const yY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bigint: gY,
  boolean: mY,
  date: vY,
  number: pY,
  string: hY
}, Symbol.toStringTag, { value: "Module" }));
vn(AO());
const Zk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $brand: Xz,
  $input: CO,
  $output: IO,
  NEVER: Jz,
  TimePrecision: NO,
  ZodAny: FR,
  ZodArray: YR,
  ZodBase64: Hb,
  ZodBase64URL: qb,
  ZodBigInt: eh,
  ZodBigIntFormat: Jb,
  ZodBoolean: Qf,
  ZodCIDRv4: Vb,
  ZodCIDRv6: Fb,
  ZodCUID: Db,
  ZodCUID2: jb,
  ZodCatch: hN,
  ZodCodec: sx,
  ZodCustom: rh,
  ZodCustomStringFormat: Lu,
  ZodDate: Kb,
  ZodDefault: oN,
  ZodDiscriminatedUnion: JR,
  ZodE164: Gb,
  ZodEmail: Rb,
  ZodEmoji: Nb,
  ZodEnum: cu,
  ZodError: tG,
  ZodFile: iN,
  get ZodFirstPartyTypeKind() {
    return nv;
  },
  ZodFunction: _N,
  ZodGUID: hf,
  ZodIPv4: Bb,
  ZodIPv6: Zb,
  ZodISODate: zb,
  ZodISODateTime: Ab,
  ZodISODuration: Cb,
  ZodISOTime: Ib,
  ZodIntersection: XR,
  ZodIssueCode: cY,
  ZodJWT: Yb,
  ZodKSUID: Lb,
  ZodLazy: bN,
  ZodLiteral: rN,
  ZodMap: tN,
  ZodNaN: mN,
  ZodNanoID: Mb,
  ZodNever: qR,
  ZodNonOptional: ix,
  ZodNull: ZR,
  ZodNullable: sN,
  ZodNumber: Wf,
  ZodNumberFormat: ko,
  ZodObject: nh,
  ZodOptional: rx,
  ZodPipe: ax,
  ZodPrefault: uN,
  ZodPromise: wN,
  ZodReadonly: gN,
  ZodRealError: Yn,
  ZodRecord: ex,
  ZodSet: nN,
  ZodString: Xf,
  ZodStringFormat: mt,
  ZodSuccess: fN,
  ZodSymbol: LR,
  ZodTemplateLiteral: yN,
  ZodTransform: aN,
  ZodTuple: WR,
  ZodType: je,
  ZodULID: Pb,
  ZodURL: Kf,
  ZodUUID: mi,
  ZodUndefined: BR,
  ZodUnion: Wb,
  ZodUnknown: HR,
  ZodVoid: GR,
  ZodXID: Ub,
  _ZodString: Ob,
  _default: lN,
  _function: Bk,
  any: PG,
  array: th,
  base64: wG,
  base64url: _G,
  bigint: RG,
  boolean: UR,
  catch: pN,
  check: iY,
  cidrv4: bG,
  cidrv6: xG,
  clone: dr,
  codec: tY,
  coerce: yY,
  config: vn,
  core: Q2,
  cuid: fG,
  cuid2: hG,
  custom: aY,
  date: LG,
  decode: CR,
  decodeAsync: RR,
  discriminatedUnion: HG,
  e164: SG,
  email: nG,
  emoji: cG,
  encode: IR,
  encodeAsync: OR,
  endsWith: _b,
  enum: tx,
  file: KG,
  flattenError: Ey,
  float32: zG,
  float64: IG,
  formatError: $y,
  function: Bk,
  getErrorMap: fY,
  globalRegistry: Ua,
  gt: Ja,
  gte: Zn,
  guid: rG,
  hash: AG,
  hex: $G,
  hostname: EG,
  httpUrl: uG,
  includes: xb,
  instanceof: sY,
  int: tv,
  int32: CG,
  int64: NG,
  intersection: KR,
  ipv4: vG,
  ipv6: yG,
  iso: eG,
  json: lY,
  jwt: kG,
  keyof: BG,
  ksuid: gG,
  lazy: xN,
  length: Jf,
  literal: XG,
  locales: zO,
  looseObject: FG,
  lowercase: yb,
  lt: Ya,
  lte: _r,
  map: GG,
  maxLength: Yf,
  maxSize: Gf,
  mime: Sb,
  minLength: ho,
  minSize: uu,
  multipleOf: lu,
  nan: eY,
  nanoid: dG,
  nativeEnum: JG,
  negative: uR,
  never: Xb,
  nonnegative: dR,
  nonoptional: dN,
  nonpositive: cR,
  normalize: kb,
  null: VR,
  nullable: mf,
  nullish: WG,
  number: PR,
  object: ZG,
  optional: pf,
  overwrite: ts,
  parse: ER,
  parseAsync: $R,
  partialRecord: qG,
  pipe: gf,
  positive: lR,
  prefault: cN,
  preprocess: uY,
  prettifyError: mI,
  promise: rY,
  property: fR,
  readonly: vN,
  record: eN,
  refine: SN,
  regex: vb,
  regexes: Py,
  registry: Jy,
  safeDecode: MR,
  safeDecodeAsync: jR,
  safeEncode: NR,
  safeEncodeAsync: DR,
  safeParse: AR,
  safeParseAsync: zR,
  set: YG,
  setErrorMap: dY,
  size: gb,
  startsWith: wb,
  strictObject: VG,
  string: ev,
  stringFormat: TG,
  stringbool: oY,
  success: QG,
  superRefine: kN,
  symbol: DG,
  templateLiteral: nY,
  toJSONSchema: xR,
  toLowerCase: Eb,
  toUpperCase: $b,
  transform: nx,
  treeifyError: hI,
  trim: Tb,
  tuple: QR,
  uint32: OG,
  uint64: MG,
  ulid: pG,
  undefined: jG,
  union: Qb,
  unknown: po,
  uppercase: bb,
  url: lG,
  uuid: iG,
  uuidv4: aG,
  uuidv6: sG,
  uuidv7: oG,
  void: UG,
  xid: mG
}, Symbol.toStringTag, { value: "Module" }));
var bY = (e) => Object.fromEntries(
  Object.entries(e).map(([t, n]) => [
    t,
    {
      ...n.description ? { description: n.description } : void 0,
      parameters: n.parameters instanceof Zk.ZodType ? Zk.toJSONSchema(n.parameters) : n.parameters
    }
  ])
), xY = (e) => Object.fromEntries(
  Object.entries(e).filter(
    ([, t]) => !t.disabled && t.type !== "backend"
  )
), Vk = class extends Gz {
  runtime;
  constructor(e) {
    super({
      ...e,
      prepareSendMessagesRequest: async (t) => {
        const n = this.runtime?.thread.getModelContext(), i = {
          ...t,
          body: {
            callSettings: n?.callSettings,
            system: n?.system,
            tools: bY(xY(n?.tools ?? {})),
            ...t?.body
          }
        }, r = await e?.prepareSendMessagesRequest?.(i);
        return {
          ...r,
          body: r?.body ?? {
            ...i.body,
            id: t.id,
            messages: t.messages,
            trigger: t.trigger,
            messageId: t.messageId
          }
        };
      }
    });
  }
  setRuntime(e) {
    this.runtime = e;
  }
}, wY = (e) => {
  const {
    adapters: t,
    transport: n,
    ...i
  } = e ?? {}, r = n ?? new Vk(), s = S$(), l = W7({
    ...i,
    transport: r,
    onToolCall: async ({ toolCall: f }) => {
      await i.onToolCall?.({ toolCall: f });
      const p = c.thread.getModelContext().tools?.[f.toolName];
      if (p)
        try {
          const m = await p.execute?.(f.input, {
            toolCallId: f.toolCallId,
            abortSignal: new AbortController().signal
            // dummy signal for now
          });
          l.addToolResult({
            tool: f.toolName,
            toolCallId: f.toolCallId,
            output: m
          });
        } catch (m) {
          l.addToolResult({
            tool: f.toolName,
            toolCallId: f.toolCallId,
            output: {
              error: m instanceof Error ? m.message : String(m)
            }
          });
        }
    }
  }), c = q7(l, {
    adapters: {
      ...s,
      ...t
    }
  });
  return r instanceof Vk && r.setRuntime(c), c;
}, _Y = ({
  cloud: e,
  ...t
} = {}) => {
  const n = bL({ cloud: e });
  return OL({
    runtimeHook: function() {
      return wY(t);
    },
    adapter: n
  });
};
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SY = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), kY = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, i) => i ? i.toUpperCase() : n.toLowerCase()
), Fk = (e) => {
  const t = kY(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
}, TN = (...e) => e.filter((t, n, i) => !!t && t.trim() !== "" && i.indexOf(t) === n).join(" ").trim(), TY = (e) => {
  for (const t in e)
    if (t.startsWith("aria-") || t === "role" || t === "title")
      return !0;
};
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var EY = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const $Y = $.forwardRef(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: i,
    className: r = "",
    children: s,
    iconNode: l,
    ...c
  }, f) => $.createElement(
    "svg",
    {
      ref: f,
      ...EY,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: i ? Number(n) * 24 / Number(t) : n,
      className: TN("lucide", r),
      ...!s && !TY(c) && { "aria-hidden": "true" },
      ...c
    },
    [
      ...l.map(([h, p]) => $.createElement(h, p)),
      ...Array.isArray(s) ? s : [s]
    ]
  )
);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fr = (e, t) => {
  const n = $.forwardRef(
    ({ className: i, ...r }, s) => $.createElement($Y, {
      ref: s,
      iconNode: t,
      className: TN(
        `lucide-${SY(Fk(e))}`,
        `lucide-${e}`,
        i
      ),
      ...r
    })
  );
  return n.displayName = Fk(e), n;
};
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const AY = [
  ["path", { d: "M12 5v14", key: "s699le" }],
  ["path", { d: "m19 12-7 7-7-7", key: "1idqje" }]
], zY = fr("arrow-down", AY);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const IY = [
  ["path", { d: "m5 12 7-7 7 7", key: "hav0vg" }],
  ["path", { d: "M12 19V5", key: "x0mq9r" }]
], CY = fr("arrow-up", IY);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const OY = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], ox = fr("check", OY);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const RY = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], NY = fr("chevron-down", RY);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const MY = [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]], DY = fr("chevron-left", MY);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const jY = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]], PY = fr("chevron-right", jY);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const UY = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], LY = fr("chevron-up", UY);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const BY = [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
], EN = fr("copy", BY);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ZY = [
  [
    "path",
    {
      d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",
      key: "1a8usu"
    }
  ],
  ["path", { d: "m15 5 4 4", key: "1mk7zo" }]
], VY = fr("pencil", ZY);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const FY = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
], HY = fr("plus", FY);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const qY = [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
], GY = fr("refresh-cw", qY);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const YY = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }]
], JY = fr("square", YY);
var XY = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), KY = "VisuallyHidden", $N = $.forwardRef(
  (e, t) => /* @__PURE__ */ C.jsx(
    Ft.span,
    {
      ...e,
      ref: t,
      style: { ...XY, ...e.style }
    }
  )
);
$N.displayName = KY;
var WY = $N, [ih, tle] = X$("Tooltip", [
  hA
]), ah = hA(), AN = "TooltipProvider", QY = 700, rv = "tooltip.open", [eJ, lx] = ih(AN), zN = (e) => {
  const {
    __scopeTooltip: t,
    delayDuration: n = QY,
    skipDelayDuration: i = 300,
    disableHoverableContent: r = !1,
    children: s
  } = e, l = $.useRef(!0), c = $.useRef(!1), f = $.useRef(0);
  return $.useEffect(() => {
    const h = f.current;
    return () => window.clearTimeout(h);
  }, []), /* @__PURE__ */ C.jsx(
    eJ,
    {
      scope: t,
      isOpenDelayedRef: l,
      delayDuration: n,
      onOpen: $.useCallback(() => {
        window.clearTimeout(f.current), l.current = !1;
      }, []),
      onClose: $.useCallback(() => {
        window.clearTimeout(f.current), f.current = window.setTimeout(
          () => l.current = !0,
          i
        );
      }, [i]),
      isPointerInTransitRef: c,
      onPointerInTransitChange: $.useCallback((h) => {
        c.current = h;
      }, []),
      disableHoverableContent: r,
      children: s
    }
  );
};
zN.displayName = AN;
var du = "Tooltip", [tJ, Bu] = ih(du), IN = (e) => {
  const {
    __scopeTooltip: t,
    children: n,
    open: i,
    defaultOpen: r,
    onOpenChange: s,
    disableHoverableContent: l,
    delayDuration: c
  } = e, f = lx(du, e.__scopeTooltip), h = ah(t), [p, m] = $.useState(null), y = iB(), b = $.useRef(0), x = l ?? f.disableHoverableContent, w = c ?? f.delayDuration, k = $.useRef(!1), [T, A] = R3({
    prop: i,
    defaultProp: r ?? !1,
    onChange: (U) => {
      U ? (f.onOpen(), document.dispatchEvent(new CustomEvent(rv))) : f.onClose(), s?.(U);
    },
    caller: du
  }), z = $.useMemo(() => T ? k.current ? "delayed-open" : "instant-open" : "closed", [T]), O = $.useCallback(() => {
    window.clearTimeout(b.current), b.current = 0, k.current = !1, A(!0);
  }, [A]), M = $.useCallback(() => {
    window.clearTimeout(b.current), b.current = 0, A(!1);
  }, [A]), N = $.useCallback(() => {
    window.clearTimeout(b.current), b.current = window.setTimeout(() => {
      k.current = !0, A(!0), b.current = 0;
    }, w);
  }, [w, A]);
  return $.useEffect(() => () => {
    b.current && (window.clearTimeout(b.current), b.current = 0);
  }, []), /* @__PURE__ */ C.jsx(k3, { ...h, children: /* @__PURE__ */ C.jsx(
    tJ,
    {
      scope: t,
      contentId: y,
      open: T,
      stateAttribute: z,
      trigger: p,
      onTriggerChange: m,
      onTriggerEnter: $.useCallback(() => {
        f.isOpenDelayedRef.current ? N() : O();
      }, [f.isOpenDelayedRef, N, O]),
      onTriggerLeave: $.useCallback(() => {
        x ? M() : (window.clearTimeout(b.current), b.current = 0);
      }, [M, x]),
      onOpen: O,
      onClose: M,
      disableHoverableContent: x,
      children: n
    }
  ) });
};
IN.displayName = du;
var iv = "TooltipTrigger", CN = $.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...i } = e, r = Bu(iv, n), s = lx(iv, n), l = ah(n), c = $.useRef(null), f = zr(t, c, r.onTriggerChange), h = $.useRef(!1), p = $.useRef(!1), m = $.useCallback(() => h.current = !1, []);
    return $.useEffect(() => () => document.removeEventListener("pointerup", m), [m]), /* @__PURE__ */ C.jsx(T3, { asChild: !0, ...l, children: /* @__PURE__ */ C.jsx(
      Ft.button,
      {
        "aria-describedby": r.open ? r.contentId : void 0,
        "data-state": r.stateAttribute,
        ...i,
        ref: f,
        onPointerMove: hn(e.onPointerMove, (y) => {
          y.pointerType !== "touch" && !p.current && !s.isPointerInTransitRef.current && (r.onTriggerEnter(), p.current = !0);
        }),
        onPointerLeave: hn(e.onPointerLeave, () => {
          r.onTriggerLeave(), p.current = !1;
        }),
        onPointerDown: hn(e.onPointerDown, () => {
          r.open && r.onClose(), h.current = !0, document.addEventListener("pointerup", m, { once: !0 });
        }),
        onFocus: hn(e.onFocus, () => {
          h.current || r.onOpen();
        }),
        onBlur: hn(e.onBlur, r.onClose),
        onClick: hn(e.onClick, r.onClose)
      }
    ) });
  }
);
CN.displayName = iv;
var ux = "TooltipPortal", [nJ, rJ] = ih(ux, {
  forceMount: void 0
}), ON = (e) => {
  const { __scopeTooltip: t, forceMount: n, children: i, container: r } = e, s = Bu(ux, t);
  return /* @__PURE__ */ C.jsx(nJ, { scope: t, forceMount: n, children: /* @__PURE__ */ C.jsx(iy, { present: n || s.open, children: /* @__PURE__ */ C.jsx(_A, { asChild: !0, container: r, children: i }) }) });
};
ON.displayName = ux;
var mo = "TooltipContent", RN = $.forwardRef(
  (e, t) => {
    const n = rJ(mo, e.__scopeTooltip), { forceMount: i = n.forceMount, side: r = "top", ...s } = e, l = Bu(mo, e.__scopeTooltip);
    return /* @__PURE__ */ C.jsx(iy, { present: i || l.open, children: l.disableHoverableContent ? /* @__PURE__ */ C.jsx(NN, { side: r, ...s, ref: t }) : /* @__PURE__ */ C.jsx(iJ, { side: r, ...s, ref: t }) });
  }
), iJ = $.forwardRef((e, t) => {
  const n = Bu(mo, e.__scopeTooltip), i = lx(mo, e.__scopeTooltip), r = $.useRef(null), s = zr(t, r), [l, c] = $.useState(null), { trigger: f, onClose: h } = n, p = r.current, { onPointerInTransitChange: m } = i, y = $.useCallback(() => {
    c(null), m(!1);
  }, [m]), b = $.useCallback(
    (x, w) => {
      const k = x.currentTarget, T = { x: x.clientX, y: x.clientY }, A = lJ(T, k.getBoundingClientRect()), z = uJ(T, A), O = cJ(w.getBoundingClientRect()), M = fJ([...z, ...O]);
      c(M), m(!0);
    },
    [m]
  );
  return $.useEffect(() => () => y(), [y]), $.useEffect(() => {
    if (f && p) {
      const x = (k) => b(k, p), w = (k) => b(k, f);
      return f.addEventListener("pointerleave", x), p.addEventListener("pointerleave", w), () => {
        f.removeEventListener("pointerleave", x), p.removeEventListener("pointerleave", w);
      };
    }
  }, [f, p, b, y]), $.useEffect(() => {
    if (l) {
      const x = (w) => {
        const k = w.target, T = { x: w.clientX, y: w.clientY }, A = f?.contains(k) || p?.contains(k), z = !dJ(T, l);
        A ? y() : z && (y(), h());
      };
      return document.addEventListener("pointermove", x), () => document.removeEventListener("pointermove", x);
    }
  }, [f, p, l, h, y]), /* @__PURE__ */ C.jsx(NN, { ...e, ref: s });
}), [aJ, sJ] = ih(du, { isInside: !1 }), oJ = /* @__PURE__ */ ML("TooltipContent"), NN = $.forwardRef(
  (e, t) => {
    const {
      __scopeTooltip: n,
      children: i,
      "aria-label": r,
      onEscapeKeyDown: s,
      onPointerDownOutside: l,
      ...c
    } = e, f = Bu(mo, n), h = ah(n), { onClose: p } = f;
    return $.useEffect(() => (document.addEventListener(rv, p), () => document.removeEventListener(rv, p)), [p]), $.useEffect(() => {
      if (f.trigger) {
        const m = (y) => {
          y.target?.contains(f.trigger) && p();
        };
        return window.addEventListener("scroll", m, { capture: !0 }), () => window.removeEventListener("scroll", m, { capture: !0 });
      }
    }, [f.trigger, p]), /* @__PURE__ */ C.jsx(
      W$,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: s,
        onPointerDownOutside: l,
        onFocusOutside: (m) => m.preventDefault(),
        onDismiss: p,
        children: /* @__PURE__ */ C.jsxs(
          E3,
          {
            "data-state": f.stateAttribute,
            ...h,
            ...c,
            ref: t,
            style: {
              ...c.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ C.jsx(oJ, { children: i }),
              /* @__PURE__ */ C.jsx(aJ, { scope: n, isInside: !0, children: /* @__PURE__ */ C.jsx(WY, { id: f.contentId, role: "tooltip", children: r || i }) })
            ]
          }
        )
      }
    );
  }
);
RN.displayName = mo;
var MN = "TooltipArrow", DN = $.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...i } = e, r = ah(n);
    return sJ(
      MN,
      n
    ).isInside ? null : /* @__PURE__ */ C.jsx($3, { ...r, ...i, ref: t });
  }
);
DN.displayName = MN;
function lJ(e, t) {
  const n = Math.abs(t.top - e.y), i = Math.abs(t.bottom - e.y), r = Math.abs(t.right - e.x), s = Math.abs(t.left - e.x);
  switch (Math.min(n, i, r, s)) {
    case s:
      return "left";
    case r:
      return "right";
    case n:
      return "top";
    case i:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function uJ(e, t, n = 5) {
  const i = [];
  switch (t) {
    case "top":
      i.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      i.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      i.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      i.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return i;
}
function cJ(e) {
  const { top: t, right: n, bottom: i, left: r } = e;
  return [
    { x: r, y: t },
    { x: n, y: t },
    { x: n, y: i },
    { x: r, y: i }
  ];
}
function dJ(e, t) {
  const { x: n, y: i } = e;
  let r = !1;
  for (let s = 0, l = t.length - 1; s < t.length; l = s++) {
    const c = t[s], f = t[l], h = c.x, p = c.y, m = f.x, y = f.y;
    p > i != y > i && n < (m - h) * (i - p) / (y - p) + h && (r = !r);
  }
  return r;
}
function fJ(e) {
  const t = e.slice();
  return t.sort((n, i) => n.x < i.x ? -1 : n.x > i.x ? 1 : n.y < i.y ? -1 : n.y > i.y ? 1 : 0), hJ(t);
}
function hJ(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let i = 0; i < e.length; i++) {
    const r = e[i];
    for (; t.length >= 2; ) {
      const s = t[t.length - 1], l = t[t.length - 2];
      if ((s.x - l.x) * (r.y - l.y) >= (s.y - l.y) * (r.x - l.x)) t.pop();
      else break;
    }
    t.push(r);
  }
  t.pop();
  const n = [];
  for (let i = e.length - 1; i >= 0; i--) {
    const r = e[i];
    for (; n.length >= 2; ) {
      const s = n[n.length - 1], l = n[n.length - 2];
      if ((s.x - l.x) * (r.y - l.y) >= (s.y - l.y) * (r.x - l.x)) n.pop();
      else break;
    }
    n.push(r);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var pJ = zN, mJ = IN, gJ = CN, vJ = ON, yJ = RN, bJ = DN;
function jN(e) {
  var t, n, i = "";
  if (typeof e == "string" || typeof e == "number") i += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var r = e.length;
    for (t = 0; t < r; t++) e[t] && (n = jN(e[t])) && (i && (i += " "), i += n);
  } else for (n in e) e[n] && (i && (i += " "), i += n);
  return i;
}
function PN() {
  for (var e, t, n = 0, i = "", r = arguments.length; n < r; n++) (e = arguments[n]) && (t = jN(e)) && (i && (i += " "), i += t);
  return i;
}
const cx = "-", xJ = (e) => {
  const t = _J(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: i
  } = e;
  return {
    getClassGroupId: (l) => {
      const c = l.split(cx);
      return c[0] === "" && c.length !== 1 && c.shift(), UN(c, t) || wJ(l);
    },
    getConflictingClassGroupIds: (l, c) => {
      const f = n[l] || [];
      return c && i[l] ? [...f, ...i[l]] : f;
    }
  };
}, UN = (e, t) => {
  if (e.length === 0)
    return t.classGroupId;
  const n = e[0], i = t.nextPart.get(n), r = i ? UN(e.slice(1), i) : void 0;
  if (r)
    return r;
  if (t.validators.length === 0)
    return;
  const s = e.join(cx);
  return t.validators.find(({
    validator: l
  }) => l(s))?.classGroupId;
}, Hk = /^\[(.+)\]$/, wJ = (e) => {
  if (Hk.test(e)) {
    const t = Hk.exec(e)[1], n = t?.substring(0, t.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, _J = (e) => {
  const {
    theme: t,
    classGroups: n
  } = e, i = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  for (const r in n)
    av(n[r], i, r, t);
  return i;
}, av = (e, t, n, i) => {
  e.forEach((r) => {
    if (typeof r == "string") {
      const s = r === "" ? t : qk(t, r);
      s.classGroupId = n;
      return;
    }
    if (typeof r == "function") {
      if (SJ(r)) {
        av(r(i), t, n, i);
        return;
      }
      t.validators.push({
        validator: r,
        classGroupId: n
      });
      return;
    }
    Object.entries(r).forEach(([s, l]) => {
      av(l, qk(t, s), n, i);
    });
  });
}, qk = (e, t) => {
  let n = e;
  return t.split(cx).forEach((i) => {
    n.nextPart.has(i) || n.nextPart.set(i, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(i);
  }), n;
}, SJ = (e) => e.isThemeGetter, kJ = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  const r = (s, l) => {
    n.set(s, l), t++, t > e && (t = 0, i = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(s) {
      let l = n.get(s);
      if (l !== void 0)
        return l;
      if ((l = i.get(s)) !== void 0)
        return r(s, l), l;
    },
    set(s, l) {
      n.has(s) ? n.set(s, l) : r(s, l);
    }
  };
}, sv = "!", ov = ":", TJ = ov.length, EJ = (e) => {
  const {
    prefix: t,
    experimentalParseClassName: n
  } = e;
  let i = (r) => {
    const s = [];
    let l = 0, c = 0, f = 0, h;
    for (let x = 0; x < r.length; x++) {
      let w = r[x];
      if (l === 0 && c === 0) {
        if (w === ov) {
          s.push(r.slice(f, x)), f = x + TJ;
          continue;
        }
        if (w === "/") {
          h = x;
          continue;
        }
      }
      w === "[" ? l++ : w === "]" ? l-- : w === "(" ? c++ : w === ")" && c--;
    }
    const p = s.length === 0 ? r : r.substring(f), m = $J(p), y = m !== p, b = h && h > f ? h - f : void 0;
    return {
      modifiers: s,
      hasImportantModifier: y,
      baseClassName: m,
      maybePostfixModifierPosition: b
    };
  };
  if (t) {
    const r = t + ov, s = i;
    i = (l) => l.startsWith(r) ? s(l.substring(r.length)) : {
      isExternal: !0,
      modifiers: [],
      hasImportantModifier: !1,
      baseClassName: l,
      maybePostfixModifierPosition: void 0
    };
  }
  if (n) {
    const r = i;
    i = (s) => n({
      className: s,
      parseClassName: r
    });
  }
  return i;
}, $J = (e) => e.endsWith(sv) ? e.substring(0, e.length - 1) : e.startsWith(sv) ? e.substring(1) : e, AJ = (e) => {
  const t = Object.fromEntries(e.orderSensitiveModifiers.map((i) => [i, !0]));
  return (i) => {
    if (i.length <= 1)
      return i;
    const r = [];
    let s = [];
    return i.forEach((l) => {
      l[0] === "[" || t[l] ? (r.push(...s.sort(), l), s = []) : s.push(l);
    }), r.push(...s.sort()), r;
  };
}, zJ = (e) => ({
  cache: kJ(e.cacheSize),
  parseClassName: EJ(e),
  sortModifiers: AJ(e),
  ...xJ(e)
}), IJ = /\s+/, CJ = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: i,
    getConflictingClassGroupIds: r,
    sortModifiers: s
  } = t, l = [], c = e.trim().split(IJ);
  let f = "";
  for (let h = c.length - 1; h >= 0; h -= 1) {
    const p = c[h], {
      isExternal: m,
      modifiers: y,
      hasImportantModifier: b,
      baseClassName: x,
      maybePostfixModifierPosition: w
    } = n(p);
    if (m) {
      f = p + (f.length > 0 ? " " + f : f);
      continue;
    }
    let k = !!w, T = i(k ? x.substring(0, w) : x);
    if (!T) {
      if (!k) {
        f = p + (f.length > 0 ? " " + f : f);
        continue;
      }
      if (T = i(x), !T) {
        f = p + (f.length > 0 ? " " + f : f);
        continue;
      }
      k = !1;
    }
    const A = s(y).join(":"), z = b ? A + sv : A, O = z + T;
    if (l.includes(O))
      continue;
    l.push(O);
    const M = r(T, k);
    for (let N = 0; N < M.length; ++N) {
      const U = M[N];
      l.push(z + U);
    }
    f = p + (f.length > 0 ? " " + f : f);
  }
  return f;
};
function OJ() {
  let e = 0, t, n, i = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (n = LN(t)) && (i && (i += " "), i += n);
  return i;
}
const LN = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let i = 0; i < e.length; i++)
    e[i] && (t = LN(e[i])) && (n && (n += " "), n += t);
  return n;
};
function RJ(e, ...t) {
  let n, i, r, s = l;
  function l(f) {
    const h = t.reduce((p, m) => m(p), e());
    return n = zJ(h), i = n.cache.get, r = n.cache.set, s = c, c(f);
  }
  function c(f) {
    const h = i(f);
    if (h)
      return h;
    const p = CJ(f, n);
    return r(f, p), p;
  }
  return function() {
    return s(OJ.apply(null, arguments));
  };
}
const Lt = (e) => {
  const t = (n) => n[e] || [];
  return t.isThemeGetter = !0, t;
}, BN = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, ZN = /^\((?:(\w[\w-]*):)?(.+)\)$/i, NJ = /^\d+\/\d+$/, MJ = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, DJ = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, jJ = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, PJ = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, UJ = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Fs = (e) => NJ.test(e), Le = (e) => !!e && !Number.isNaN(Number(e)), Yi = (e) => !!e && Number.isInteger(Number(e)), Ym = (e) => e.endsWith("%") && Le(e.slice(0, -1)), pi = (e) => MJ.test(e), LJ = () => !0, BJ = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  DJ.test(e) && !jJ.test(e)
), VN = () => !1, ZJ = (e) => PJ.test(e), VJ = (e) => UJ.test(e), FJ = (e) => !ye(e) && !be(e), HJ = (e) => To(e, qN, VN), ye = (e) => BN.test(e), Ra = (e) => To(e, GN, BJ), Jm = (e) => To(e, XJ, Le), Gk = (e) => To(e, FN, VN), qJ = (e) => To(e, HN, VJ), Td = (e) => To(e, YN, ZJ), be = (e) => ZN.test(e), Rl = (e) => Eo(e, GN), GJ = (e) => Eo(e, KJ), Yk = (e) => Eo(e, FN), YJ = (e) => Eo(e, qN), JJ = (e) => Eo(e, HN), Ed = (e) => Eo(e, YN, !0), To = (e, t, n) => {
  const i = BN.exec(e);
  return i ? i[1] ? t(i[1]) : n(i[2]) : !1;
}, Eo = (e, t, n = !1) => {
  const i = ZN.exec(e);
  return i ? i[1] ? t(i[1]) : n : !1;
}, FN = (e) => e === "position" || e === "percentage", HN = (e) => e === "image" || e === "url", qN = (e) => e === "length" || e === "size" || e === "bg-size", GN = (e) => e === "length", XJ = (e) => e === "number", KJ = (e) => e === "family-name", YN = (e) => e === "shadow", WJ = () => {
  const e = Lt("color"), t = Lt("font"), n = Lt("text"), i = Lt("font-weight"), r = Lt("tracking"), s = Lt("leading"), l = Lt("breakpoint"), c = Lt("container"), f = Lt("spacing"), h = Lt("radius"), p = Lt("shadow"), m = Lt("inset-shadow"), y = Lt("text-shadow"), b = Lt("drop-shadow"), x = Lt("blur"), w = Lt("perspective"), k = Lt("aspect"), T = Lt("ease"), A = Lt("animate"), z = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], O = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], M = () => [...O(), be, ye], N = () => ["auto", "hidden", "clip", "visible", "scroll"], U = () => ["auto", "contain", "none"], Z = () => [be, ye, f], re = () => [Fs, "full", "auto", ...Z()], D = () => [Yi, "none", "subgrid", be, ye], ae = () => ["auto", {
    span: ["full", Yi, be, ye]
  }, Yi, be, ye], ie = () => [Yi, "auto", be, ye], le = () => ["auto", "min", "max", "fr", be, ye], se = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], ce = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], L = () => ["auto", ...Z()], Y = () => [Fs, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...Z()], H = () => [e, be, ye], ge = () => [...O(), Yk, Gk, {
    position: [be, ye]
  }], S = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], X = () => ["auto", "cover", "contain", YJ, HJ, {
    size: [be, ye]
  }], fe = () => [Ym, Rl, Ra], I = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    h,
    be,
    ye
  ], he = () => ["", Le, Rl, Ra], Ie = () => ["solid", "dashed", "dotted", "double"], pe = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], Ce = () => [Le, Ym, Yk, Gk], Pe = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    x,
    be,
    ye
  ], kt = () => ["none", Le, be, ye], Kt = () => ["none", Le, be, ye], un = () => [Le, be, ye], Jn = () => [Fs, "full", ...Z()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [pi],
      breakpoint: [pi],
      color: [LJ],
      container: [pi],
      "drop-shadow": [pi],
      ease: ["in", "out", "in-out"],
      font: [FJ],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [pi],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [pi],
      shadow: [pi],
      spacing: ["px", Le],
      text: [pi],
      "text-shadow": [pi],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", Fs, ye, be, k]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Le, ye, be, c]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": z()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": z()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: M()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: N()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": N()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": N()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: U()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": U()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": U()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: re()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": re()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": re()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: re()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: re()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: re()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: re()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: re()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: re()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [Yi, "auto", be, ye]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [Fs, "full", "auto", c, ...Z()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [Le, Fs, "auto", "initial", "none", ye]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", Le, be, ye]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", Le, be, ye]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [Yi, "first", "last", "none", be, ye]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": D()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ae()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": ie()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": ie()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": D()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ae()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": ie()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": ie()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": le()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": le()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: Z()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": Z()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": Z()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...se(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...ce(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...ce()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...se()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...ce(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...ce(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": se()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...ce(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...ce()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: Z()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: Z()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: Z()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: Z()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: Z()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: Z()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: Z()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: Z()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: Z()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: L()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: L()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: L()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: L()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: L()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: L()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: L()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: L()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: L()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": Z()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": Z()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: Y()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [c, "screen", ...Y()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          c,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...Y()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          c,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [l]
          },
          ...Y()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...Y()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...Y()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...Y()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", n, Rl, Ra]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [i, be, Jm]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", Ym, ye]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [GJ, ye, t]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [r, be, ye]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [Le, "none", be, Jm]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          s,
          ...Z()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", be, ye]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", be, ye]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: H()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: H()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...Ie(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [Le, "from-font", "auto", be, Ra]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: H()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [Le, "auto", be, ye]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: Z()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", be, ye]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", be, ye]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: ge()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: S()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: X()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, Yi, be, ye],
          radial: ["", be, ye],
          conic: [Yi, be, ye]
        }, JJ, qJ]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: H()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: fe()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: fe()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: fe()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: H()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: H()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: H()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: I()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": I()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": I()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": I()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": I()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": I()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": I()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": I()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": I()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": I()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": I()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": I()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": I()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": I()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": I()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: he()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": he()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": he()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": he()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": he()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": he()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": he()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": he()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": he()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": he()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": he()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...Ie(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...Ie(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: H()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": H()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": H()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": H()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": H()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": H()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": H()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": H()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": H()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: H()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...Ie(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Le, be, ye]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", Le, Rl, Ra]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: H()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          p,
          Ed,
          Td
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: H()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", m, Ed, Td]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": H()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: he()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: H()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [Le, Ra]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": H()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": he()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": H()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", y, Ed, Td]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": H()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [Le, be, ye]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...pe(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": pe()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [Le]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": Ce()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": Ce()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": H()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": H()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": Ce()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": Ce()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": H()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": H()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": Ce()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": Ce()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": H()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": H()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": Ce()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": Ce()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": H()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": H()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": Ce()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": Ce()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": H()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": H()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": Ce()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": Ce()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": H()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": H()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": Ce()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": Ce()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": H()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": H()
      }],
      "mask-image-radial": [{
        "mask-radial": [be, ye]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": Ce()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": Ce()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": H()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": H()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": O()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [Le]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": Ce()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": Ce()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": H()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": H()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: ge()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: S()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: X()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", be, ye]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          be,
          ye
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: Pe()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [Le, be, ye]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [Le, be, ye]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          b,
          Ed,
          Td
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": H()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", Le, be, ye]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [Le, be, ye]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", Le, be, ye]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [Le, be, ye]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", Le, be, ye]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          be,
          ye
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": Pe()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [Le, be, ye]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [Le, be, ye]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", Le, be, ye]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [Le, be, ye]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", Le, be, ye]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [Le, be, ye]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [Le, be, ye]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", Le, be, ye]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": Z()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": Z()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": Z()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", be, ye]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [Le, "initial", be, ye]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", T, be, ye]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [Le, be, ye]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", A, be, ye]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [w, be, ye]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": M()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: kt()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": kt()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": kt()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": kt()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: Kt()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": Kt()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": Kt()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": Kt()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: un()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": un()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": un()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [be, ye, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: M()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: Jn()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": Jn()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": Jn()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": Jn()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: H()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: H()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", be, ye]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": Z()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": Z()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": Z()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": Z()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": Z()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": Z()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": Z()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": Z()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": Z()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": Z()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": Z()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": Z()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": Z()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": Z()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": Z()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": Z()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": Z()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": Z()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", be, ye]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...H()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Le, Rl, Ra, Jm]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...H()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, QJ = /* @__PURE__ */ RJ(WJ);
function wt(...e) {
  return QJ(PN(e));
}
function eX({
  delayDuration: e = 0,
  ...t
}) {
  return /* @__PURE__ */ C.jsx(
    pJ,
    {
      "data-slot": "tooltip-provider",
      delayDuration: e,
      ...t
    }
  );
}
function tX({
  ...e
}) {
  return /* @__PURE__ */ C.jsx(eX, { children: /* @__PURE__ */ C.jsx(mJ, { "data-slot": "tooltip", ...e }) });
}
function nX({
  ...e
}) {
  return /* @__PURE__ */ C.jsx(gJ, { "data-slot": "tooltip-trigger", ...e });
}
function rX({
  className: e,
  sideOffset: t = 0,
  children: n,
  ...i
}) {
  return /* @__PURE__ */ C.jsx(vJ, { children: /* @__PURE__ */ C.jsxs(
    yJ,
    {
      "data-slot": "tooltip-content",
      sideOffset: t,
      className: wt(
        "assistant:bg-primary assistant:text-primary-foreground assistant:animate-in assistant:fade-in-0 assistant:zoom-in-95 assistant:data-[state=closed]:animate-out assistant:data-[state=closed]:fade-out-0 assistant:data-[state=closed]:zoom-out-95 assistant:data-[side=bottom]:slide-in-from-top-2 assistant:data-[side=left]:slide-in-from-right-2 assistant:data-[side=right]:slide-in-from-left-2 assistant:data-[side=top]:slide-in-from-bottom-2 assistant:z-50 assistant:w-fit assistant:origin-(--radix-tooltip-content-transform-origin) assistant:rounded-md assistant:px-3 assistant:py-1.5 assistant:text-xs assistant:text-balance",
        e
      ),
      ...i,
      children: [
        n,
        /* @__PURE__ */ C.jsx(bJ, { className: "assistant:bg-primary assistant:fill-primary assistant:z-50 assistant:size-2.5 assistant:translate-y-[calc(-50%_-_2px)] assistant:rotate-45 assistant:rounded-[2px]" })
      ]
    }
  ) });
}
const Jk = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, Xk = PN, iX = (e, t) => (n) => {
  var i;
  if (t?.variants == null) return Xk(e, n?.class, n?.className);
  const { variants: r, defaultVariants: s } = t, l = Object.keys(r).map((h) => {
    const p = n?.[h], m = s?.[h];
    if (p === null) return null;
    const y = Jk(p) || Jk(m);
    return r[h][y];
  }), c = n && Object.entries(n).reduce((h, p) => {
    let [m, y] = p;
    return y === void 0 || (h[m] = y), h;
  }, {}), f = t == null || (i = t.compoundVariants) === null || i === void 0 ? void 0 : i.reduce((h, p) => {
    let { class: m, className: y, ...b } = p;
    return Object.entries(b).every((x) => {
      let [w, k] = x;
      return Array.isArray(k) ? k.includes({
        ...s,
        ...c
      }[w]) : {
        ...s,
        ...c
      }[w] === k;
    }) ? [
      ...h,
      m,
      y
    ] : h;
  }, []);
  return Xk(e, l, f, n?.class, n?.className);
}, aX = iX(
  "assistant:inline-flex assistant:items-center assistant:justify-center assistant:gap-2 assistant:whitespace-nowrap assistant:rounded-md assistant:text-sm assistant:font-medium assistant:transition-all assistant:disabled:pointer-events-none assistant:disabled:opacity-50 assistant:[&_svg]:pointer-events-none assistant:[&_svg:not([class*=size-])]:size-4 assistant:shrink-0 assistant:[&_svg]:shrink-0 assistant:outline-none assistant:focus-visible:border-ring assistant:focus-visible:ring-ring/50 assistant:focus-visible:ring-[3px] assistant:aria-invalid:ring-destructive/20 assistant:dark:aria-invalid:ring-destructive/40 assistant:aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "assistant:bg-primary assistant:text-primary-foreground assistant:shadow-xs assistant:hover:bg-primary/90",
        destructive: "assistant:bg-destructive assistant:text-white assistant:shadow-xs assistant:hover:bg-destructive/90 assistant:focus-visible:ring-destructive/20 assistant:dark:focus-visible:ring-destructive/40 assistant:dark:bg-destructive/60",
        outline: "assistant:border assistant:bg-background assistant:shadow-xs assistant:hover:bg-accent assistant:hover:text-accent-foreground assistant:dark:bg-input/30 assistant:dark:border-input assistant:dark:hover:bg-input/50",
        secondary: "assistant:bg-secondary assistant:text-secondary-foreground assistant:shadow-xs assistant:hover:bg-secondary/80",
        ghost: "assistant:hover:bg-accent assistant:hover:text-accent-foreground assistant:dark:hover:bg-accent/50",
        link: "assistant:text-primary assistant:underline-offset-4 assistant:hover:underline"
      },
      size: {
        default: "assistant:h-9 assistant:px-4 assistant:py-2 assistant:has-[>svg]:px-3",
        sm: "assistant:h-8 assistant:rounded-md assistant:gap-1.5 assistant:px-3 assistant:has-[>svg]:px-2.5",
        lg: "assistant:h-10 assistant:rounded-md assistant:px-6 assistant:has-[>svg]:px-4",
        icon: "assistant:size-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
function Xa({
  className: e,
  variant: t,
  size: n,
  asChild: i = !1,
  ...r
}) {
  const s = i ? q$ : "button";
  return /* @__PURE__ */ C.jsx(
    s,
    {
      "data-slot": "button",
      className: wt(aX({ variant: t, size: n, className: e })),
      ...r
    }
  );
}
const bi = $.forwardRef(({ children: e, tooltip: t, side: n = "bottom", className: i, ...r }, s) => /* @__PURE__ */ C.jsxs(tX, { children: [
  /* @__PURE__ */ C.jsx(nX, { asChild: !0, children: /* @__PURE__ */ C.jsxs(
    Xa,
    {
      variant: "ghost",
      size: "icon",
      ...r,
      className: wt("assistant:size-6 assistant:p-1", i),
      ref: s,
      children: [
        e,
        /* @__PURE__ */ C.jsx("span", { className: "assistant:sr-only", children: t })
      ]
    }
  ) }),
  /* @__PURE__ */ C.jsx(rX, { side: n, children: t })
] }));
bi.displayName = "TooltipIconButton";
const JN = $.createContext({});
function sX(e) {
  const t = $.useRef(null);
  return t.current === null && (t.current = e()), t.current;
}
const dx = typeof window < "u", oX = dx ? $.useLayoutEffect : $.useEffect, fx = /* @__PURE__ */ $.createContext(null);
function hx(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function px(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
const xi = (e, t, n) => n > t ? t : n < e ? e : n;
let mx = () => {
};
const wi = {}, XN = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
function KN(e) {
  return typeof e == "object" && e !== null;
}
const WN = (e) => /^0[^.\s]+$/u.test(e);
// @__NO_SIDE_EFFECTS__
function gx(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const cr = /* @__NO_SIDE_EFFECTS__ */ (e) => e, lX = (e, t) => (n) => t(e(n)), Zu = (...e) => e.reduce(lX), fu = /* @__NO_SIDE_EFFECTS__ */ (e, t, n) => {
  const i = t - e;
  return i === 0 ? 1 : (n - e) / i;
};
class vx {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return hx(this.subscriptions, t), () => px(this.subscriptions, t);
  }
  notify(t, n, i) {
    const r = this.subscriptions.length;
    if (r)
      if (r === 1)
        this.subscriptions[0](t, n, i);
      else
        for (let s = 0; s < r; s++) {
          const l = this.subscriptions[s];
          l && l(t, n, i);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const Vr = /* @__NO_SIDE_EFFECTS__ */ (e) => e * 1e3, Fr = /* @__NO_SIDE_EFFECTS__ */ (e) => e / 1e3;
function QN(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const eM = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, uX = 1e-7, cX = 12;
function dX(e, t, n, i, r) {
  let s, l, c = 0;
  do
    l = t + (n - t) / 2, s = eM(l, i, r) - e, s > 0 ? n = l : t = l;
  while (Math.abs(s) > uX && ++c < cX);
  return l;
}
function Vu(e, t, n, i) {
  if (e === t && n === i)
    return cr;
  const r = (s) => dX(s, 0, 1, e, n);
  return (s) => s === 0 || s === 1 ? s : eM(r(s), t, i);
}
const tM = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, nM = (e) => (t) => 1 - e(1 - t), rM = /* @__PURE__ */ Vu(0.33, 1.53, 0.69, 0.99), yx = /* @__PURE__ */ nM(rM), iM = /* @__PURE__ */ tM(yx), aM = (e) => (e *= 2) < 1 ? 0.5 * yx(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), bx = (e) => 1 - Math.sin(Math.acos(e)), sM = nM(bx), oM = tM(bx), fX = /* @__PURE__ */ Vu(0.42, 0, 1, 1), hX = /* @__PURE__ */ Vu(0, 0, 0.58, 1), lM = /* @__PURE__ */ Vu(0.42, 0, 0.58, 1), pX = (e) => Array.isArray(e) && typeof e[0] != "number", uM = (e) => Array.isArray(e) && typeof e[0] == "number", mX = {
  linear: cr,
  easeIn: fX,
  easeInOut: lM,
  easeOut: hX,
  circIn: bx,
  circInOut: oM,
  circOut: sM,
  backIn: yx,
  backInOut: iM,
  backOut: rM,
  anticipate: aM
}, gX = (e) => typeof e == "string", Kk = (e) => {
  if (uM(e)) {
    mx(e.length === 4);
    const [t, n, i, r] = e;
    return Vu(t, n, i, r);
  } else if (gX(e))
    return mX[e];
  return e;
}, $d = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function vX(e, t) {
  let n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), r = !1, s = !1;
  const l = /* @__PURE__ */ new WeakSet();
  let c = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function f(p) {
    l.has(p) && (h.schedule(p), e()), p(c);
  }
  const h = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (p, m = !1, y = !1) => {
      const x = y && r ? n : i;
      return m && l.add(p), x.has(p) || x.add(p), p;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (p) => {
      i.delete(p), l.delete(p);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (p) => {
      if (c = p, r) {
        s = !0;
        return;
      }
      r = !0, [n, i] = [i, n], n.forEach(f), n.clear(), r = !1, s && (s = !1, h.process(p));
    }
  };
  return h;
}
const yX = 40;
function cM(e, t) {
  let n = !1, i = !0;
  const r = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, s = () => n = !0, l = $d.reduce((z, O) => (z[O] = vX(s), z), {}), { setup: c, read: f, resolveKeyframes: h, preUpdate: p, update: m, preRender: y, render: b, postRender: x } = l, w = () => {
    const z = wi.useManualTiming ? r.timestamp : performance.now();
    n = !1, wi.useManualTiming || (r.delta = i ? 1e3 / 60 : Math.max(Math.min(z - r.timestamp, yX), 1)), r.timestamp = z, r.isProcessing = !0, c.process(r), f.process(r), h.process(r), p.process(r), m.process(r), y.process(r), b.process(r), x.process(r), r.isProcessing = !1, n && t && (i = !1, e(w));
  }, k = () => {
    n = !0, i = !0, r.isProcessing || e(w);
  };
  return { schedule: $d.reduce((z, O) => {
    const M = l[O];
    return z[O] = (N, U = !1, Z = !1) => (n || k(), M.schedule(N, U, Z)), z;
  }, {}), cancel: (z) => {
    for (let O = 0; O < $d.length; O++)
      l[$d[O]].cancel(z);
  }, state: r, steps: l };
}
const { schedule: vt, cancel: sa, state: tn, steps: Xm } = /* @__PURE__ */ cM(typeof requestAnimationFrame < "u" ? requestAnimationFrame : cr, !0);
let Bd;
function bX() {
  Bd = void 0;
}
const En = {
  now: () => (Bd === void 0 && En.set(tn.isProcessing || wi.useManualTiming ? tn.timestamp : performance.now()), Bd),
  set: (e) => {
    Bd = e, queueMicrotask(bX);
  }
}, dM = (e) => (t) => typeof t == "string" && t.startsWith(e), xx = /* @__PURE__ */ dM("--"), xX = /* @__PURE__ */ dM("var(--"), wx = (e) => xX(e) ? wX.test(e.split("/*")[0].trim()) : !1, wX = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, $o = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, hu = {
  ...$o,
  transform: (e) => xi(0, 1, e)
}, Ad = {
  ...$o,
  default: 1
}, ql = (e) => Math.round(e * 1e5) / 1e5, _x = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function _X(e) {
  return e == null;
}
const SX = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Sx = (e, t) => (n) => !!(typeof n == "string" && SX.test(n) && n.startsWith(e) || t && !_X(n) && Object.prototype.hasOwnProperty.call(n, t)), fM = (e, t, n) => (i) => {
  if (typeof i != "string")
    return i;
  const [r, s, l, c] = i.match(_x);
  return {
    [e]: parseFloat(r),
    [t]: parseFloat(s),
    [n]: parseFloat(l),
    alpha: c !== void 0 ? parseFloat(c) : 1
  };
}, kX = (e) => xi(0, 255, e), Km = {
  ...$o,
  transform: (e) => Math.round(kX(e))
}, La = {
  test: /* @__PURE__ */ Sx("rgb", "red"),
  parse: /* @__PURE__ */ fM("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: i = 1 }) => "rgba(" + Km.transform(e) + ", " + Km.transform(t) + ", " + Km.transform(n) + ", " + ql(hu.transform(i)) + ")"
};
function TX(e) {
  let t = "", n = "", i = "", r = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), i = e.substring(5, 7), r = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), i = e.substring(3, 4), r = e.substring(4, 5), t += t, n += n, i += i, r += r), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(i, 16),
    alpha: r ? parseInt(r, 16) / 255 : 1
  };
}
const lv = {
  test: /* @__PURE__ */ Sx("#"),
  parse: TX,
  transform: La.transform
}, Fu = /* @__NO_SIDE_EFFECTS__ */ (e) => ({
  test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), Ki = /* @__PURE__ */ Fu("deg"), Hr = /* @__PURE__ */ Fu("%"), ze = /* @__PURE__ */ Fu("px"), EX = /* @__PURE__ */ Fu("vh"), $X = /* @__PURE__ */ Fu("vw"), Wk = {
  ...Hr,
  parse: (e) => Hr.parse(e) / 100,
  transform: (e) => Hr.transform(e * 100)
}, Ws = {
  test: /* @__PURE__ */ Sx("hsl", "hue"),
  parse: /* @__PURE__ */ fM("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: i = 1 }) => "hsla(" + Math.round(e) + ", " + Hr.transform(ql(t)) + ", " + Hr.transform(ql(n)) + ", " + ql(hu.transform(i)) + ")"
}, Dt = {
  test: (e) => La.test(e) || lv.test(e) || Ws.test(e),
  parse: (e) => La.test(e) ? La.parse(e) : Ws.test(e) ? Ws.parse(e) : lv.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? La.transform(e) : Ws.transform(e),
  getAnimatableNone: (e) => {
    const t = Dt.parse(e);
    return t.alpha = 0, Dt.transform(t);
  }
}, AX = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function zX(e) {
  return isNaN(e) && typeof e == "string" && (e.match(_x)?.length || 0) + (e.match(AX)?.length || 0) > 0;
}
const hM = "number", pM = "color", IX = "var", CX = "var(", Qk = "${}", OX = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function pu(e) {
  const t = e.toString(), n = [], i = {
    color: [],
    number: [],
    var: []
  }, r = [];
  let s = 0;
  const c = t.replace(OX, (f) => (Dt.test(f) ? (i.color.push(s), r.push(pM), n.push(Dt.parse(f))) : f.startsWith(CX) ? (i.var.push(s), r.push(IX), n.push(f)) : (i.number.push(s), r.push(hM), n.push(parseFloat(f))), ++s, Qk)).split(Qk);
  return { values: n, split: c, indexes: i, types: r };
}
function mM(e) {
  return pu(e).values;
}
function gM(e) {
  const { split: t, types: n } = pu(e), i = t.length;
  return (r) => {
    let s = "";
    for (let l = 0; l < i; l++)
      if (s += t[l], r[l] !== void 0) {
        const c = n[l];
        c === hM ? s += ql(r[l]) : c === pM ? s += Dt.transform(r[l]) : s += r[l];
      }
    return s;
  };
}
const RX = (e) => typeof e == "number" ? 0 : Dt.test(e) ? Dt.getAnimatableNone(e) : e;
function NX(e) {
  const t = mM(e);
  return gM(e)(t.map(RX));
}
const oa = {
  test: zX,
  parse: mM,
  createTransformer: gM,
  getAnimatableNone: NX
};
function Wm(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function MX({ hue: e, saturation: t, lightness: n, alpha: i }) {
  e /= 360, t /= 100, n /= 100;
  let r = 0, s = 0, l = 0;
  if (!t)
    r = s = l = n;
  else {
    const c = n < 0.5 ? n * (1 + t) : n + t - n * t, f = 2 * n - c;
    r = Wm(f, c, e + 1 / 3), s = Wm(f, c, e), l = Wm(f, c, e - 1 / 3);
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(s * 255),
    blue: Math.round(l * 255),
    alpha: i
  };
}
function vf(e, t) {
  return (n) => n > 0 ? t : e;
}
const _t = (e, t, n) => e + (t - e) * n, Qm = (e, t, n) => {
  const i = e * e, r = n * (t * t - i) + i;
  return r < 0 ? 0 : Math.sqrt(r);
}, DX = [lv, La, Ws], jX = (e) => DX.find((t) => t.test(e));
function eT(e) {
  const t = jX(e);
  if (!t)
    return !1;
  let n = t.parse(e);
  return t === Ws && (n = MX(n)), n;
}
const tT = (e, t) => {
  const n = eT(e), i = eT(t);
  if (!n || !i)
    return vf(e, t);
  const r = { ...n };
  return (s) => (r.red = Qm(n.red, i.red, s), r.green = Qm(n.green, i.green, s), r.blue = Qm(n.blue, i.blue, s), r.alpha = _t(n.alpha, i.alpha, s), La.transform(r));
}, uv = /* @__PURE__ */ new Set(["none", "hidden"]);
function PX(e, t) {
  return uv.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function UX(e, t) {
  return (n) => _t(e, t, n);
}
function kx(e) {
  return typeof e == "number" ? UX : typeof e == "string" ? wx(e) ? vf : Dt.test(e) ? tT : ZX : Array.isArray(e) ? vM : typeof e == "object" ? Dt.test(e) ? tT : LX : vf;
}
function vM(e, t) {
  const n = [...e], i = n.length, r = e.map((s, l) => kx(s)(s, t[l]));
  return (s) => {
    for (let l = 0; l < i; l++)
      n[l] = r[l](s);
    return n;
  };
}
function LX(e, t) {
  const n = { ...e, ...t }, i = {};
  for (const r in n)
    e[r] !== void 0 && t[r] !== void 0 && (i[r] = kx(e[r])(e[r], t[r]));
  return (r) => {
    for (const s in i)
      n[s] = i[s](r);
    return n;
  };
}
function BX(e, t) {
  const n = [], i = { color: 0, var: 0, number: 0 };
  for (let r = 0; r < t.values.length; r++) {
    const s = t.types[r], l = e.indexes[s][i[s]], c = e.values[l] ?? 0;
    n[r] = c, i[s]++;
  }
  return n;
}
const ZX = (e, t) => {
  const n = oa.createTransformer(t), i = pu(e), r = pu(t);
  return i.indexes.var.length === r.indexes.var.length && i.indexes.color.length === r.indexes.color.length && i.indexes.number.length >= r.indexes.number.length ? uv.has(e) && !r.values.length || uv.has(t) && !i.values.length ? PX(e, t) : Zu(vM(BX(i, r), r.values), n) : vf(e, t);
};
function yM(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? _t(e, t, n) : kx(e)(e, t);
}
const VX = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: (n = !0) => vt.update(t, n),
    stop: () => sa(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => tn.isProcessing ? tn.timestamp : En.now()
  };
}, bM = (e, t, n = 10) => {
  let i = "";
  const r = Math.max(Math.round(t / n), 2);
  for (let s = 0; s < r; s++)
    i += Math.round(e(s / (r - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${i.substring(0, i.length - 2)})`;
}, yf = 2e4;
function Tx(e) {
  let t = 0;
  const n = 50;
  let i = e.next(t);
  for (; !i.done && t < yf; )
    t += n, i = e.next(t);
  return t >= yf ? 1 / 0 : t;
}
function FX(e, t = 100, n) {
  const i = n({ ...e, keyframes: [0, t] }), r = Math.min(Tx(i), yf);
  return {
    type: "keyframes",
    ease: (s) => i.next(r * s).value / t,
    duration: /* @__PURE__ */ Fr(r)
  };
}
const HX = 5;
function xM(e, t, n) {
  const i = Math.max(t - HX, 0);
  return QN(n - e(i), t - i);
}
const $t = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, eg = 1e-3;
function qX({ duration: e = $t.duration, bounce: t = $t.bounce, velocity: n = $t.velocity, mass: i = $t.mass }) {
  let r, s, l = 1 - t;
  l = xi($t.minDamping, $t.maxDamping, l), e = xi($t.minDuration, $t.maxDuration, /* @__PURE__ */ Fr(e)), l < 1 ? (r = (h) => {
    const p = h * l, m = p * e, y = p - n, b = cv(h, l), x = Math.exp(-m);
    return eg - y / b * x;
  }, s = (h) => {
    const m = h * l * e, y = m * n + n, b = Math.pow(l, 2) * Math.pow(h, 2) * e, x = Math.exp(-m), w = cv(Math.pow(h, 2), l);
    return (-r(h) + eg > 0 ? -1 : 1) * ((y - b) * x) / w;
  }) : (r = (h) => {
    const p = Math.exp(-h * e), m = (h - n) * e + 1;
    return -eg + p * m;
  }, s = (h) => {
    const p = Math.exp(-h * e), m = (n - h) * (e * e);
    return p * m;
  });
  const c = 5 / e, f = YX(r, s, c);
  if (e = /* @__PURE__ */ Vr(e), isNaN(f))
    return {
      stiffness: $t.stiffness,
      damping: $t.damping,
      duration: e
    };
  {
    const h = Math.pow(f, 2) * i;
    return {
      stiffness: h,
      damping: l * 2 * Math.sqrt(i * h),
      duration: e
    };
  }
}
const GX = 12;
function YX(e, t, n) {
  let i = n;
  for (let r = 1; r < GX; r++)
    i = i - e(i) / t(i);
  return i;
}
function cv(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const JX = ["duration", "bounce"], XX = ["stiffness", "damping", "mass"];
function nT(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function KX(e) {
  let t = {
    velocity: $t.velocity,
    stiffness: $t.stiffness,
    damping: $t.damping,
    mass: $t.mass,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!nT(e, XX) && nT(e, JX))
    if (e.visualDuration) {
      const n = e.visualDuration, i = 2 * Math.PI / (n * 1.2), r = i * i, s = 2 * xi(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(r);
      t = {
        ...t,
        mass: $t.mass,
        stiffness: r,
        damping: s
      };
    } else {
      const n = qX(e);
      t = {
        ...t,
        ...n,
        mass: $t.mass
      }, t.isResolvedFromDuration = !0;
    }
  return t;
}
function bf(e = $t.visualDuration, t = $t.bounce) {
  const n = typeof e != "object" ? {
    visualDuration: e,
    keyframes: [0, 1],
    bounce: t
  } : e;
  let { restSpeed: i, restDelta: r } = n;
  const s = n.keyframes[0], l = n.keyframes[n.keyframes.length - 1], c = { done: !1, value: s }, { stiffness: f, damping: h, mass: p, duration: m, velocity: y, isResolvedFromDuration: b } = KX({
    ...n,
    velocity: -/* @__PURE__ */ Fr(n.velocity || 0)
  }), x = y || 0, w = h / (2 * Math.sqrt(f * p)), k = l - s, T = /* @__PURE__ */ Fr(Math.sqrt(f / p)), A = Math.abs(k) < 5;
  i || (i = A ? $t.restSpeed.granular : $t.restSpeed.default), r || (r = A ? $t.restDelta.granular : $t.restDelta.default);
  let z;
  if (w < 1) {
    const M = cv(T, w);
    z = (N) => {
      const U = Math.exp(-w * T * N);
      return l - U * ((x + w * T * k) / M * Math.sin(M * N) + k * Math.cos(M * N));
    };
  } else if (w === 1)
    z = (M) => l - Math.exp(-T * M) * (k + (x + T * k) * M);
  else {
    const M = T * Math.sqrt(w * w - 1);
    z = (N) => {
      const U = Math.exp(-w * T * N), Z = Math.min(M * N, 300);
      return l - U * ((x + w * T * k) * Math.sinh(Z) + M * k * Math.cosh(Z)) / M;
    };
  }
  const O = {
    calculatedDuration: b && m || null,
    next: (M) => {
      const N = z(M);
      if (b)
        c.done = M >= m;
      else {
        let U = M === 0 ? x : 0;
        w < 1 && (U = M === 0 ? /* @__PURE__ */ Vr(x) : xM(z, M, N));
        const Z = Math.abs(U) <= i, re = Math.abs(l - N) <= r;
        c.done = Z && re;
      }
      return c.value = c.done ? l : N, c;
    },
    toString: () => {
      const M = Math.min(Tx(O), yf), N = bM((U) => O.next(M * U).value, M, 30);
      return M + "ms " + N;
    },
    toTransition: () => {
    }
  };
  return O;
}
bf.applyToOptions = (e) => {
  const t = FX(e, 100, bf);
  return e.ease = t.ease, e.duration = /* @__PURE__ */ Vr(t.duration), e.type = "keyframes", e;
};
function dv({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: i = 325, bounceDamping: r = 10, bounceStiffness: s = 500, modifyTarget: l, min: c, max: f, restDelta: h = 0.5, restSpeed: p }) {
  const m = e[0], y = {
    done: !1,
    value: m
  }, b = (Z) => c !== void 0 && Z < c || f !== void 0 && Z > f, x = (Z) => c === void 0 ? f : f === void 0 || Math.abs(c - Z) < Math.abs(f - Z) ? c : f;
  let w = n * t;
  const k = m + w, T = l === void 0 ? k : l(k);
  T !== k && (w = T - m);
  const A = (Z) => -w * Math.exp(-Z / i), z = (Z) => T + A(Z), O = (Z) => {
    const re = A(Z), D = z(Z);
    y.done = Math.abs(re) <= h, y.value = y.done ? T : D;
  };
  let M, N;
  const U = (Z) => {
    b(y.value) && (M = Z, N = bf({
      keyframes: [y.value, x(y.value)],
      velocity: xM(z, Z, y.value),
      // TODO: This should be passing * 1000
      damping: r,
      stiffness: s,
      restDelta: h,
      restSpeed: p
    }));
  };
  return U(0), {
    calculatedDuration: null,
    next: (Z) => {
      let re = !1;
      return !N && M === void 0 && (re = !0, O(Z), U(Z)), M !== void 0 && Z >= M ? N.next(Z - M) : (!re && O(Z), y);
    }
  };
}
function WX(e, t, n) {
  const i = [], r = n || wi.mix || yM, s = e.length - 1;
  for (let l = 0; l < s; l++) {
    let c = r(e[l], e[l + 1]);
    if (t) {
      const f = Array.isArray(t) ? t[l] || cr : t;
      c = Zu(f, c);
    }
    i.push(c);
  }
  return i;
}
function QX(e, t, { clamp: n = !0, ease: i, mixer: r } = {}) {
  const s = e.length;
  if (mx(s === t.length), s === 1)
    return () => t[0];
  if (s === 2 && t[0] === t[1])
    return () => t[1];
  const l = e[0] === e[1];
  e[0] > e[s - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const c = WX(t, i, r), f = c.length, h = (p) => {
    if (l && p < e[0])
      return t[0];
    let m = 0;
    if (f > 1)
      for (; m < e.length - 2 && !(p < e[m + 1]); m++)
        ;
    const y = /* @__PURE__ */ fu(e[m], e[m + 1], p);
    return c[m](y);
  };
  return n ? (p) => h(xi(e[0], e[s - 1], p)) : h;
}
function eK(e, t) {
  const n = e[e.length - 1];
  for (let i = 1; i <= t; i++) {
    const r = /* @__PURE__ */ fu(0, t, i);
    e.push(_t(n, 1, r));
  }
}
function tK(e) {
  const t = [0];
  return eK(t, e.length - 1), t;
}
function nK(e, t) {
  return e.map((n) => n * t);
}
function rK(e, t) {
  return e.map(() => t || lM).splice(0, e.length - 1);
}
function Gl({ duration: e = 300, keyframes: t, times: n, ease: i = "easeInOut" }) {
  const r = pX(i) ? i.map(Kk) : Kk(i), s = {
    done: !1,
    value: t[0]
  }, l = nK(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : tK(t),
    e
  ), c = QX(l, t, {
    ease: Array.isArray(r) ? r : rK(t, r)
  });
  return {
    calculatedDuration: e,
    next: (f) => (s.value = c(f), s.done = f >= e, s)
  };
}
const iK = (e) => e !== null;
function Ex(e, { repeat: t, repeatType: n = "loop" }, i, r = 1) {
  const s = e.filter(iK), c = r < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : s.length - 1;
  return !c || i === void 0 ? s[c] : i;
}
const aK = {
  decay: dv,
  inertia: dv,
  tween: Gl,
  keyframes: Gl,
  spring: bf
};
function wM(e) {
  typeof e.type == "string" && (e.type = aK[e.type]);
}
class $x {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
}
const sK = (e) => e / 100;
class Ax extends $x {
  constructor(t) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      const { motionValue: n } = this.options;
      n && n.updatedAt !== En.now() && this.tick(En.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.());
    }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    wM(t);
    const { type: n = Gl, repeat: i = 0, repeatDelay: r = 0, repeatType: s, velocity: l = 0 } = t;
    let { keyframes: c } = t;
    const f = n || Gl;
    f !== Gl && typeof c[0] != "number" && (this.mixKeyframes = Zu(sK, yM(c[0], c[1])), c = [0, 100]);
    const h = f({ ...t, keyframes: c });
    s === "mirror" && (this.mirroredGenerator = f({
      ...t,
      keyframes: [...c].reverse(),
      velocity: -l
    })), h.calculatedDuration === null && (h.calculatedDuration = Tx(h));
    const { calculatedDuration: p } = h;
    this.calculatedDuration = p, this.resolvedDuration = p + r, this.totalDuration = this.resolvedDuration * (i + 1) - r, this.generator = h;
  }
  updateTime(t) {
    const n = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;
  }
  tick(t, n = !1) {
    const { generator: i, totalDuration: r, mixKeyframes: s, mirroredGenerator: l, resolvedDuration: c, calculatedDuration: f } = this;
    if (this.startTime === null)
      return i.next(0);
    const { delay: h = 0, keyframes: p, repeat: m, repeatType: y, repeatDelay: b, type: x, onUpdate: w, finalKeyframe: k } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - r / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
    const T = this.currentTime - h * (this.playbackSpeed >= 0 ? 1 : -1), A = this.playbackSpeed >= 0 ? T < 0 : T > r;
    this.currentTime = Math.max(T, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = r);
    let z = this.currentTime, O = i;
    if (m) {
      const Z = Math.min(this.currentTime, r) / c;
      let re = Math.floor(Z), D = Z % 1;
      !D && Z >= 1 && (D = 1), D === 1 && re--, re = Math.min(re, m + 1), !!(re % 2) && (y === "reverse" ? (D = 1 - D, b && (D -= b / c)) : y === "mirror" && (O = l)), z = xi(0, 1, D) * c;
    }
    const M = A ? { done: !1, value: p[0] } : O.next(z);
    s && (M.value = s(M.value));
    let { done: N } = M;
    !A && f !== null && (N = this.playbackSpeed >= 0 ? this.currentTime >= r : this.currentTime <= 0);
    const U = this.holdTime === null && (this.state === "finished" || this.state === "running" && N);
    return U && x !== dv && (M.value = Ex(p, this.options, k, this.speed)), w && w(M.value), U && this.finish(), M;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
  get duration() {
    return /* @__PURE__ */ Fr(this.calculatedDuration);
  }
  get time() {
    return /* @__PURE__ */ Fr(this.currentTime);
  }
  set time(t) {
    t = /* @__PURE__ */ Vr(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), this.driver?.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(En.now());
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = /* @__PURE__ */ Fr(this.currentTime));
  }
  play() {
    if (this.isStopped)
      return;
    const { driver: t = VX, startTime: n } = this.options;
    this.driver || (this.driver = t((r) => this.tick(r))), this.options.onPlay?.();
    const i = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = i) : this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime || (this.startTime = n ?? i), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(En.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.();
  }
  cancel() {
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
  attachTimeline(t) {
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), t.observe(this);
  }
}
function oK(e) {
  for (let t = 1; t < e.length; t++)
    e[t] ?? (e[t] = e[t - 1]);
}
const Ba = (e) => e * 180 / Math.PI, fv = (e) => {
  const t = Ba(Math.atan2(e[1], e[0]));
  return hv(t);
}, lK = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
  rotate: fv,
  rotateZ: fv,
  skewX: (e) => Ba(Math.atan(e[1])),
  skewY: (e) => Ba(Math.atan(e[2])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2
}, hv = (e) => (e = e % 360, e < 0 && (e += 360), e), rT = fv, iT = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]), aT = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]), uK = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX: iT,
  scaleY: aT,
  scale: (e) => (iT(e) + aT(e)) / 2,
  rotateX: (e) => hv(Ba(Math.atan2(e[6], e[5]))),
  rotateY: (e) => hv(Ba(Math.atan2(-e[2], e[0]))),
  rotateZ: rT,
  rotate: rT,
  skewX: (e) => Ba(Math.atan(e[4])),
  skewY: (e) => Ba(Math.atan(e[1])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2
};
function pv(e) {
  return e.includes("scale") ? 1 : 0;
}
function mv(e, t) {
  if (!e || e === "none")
    return pv(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let i, r;
  if (n)
    i = uK, r = n;
  else {
    const c = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    i = lK, r = c;
  }
  if (!r)
    return pv(t);
  const s = i[t], l = r[1].split(",").map(dK);
  return typeof s == "function" ? s(l) : l[s];
}
const cK = (e, t) => {
  const { transform: n = "none" } = getComputedStyle(e);
  return mv(n, t);
};
function dK(e) {
  return parseFloat(e.trim());
}
const Ao = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], zo = new Set(Ao), sT = (e) => e === $o || e === ze, fK = /* @__PURE__ */ new Set(["x", "y", "z"]), hK = Ao.filter((e) => !fK.has(e));
function pK(e) {
  const t = [];
  return hK.forEach((n) => {
    const i = e.getValue(n);
    i !== void 0 && (t.push([n, i.get()]), i.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const Fa = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: (e, { transform: t }) => mv(t, "x"),
  y: (e, { transform: t }) => mv(t, "y")
};
Fa.translateX = Fa.x;
Fa.translateY = Fa.y;
const Ha = /* @__PURE__ */ new Set();
let gv = !1, vv = !1, yv = !1;
function _M() {
  if (vv) {
    const e = Array.from(Ha).filter((i) => i.needsMeasurement), t = new Set(e.map((i) => i.element)), n = /* @__PURE__ */ new Map();
    t.forEach((i) => {
      const r = pK(i);
      r.length && (n.set(i, r), i.render());
    }), e.forEach((i) => i.measureInitialState()), t.forEach((i) => {
      i.render();
      const r = n.get(i);
      r && r.forEach(([s, l]) => {
        i.getValue(s)?.set(l);
      });
    }), e.forEach((i) => i.measureEndState()), e.forEach((i) => {
      i.suspendedScrollY !== void 0 && window.scrollTo(0, i.suspendedScrollY);
    });
  }
  vv = !1, gv = !1, Ha.forEach((e) => e.complete(yv)), Ha.clear();
}
function SM() {
  Ha.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (vv = !0);
  });
}
function mK() {
  yv = !0, SM(), _M(), yv = !1;
}
class zx {
  constructor(t, n, i, r, s, l = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = i, this.motionValue = r, this.element = s, this.isAsync = l;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (Ha.add(this), gv || (gv = !0, vt.read(SM), vt.resolveKeyframes(_M))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: i, motionValue: r } = this;
    if (t[0] === null) {
      const s = r?.get(), l = t[t.length - 1];
      if (s !== void 0)
        t[0] = s;
      else if (i && n) {
        const c = i.readValue(n, l);
        c != null && (t[0] = c);
      }
      t[0] === void 0 && (t[0] = l), r && s === void 0 && r.set(t[0]);
    }
    oK(t);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(t = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), Ha.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (Ha.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const gK = (e) => e.startsWith("--");
function vK(e, t, n) {
  gK(t) ? e.style.setProperty(t, n) : e.style[t] = n;
}
const yK = /* @__PURE__ */ gx(() => window.ScrollTimeline !== void 0), bK = {};
function xK(e, t) {
  const n = /* @__PURE__ */ gx(e);
  return () => bK[t] ?? n();
}
const kM = /* @__PURE__ */ xK(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), Fl = ([e, t, n, i]) => `cubic-bezier(${e}, ${t}, ${n}, ${i})`, oT = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ Fl([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ Fl([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ Fl([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ Fl([0.33, 1.53, 0.69, 0.99])
};
function TM(e, t) {
  if (e)
    return typeof e == "function" ? kM() ? bM(e, t) : "ease-out" : uM(e) ? Fl(e) : Array.isArray(e) ? e.map((n) => TM(n, t) || oT.easeOut) : oT[e];
}
function wK(e, t, n, { delay: i = 0, duration: r = 300, repeat: s = 0, repeatType: l = "loop", ease: c = "easeOut", times: f } = {}, h = void 0) {
  const p = {
    [t]: n
  };
  f && (p.offset = f);
  const m = TM(c, r);
  Array.isArray(m) && (p.easing = m);
  const y = {
    delay: i,
    duration: r,
    easing: Array.isArray(m) ? "linear" : m,
    fill: "both",
    iterations: s + 1,
    direction: l === "reverse" ? "alternate" : "normal"
  };
  return h && (y.pseudoElement = h), e.animate(p, y);
}
function EM(e) {
  return typeof e == "function" && "applyToOptions" in e;
}
function _K({ type: e, ...t }) {
  return EM(e) && kM() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
class SK extends $x {
  constructor(t) {
    if (super(), this.finishedTime = null, this.isStopped = !1, !t)
      return;
    const { element: n, name: i, keyframes: r, pseudoElement: s, allowFlatten: l = !1, finalKeyframe: c, onComplete: f } = t;
    this.isPseudoElement = !!s, this.allowFlatten = l, this.options = t, mx(typeof t.type != "string");
    const h = _K(t);
    this.animation = wK(n, i, r, h, s), h.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !s) {
        const p = Ex(r, this.options, c, this.speed);
        this.updateMotionValue ? this.updateMotionValue(p) : vK(n, i, p), this.animation.cancel();
      }
      f?.(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    this.isPseudoElement || this.animation.commitStyles?.();
  }
  get duration() {
    const t = this.animation.effect?.getComputedTiming?.().duration || 0;
    return /* @__PURE__ */ Fr(Number(t));
  }
  get time() {
    return /* @__PURE__ */ Fr(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ Vr(t);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    t < 0 && (this.finishedTime = null), this.animation.playbackRate = t;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(t) {
    this.animation.startTime = t;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: t, observe: n }) {
    return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, t && yK() ? (this.animation.timeline = t, cr) : n(this);
  }
}
const $M = {
  anticipate: aM,
  backInOut: iM,
  circInOut: oM
};
function kK(e) {
  return e in $M;
}
function TK(e) {
  typeof e.ease == "string" && kK(e.ease) && (e.ease = $M[e.ease]);
}
const lT = 10;
class EK extends SK {
  constructor(t) {
    TK(t), wM(t), super(t), t.startTime && (this.startTime = t.startTime), this.options = t;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(t) {
    const { motionValue: n, onUpdate: i, onComplete: r, element: s, ...l } = this.options;
    if (!n)
      return;
    if (t !== void 0) {
      n.set(t);
      return;
    }
    const c = new Ax({
      ...l,
      autoplay: !1
    }), f = /* @__PURE__ */ Vr(this.finishedTime ?? this.time);
    n.setWithVelocity(c.sample(f - lT).value, c.sample(f).value, lT), c.stop();
  }
}
const uT = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(oa.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function $K(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function AK(e, t, n, i) {
  const r = e[0];
  if (r === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const s = e[e.length - 1], l = uT(r, t), c = uT(s, t);
  return !l || !c ? !1 : $K(e) || (n === "spring" || EM(n)) && i;
}
function bv(e) {
  e.duration = 0, e.type;
}
const zK = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), IK = /* @__PURE__ */ gx(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function CK(e) {
  const { motionValue: t, name: n, repeatDelay: i, repeatType: r, damping: s, type: l } = e;
  if (!(t?.owner?.current instanceof HTMLElement))
    return !1;
  const { onUpdate: f, transformTemplate: h } = t.owner.getProps();
  return IK() && n && zK.has(n) && (n !== "transform" || !h) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !f && !i && r !== "mirror" && s !== 0 && l !== "inertia";
}
const OK = 40;
class RK extends $x {
  constructor({ autoplay: t = !0, delay: n = 0, type: i = "keyframes", repeat: r = 0, repeatDelay: s = 0, repeatType: l = "loop", keyframes: c, name: f, motionValue: h, element: p, ...m }) {
    super(), this.stop = () => {
      this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel();
    }, this.createdAt = En.now();
    const y = {
      autoplay: t,
      delay: n,
      type: i,
      repeat: r,
      repeatDelay: s,
      repeatType: l,
      name: f,
      motionValue: h,
      element: p,
      ...m
    }, b = p?.KeyframeResolver || zx;
    this.keyframeResolver = new b(c, (x, w, k) => this.onKeyframesResolved(x, w, y, !k), f, h, p), this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(t, n, i, r) {
    this.keyframeResolver = void 0;
    const { name: s, type: l, velocity: c, delay: f, isHandoff: h, onUpdate: p } = i;
    this.resolvedAt = En.now(), AK(t, s, l, c) || ((wi.instantAnimations || !f) && p?.(Ex(t, i, n)), t[0] = t[t.length - 1], bv(i), i.repeat = 0);
    const y = {
      startTime: r ? this.resolvedAt ? this.resolvedAt - this.createdAt > OK ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...i,
      keyframes: t
    }, b = !h && CK(y) ? new EK({
      ...y,
      element: y.motionValue.owner.current
    }) : new Ax(y);
    b.finished.then(() => this.notifyFinished()).catch(cr), this.pendingTimeline && (this.stopTimeline = b.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = b;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
  get animation() {
    return this._animation || (this.keyframeResolver?.resume(), mK()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    this._animation && this.animation.cancel(), this.keyframeResolver?.cancel();
  }
}
const NK = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function MK(e) {
  const t = NK.exec(e);
  if (!t)
    return [,];
  const [, n, i, r] = t;
  return [`--${n ?? i}`, r];
}
function AM(e, t, n = 1) {
  const [i, r] = MK(e);
  if (!i)
    return;
  const s = window.getComputedStyle(t).getPropertyValue(i);
  if (s) {
    const l = s.trim();
    return XN(l) ? parseFloat(l) : l;
  }
  return wx(r) ? AM(r, t, n + 1) : r;
}
function Ix(e, t) {
  return e?.[t] ?? e?.default ?? e;
}
const zM = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...Ao
]), DK = {
  test: (e) => e === "auto",
  parse: (e) => e
}, IM = (e) => (t) => t.test(e), CM = [$o, ze, Hr, Ki, $X, EX, DK], cT = (e) => CM.find(IM(e));
function jK(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || WN(e) : !0;
}
const PK = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function UK(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [i] = n.match(_x) || [];
  if (!i)
    return e;
  const r = n.replace(i, "");
  let s = PK.has(t) ? 1 : 0;
  return i !== n && (s *= 100), t + "(" + s + r + ")";
}
const LK = /\b([a-z-]*)\(.*?\)/gu, xv = {
  ...oa,
  getAnimatableNone: (e) => {
    const t = e.match(LK);
    return t ? t.map(UK).join(" ") : e;
  }
}, dT = {
  ...$o,
  transform: Math.round
}, BK = {
  rotate: Ki,
  rotateX: Ki,
  rotateY: Ki,
  rotateZ: Ki,
  scale: Ad,
  scaleX: Ad,
  scaleY: Ad,
  scaleZ: Ad,
  skew: Ki,
  skewX: Ki,
  skewY: Ki,
  distance: ze,
  translateX: ze,
  translateY: ze,
  translateZ: ze,
  x: ze,
  y: ze,
  z: ze,
  perspective: ze,
  transformPerspective: ze,
  opacity: hu,
  originX: Wk,
  originY: Wk,
  originZ: ze
}, Cx = {
  // Border props
  borderWidth: ze,
  borderTopWidth: ze,
  borderRightWidth: ze,
  borderBottomWidth: ze,
  borderLeftWidth: ze,
  borderRadius: ze,
  radius: ze,
  borderTopLeftRadius: ze,
  borderTopRightRadius: ze,
  borderBottomRightRadius: ze,
  borderBottomLeftRadius: ze,
  // Positioning props
  width: ze,
  maxWidth: ze,
  height: ze,
  maxHeight: ze,
  top: ze,
  right: ze,
  bottom: ze,
  left: ze,
  // Spacing props
  padding: ze,
  paddingTop: ze,
  paddingRight: ze,
  paddingBottom: ze,
  paddingLeft: ze,
  margin: ze,
  marginTop: ze,
  marginRight: ze,
  marginBottom: ze,
  marginLeft: ze,
  // Misc
  backgroundPositionX: ze,
  backgroundPositionY: ze,
  ...BK,
  zIndex: dT,
  // SVG
  fillOpacity: hu,
  strokeOpacity: hu,
  numOctaves: dT
}, ZK = {
  ...Cx,
  // Color props
  color: Dt,
  backgroundColor: Dt,
  outlineColor: Dt,
  fill: Dt,
  stroke: Dt,
  // Border props
  borderColor: Dt,
  borderTopColor: Dt,
  borderRightColor: Dt,
  borderBottomColor: Dt,
  borderLeftColor: Dt,
  filter: xv,
  WebkitFilter: xv
}, OM = (e) => ZK[e];
function RM(e, t) {
  let n = OM(e);
  return n !== xv && (n = oa), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const VK = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function FK(e, t, n) {
  let i = 0, r;
  for (; i < e.length && !r; ) {
    const s = e[i];
    typeof s == "string" && !VK.has(s) && pu(s).values.length && (r = e[i]), i++;
  }
  if (r && n)
    for (const s of t)
      e[s] = RM(n, r);
}
class HK extends zx {
  constructor(t, n, i, r, s) {
    super(t, n, i, r, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: i } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let f = 0; f < t.length; f++) {
      let h = t[f];
      if (typeof h == "string" && (h = h.trim(), wx(h))) {
        const p = AM(h, n.current);
        p !== void 0 && (t[f] = p), f === t.length - 1 && (this.finalKeyframe = h);
      }
    }
    if (this.resolveNoneKeyframes(), !zM.has(i) || t.length !== 2)
      return;
    const [r, s] = t, l = cT(r), c = cT(s);
    if (l !== c)
      if (sT(l) && sT(c))
        for (let f = 0; f < t.length; f++) {
          const h = t[f];
          typeof h == "string" && (t[f] = parseFloat(h));
        }
      else Fa[i] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, i = [];
    for (let r = 0; r < t.length; r++)
      (t[r] === null || jK(t[r])) && i.push(r);
    i.length && FK(t, i, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: i } = this;
    if (!t || !t.current)
      return;
    i === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Fa[i](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const r = n[n.length - 1];
    r !== void 0 && t.getValue(i, r).jump(r, !1);
  }
  measureEndState() {
    const { element: t, name: n, unresolvedKeyframes: i } = this;
    if (!t || !t.current)
      return;
    const r = t.getValue(n);
    r && r.jump(this.measuredOrigin, !1);
    const s = i.length - 1, l = i[s];
    i[s] = Fa[n](t.measureViewportBox(), window.getComputedStyle(t.current)), l !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = l), this.removedTransforms?.length && this.removedTransforms.forEach(([c, f]) => {
      t.getValue(c).set(f);
    }), this.resolveNoneKeyframes();
  }
}
function qK(e, t, n) {
  if (e instanceof EventTarget)
    return [e];
  if (typeof e == "string") {
    let i = document;
    const r = n?.[e] ?? i.querySelectorAll(e);
    return r ? Array.from(r) : [];
  }
  return Array.from(e);
}
const NM = (e, t) => t && typeof e == "number" ? t.transform(e) : e;
function GK(e) {
  return KN(e) && "offsetHeight" in e;
}
const fT = 30, YK = (e) => !isNaN(parseFloat(e));
class JK {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(t, n = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (i) => {
      const r = En.now();
      if (this.updatedAt !== r && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(i), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents))
        for (const s of this.dependents)
          s.dirty();
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = En.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = YK(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new vx());
    const i = this.events[t].add(n);
    return t === "change" ? () => {
      i(), vt.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : i;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t) {
    this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t);
  }
  setWithVelocity(t, n, i) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - i;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(t) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(t);
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = En.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > fT)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, fT);
    return QN(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function go(e, t) {
  return new JK(e, t);
}
const { schedule: Ox } = /* @__PURE__ */ cM(queueMicrotask, !1), br = {
  x: !1,
  y: !1
};
function MM() {
  return br.x || br.y;
}
function XK(e) {
  return e === "x" || e === "y" ? br[e] ? null : (br[e] = !0, () => {
    br[e] = !1;
  }) : br.x || br.y ? null : (br.x = br.y = !0, () => {
    br.x = br.y = !1;
  });
}
function DM(e, t) {
  const n = qK(e), i = new AbortController(), r = {
    passive: !0,
    ...t,
    signal: i.signal
  };
  return [n, r, () => i.abort()];
}
function hT(e) {
  return !(e.pointerType === "touch" || MM());
}
function KK(e, t, n = {}) {
  const [i, r, s] = DM(e, n), l = (c) => {
    if (!hT(c))
      return;
    const { target: f } = c, h = t(f, c);
    if (typeof h != "function" || !f)
      return;
    const p = (m) => {
      hT(m) && (h(m), f.removeEventListener("pointerleave", p));
    };
    f.addEventListener("pointerleave", p, r);
  };
  return i.forEach((c) => {
    c.addEventListener("pointerenter", l, r);
  }), s;
}
const jM = (e, t) => t ? e === t ? !0 : jM(e, t.parentElement) : !1, Rx = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, WK = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function QK(e) {
  return WK.has(e.tagName) || e.tabIndex !== -1;
}
const Zd = /* @__PURE__ */ new WeakSet();
function pT(e) {
  return (t) => {
    t.key === "Enter" && e(t);
  };
}
function tg(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 }));
}
const eW = (e, t) => {
  const n = e.currentTarget;
  if (!n)
    return;
  const i = pT(() => {
    if (Zd.has(n))
      return;
    tg(n, "down");
    const r = pT(() => {
      tg(n, "up");
    }), s = () => tg(n, "cancel");
    n.addEventListener("keyup", r, t), n.addEventListener("blur", s, t);
  });
  n.addEventListener("keydown", i, t), n.addEventListener("blur", () => n.removeEventListener("keydown", i), t);
};
function mT(e) {
  return Rx(e) && !MM();
}
function tW(e, t, n = {}) {
  const [i, r, s] = DM(e, n), l = (c) => {
    const f = c.currentTarget;
    if (!mT(c))
      return;
    Zd.add(f);
    const h = t(f, c), p = (b, x) => {
      window.removeEventListener("pointerup", m), window.removeEventListener("pointercancel", y), Zd.has(f) && Zd.delete(f), mT(b) && typeof h == "function" && h(b, { success: x });
    }, m = (b) => {
      p(b, f === window || f === document || n.useGlobalTarget || jM(f, b.target));
    }, y = (b) => {
      p(b, !1);
    };
    window.addEventListener("pointerup", m, r), window.addEventListener("pointercancel", y, r);
  };
  return i.forEach((c) => {
    (n.useGlobalTarget ? window : c).addEventListener("pointerdown", l, r), GK(c) && (c.addEventListener("focus", (h) => eW(h, r)), !QK(c) && !c.hasAttribute("tabindex") && (c.tabIndex = 0));
  }), s;
}
function PM(e) {
  return KN(e) && "ownerSVGElement" in e;
}
function nW(e) {
  return PM(e) && e.tagName === "svg";
}
const sn = (e) => !!(e && e.getVelocity), rW = [...CM, Dt, oa], iW = (e) => rW.find(IM(e)), UM = $.createContext({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
});
function aW(e = !0) {
  const t = $.useContext(fx);
  if (t === null)
    return [!0, null];
  const { isPresent: n, onExitComplete: i, register: r } = t, s = $.useId();
  $.useEffect(() => {
    if (e)
      return r(s);
  }, [e]);
  const l = $.useCallback(() => e && i && i(s), [s, i, e]);
  return !n && i ? [!1, l] : [!0];
}
const LM = $.createContext({ strict: !1 }), gT = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, vo = {};
for (const e in gT)
  vo[e] = {
    isEnabled: (t) => gT[e].some((n) => !!t[n])
  };
function sW(e) {
  for (const t in e)
    vo[t] = {
      ...vo[t],
      ...e[t]
    };
}
const oW = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function xf(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || oW.has(e);
}
let BM = (e) => !xf(e);
function lW(e) {
  typeof e == "function" && (BM = (t) => t.startsWith("on") ? !xf(t) : e(t));
}
try {
  lW(require("@emotion/is-prop-valid").default);
} catch {
}
function uW(e, t, n) {
  const i = {};
  for (const r in e)
    r === "values" && typeof e.values == "object" || (BM(r) || n === !0 && xf(r) || !t && !xf(r) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && r.startsWith("onDrag")) && (i[r] = e[r]);
  return i;
}
const sh = /* @__PURE__ */ $.createContext({});
function oh(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function mu(e) {
  return typeof e == "string" || Array.isArray(e);
}
const Nx = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], Mx = ["initial", ...Nx];
function lh(e) {
  return oh(e.animate) || Mx.some((t) => mu(e[t]));
}
function ZM(e) {
  return !!(lh(e) || e.variants);
}
function cW(e, t) {
  if (lh(e)) {
    const { initial: n, animate: i } = e;
    return {
      initial: n === !1 || mu(n) ? n : void 0,
      animate: mu(i) ? i : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function dW(e) {
  const { initial: t, animate: n } = cW(e, $.useContext(sh));
  return $.useMemo(() => ({ initial: t, animate: n }), [vT(t), vT(n)]);
}
function vT(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const gu = {};
function fW(e) {
  for (const t in e)
    gu[t] = e[t], xx(t) && (gu[t].isCSSVariable = !0);
}
function VM(e, { layout: t, layoutId: n }) {
  return zo.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!gu[e] || e === "opacity");
}
const hW = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, pW = Ao.length;
function mW(e, t, n) {
  let i = "", r = !0;
  for (let s = 0; s < pW; s++) {
    const l = Ao[s], c = e[l];
    if (c === void 0)
      continue;
    let f = !0;
    if (typeof c == "number" ? f = c === (l.startsWith("scale") ? 1 : 0) : f = parseFloat(c) === 0, !f || n) {
      const h = NM(c, Cx[l]);
      if (!f) {
        r = !1;
        const p = hW[l] || l;
        i += `${p}(${h}) `;
      }
      n && (t[l] = h);
    }
  }
  return i = i.trim(), n ? i = n(t, r ? "" : i) : r && (i = "none"), i;
}
function Dx(e, t, n) {
  const { style: i, vars: r, transformOrigin: s } = e;
  let l = !1, c = !1;
  for (const f in t) {
    const h = t[f];
    if (zo.has(f)) {
      l = !0;
      continue;
    } else if (xx(f)) {
      r[f] = h;
      continue;
    } else {
      const p = NM(h, Cx[f]);
      f.startsWith("origin") ? (c = !0, s[f] = p) : i[f] = p;
    }
  }
  if (t.transform || (l || n ? i.transform = mW(t, e.transform, n) : i.transform && (i.transform = "none")), c) {
    const { originX: f = "50%", originY: h = "50%", originZ: p = 0 } = s;
    i.transformOrigin = `${f} ${h} ${p}`;
  }
}
const jx = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function FM(e, t, n) {
  for (const i in t)
    !sn(t[i]) && !VM(i, n) && (e[i] = t[i]);
}
function gW({ transformTemplate: e }, t) {
  return $.useMemo(() => {
    const n = jx();
    return Dx(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function vW(e, t) {
  const n = e.style || {}, i = {};
  return FM(i, n, e), Object.assign(i, gW(e, t)), i;
}
function yW(e, t) {
  const n = {}, i = vW(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none", i.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = i, n;
}
const bW = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, xW = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function wW(e, t, n = 1, i = 0, r = !0) {
  e.pathLength = 1;
  const s = r ? bW : xW;
  e[s.offset] = ze.transform(-i);
  const l = ze.transform(t), c = ze.transform(n);
  e[s.array] = `${l} ${c}`;
}
function HM(e, {
  attrX: t,
  attrY: n,
  attrScale: i,
  pathLength: r,
  pathSpacing: s = 1,
  pathOffset: l = 0,
  // This is object creation, which we try to avoid per-frame.
  ...c
}, f, h, p) {
  if (Dx(e, c, h), f) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: m, style: y } = e;
  m.transform && (y.transform = m.transform, delete m.transform), (y.transform || m.transformOrigin) && (y.transformOrigin = m.transformOrigin ?? "50% 50%", delete m.transformOrigin), y.transform && (y.transformBox = p?.transformBox ?? "fill-box", delete m.transformBox), t !== void 0 && (m.x = t), n !== void 0 && (m.y = n), i !== void 0 && (m.scale = i), r !== void 0 && wW(m, r, s, l, !1);
}
const qM = () => ({
  ...jx(),
  attrs: {}
}), GM = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function _W(e, t, n, i) {
  const r = $.useMemo(() => {
    const s = qM();
    return HM(s, t, GM(i), e.transformTemplate, e.style), {
      ...s.attrs,
      style: { ...s.style }
    };
  }, [t]);
  if (e.style) {
    const s = {};
    FM(s, e.style, e), r.style = { ...s, ...r.style };
  }
  return r;
}
const SW = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Px(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(SW.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(e))
    )
  );
}
function kW(e, t, n, { latestValues: i }, r, s = !1) {
  const c = (Px(e) ? _W : yW)(t, i, r, e), f = uW(t, typeof e == "string", s), h = e !== $.Fragment ? { ...f, ...c, ref: n } : {}, { children: p } = t, m = $.useMemo(() => sn(p) ? p.get() : p, [p]);
  return $.createElement(e, {
    ...h,
    children: m
  });
}
function yT(e) {
  const t = [{}, {}];
  return e?.values.forEach((n, i) => {
    t[0][i] = n.get(), t[1][i] = n.getVelocity();
  }), t;
}
function Ux(e, t, n, i) {
  if (typeof t == "function") {
    const [r, s] = yT(i);
    t = t(n !== void 0 ? n : e.custom, r, s);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [r, s] = yT(i);
    t = t(n !== void 0 ? n : e.custom, r, s);
  }
  return t;
}
function Vd(e) {
  return sn(e) ? e.get() : e;
}
function TW({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, i, r) {
  return {
    latestValues: EW(n, i, r, e),
    renderState: t()
  };
}
function EW(e, t, n, i) {
  const r = {}, s = i(e, {});
  for (const y in s)
    r[y] = Vd(s[y]);
  let { initial: l, animate: c } = e;
  const f = lh(e), h = ZM(e);
  t && h && !f && e.inherit !== !1 && (l === void 0 && (l = t.initial), c === void 0 && (c = t.animate));
  let p = n ? n.initial === !1 : !1;
  p = p || l === !1;
  const m = p ? c : l;
  if (m && typeof m != "boolean" && !oh(m)) {
    const y = Array.isArray(m) ? m : [m];
    for (let b = 0; b < y.length; b++) {
      const x = Ux(e, y[b]);
      if (x) {
        const { transitionEnd: w, transition: k, ...T } = x;
        for (const A in T) {
          let z = T[A];
          if (Array.isArray(z)) {
            const O = p ? z.length - 1 : 0;
            z = z[O];
          }
          z !== null && (r[A] = z);
        }
        for (const A in w)
          r[A] = w[A];
      }
    }
  }
  return r;
}
const YM = (e) => (t, n) => {
  const i = $.useContext(sh), r = $.useContext(fx), s = () => TW(e, t, i, r);
  return n ? s() : sX(s);
};
function Lx(e, t, n) {
  const { style: i } = e, r = {};
  for (const s in i)
    (sn(i[s]) || t.style && sn(t.style[s]) || VM(s, e) || n?.getValue(s)?.liveStyle !== void 0) && (r[s] = i[s]);
  return r;
}
const $W = /* @__PURE__ */ YM({
  scrapeMotionValuesFromProps: Lx,
  createRenderState: jx
});
function JM(e, t, n) {
  const i = Lx(e, t, n);
  for (const r in e)
    if (sn(e[r]) || sn(t[r])) {
      const s = Ao.indexOf(r) !== -1 ? "attr" + r.charAt(0).toUpperCase() + r.substring(1) : r;
      i[s] = e[r];
    }
  return i;
}
const AW = /* @__PURE__ */ YM({
  scrapeMotionValuesFromProps: JM,
  createRenderState: qM
}), zW = Symbol.for("motionComponentSymbol");
function Qs(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function IW(e, t, n) {
  return $.useCallback(
    (i) => {
      i && e.onMount && e.onMount(i), t && (i ? t.mount(i) : t.unmount()), n && (typeof n == "function" ? n(i) : Qs(n) && (n.current = i));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [t]
  );
}
const Bx = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), CW = "framerAppearId", XM = "data-" + Bx(CW), KM = $.createContext({});
function OW(e, t, n, i, r) {
  const { visualElement: s } = $.useContext(sh), l = $.useContext(LM), c = $.useContext(fx), f = $.useContext(UM).reducedMotion, h = $.useRef(null);
  i = i || l.renderer, !h.current && i && (h.current = i(e, {
    visualState: t,
    parent: s,
    props: n,
    presenceContext: c,
    blockInitialAnimation: c ? c.initial === !1 : !1,
    reducedMotionConfig: f
  }));
  const p = h.current, m = $.useContext(KM);
  p && !p.projection && r && (p.type === "html" || p.type === "svg") && RW(h.current, n, r, m);
  const y = $.useRef(!1);
  $.useInsertionEffect(() => {
    p && y.current && p.update(n, c);
  });
  const b = n[XM], x = $.useRef(!!b && !window.MotionHandoffIsComplete?.(b) && window.MotionHasOptimisedAnimation?.(b));
  return oX(() => {
    p && (y.current = !0, window.MotionIsMounted = !0, p.updateFeatures(), p.scheduleRenderMicrotask(), x.current && p.animationState && p.animationState.animateChanges());
  }), $.useEffect(() => {
    p && (!x.current && p.animationState && p.animationState.animateChanges(), x.current && (queueMicrotask(() => {
      window.MotionHandoffMarkAsComplete?.(b);
    }), x.current = !1), p.enteringChildren = void 0);
  }), p;
}
function RW(e, t, n, i) {
  const { layoutId: r, layout: s, drag: l, dragConstraints: c, layoutScroll: f, layoutRoot: h, layoutCrossfade: p } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : WM(e.parent)), e.projection.setOptions({
    layoutId: r,
    layout: s,
    alwaysMeasureLayout: !!l || c && Qs(c),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof s == "string" ? s : "both",
    initialPromotionConfig: i,
    crossfade: p,
    layoutScroll: f,
    layoutRoot: h
  });
}
function WM(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : WM(e.parent);
}
function ng(e, { forwardMotionProps: t = !1 } = {}, n, i) {
  n && sW(n);
  const r = Px(e) ? AW : $W;
  function s(c, f) {
    let h;
    const p = {
      ...$.useContext(UM),
      ...c,
      layoutId: NW(c)
    }, { isStatic: m } = p, y = dW(c), b = r(c, m);
    if (!m && dx) {
      MW();
      const x = DW(p);
      h = x.MeasureLayout, y.visualElement = OW(e, b, p, i, x.ProjectionNode);
    }
    return C.jsxs(sh.Provider, { value: y, children: [h && y.visualElement ? C.jsx(h, { visualElement: y.visualElement, ...p }) : null, kW(e, c, IW(b, y.visualElement, f), b, m, t)] });
  }
  s.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`;
  const l = $.forwardRef(s);
  return l[zW] = e, l;
}
function NW({ layoutId: e }) {
  const t = $.useContext(JN).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function MW(e, t) {
  $.useContext(LM).strict;
}
function DW(e) {
  const { drag: t, layout: n } = vo;
  if (!t && !n)
    return {};
  const i = { ...t, ...n };
  return {
    MeasureLayout: t?.isEnabled(e) || n?.isEnabled(e) ? i.MeasureLayout : void 0,
    ProjectionNode: i.ProjectionNode
  };
}
function jW(e, t) {
  if (typeof Proxy > "u")
    return ng;
  const n = /* @__PURE__ */ new Map(), i = (s, l) => ng(s, l, e, t), r = (s, l) => i(s, l);
  return new Proxy(r, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (s, l) => l === "create" ? i : (n.has(l) || n.set(l, ng(l, void 0, e, t)), n.get(l))
  });
}
function QM({ top: e, left: t, right: n, bottom: i }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: i }
  };
}
function PW({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function UW(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), i = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: i.y,
    right: i.x
  };
}
function rg(e) {
  return e === void 0 || e === 1;
}
function wv({ scale: e, scaleX: t, scaleY: n }) {
  return !rg(e) || !rg(t) || !rg(n);
}
function Da(e) {
  return wv(e) || eD(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function eD(e) {
  return bT(e.x) || bT(e.y);
}
function bT(e) {
  return e && e !== "0%";
}
function wf(e, t, n) {
  const i = e - n, r = t * i;
  return n + r;
}
function xT(e, t, n, i, r) {
  return r !== void 0 && (e = wf(e, r, i)), wf(e, n, i) + t;
}
function _v(e, t = 0, n = 1, i, r) {
  e.min = xT(e.min, t, n, i, r), e.max = xT(e.max, t, n, i, r);
}
function tD(e, { x: t, y: n }) {
  _v(e.x, t.translate, t.scale, t.originPoint), _v(e.y, n.translate, n.scale, n.originPoint);
}
const wT = 0.999999999999, _T = 1.0000000000001;
function LW(e, t, n, i = !1) {
  const r = n.length;
  if (!r)
    return;
  t.x = t.y = 1;
  let s, l;
  for (let c = 0; c < r; c++) {
    s = n[c], l = s.projectionDelta;
    const { visualElement: f } = s.options;
    f && f.props.style && f.props.style.display === "contents" || (i && s.options.layoutScroll && s.scroll && s !== s.root && to(e, {
      x: -s.scroll.offset.x,
      y: -s.scroll.offset.y
    }), l && (t.x *= l.x.scale, t.y *= l.y.scale, tD(e, l)), i && Da(s.latestValues) && to(e, s.latestValues));
  }
  t.x < _T && t.x > wT && (t.x = 1), t.y < _T && t.y > wT && (t.y = 1);
}
function eo(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function ST(e, t, n, i, r = 0.5) {
  const s = _t(e.min, e.max, r);
  _v(e, t, n, s, i);
}
function to(e, t) {
  ST(e.x, t.x, t.scaleX, t.scale, t.originX), ST(e.y, t.y, t.scaleY, t.scale, t.originY);
}
function nD(e, t) {
  return QM(UW(e.getBoundingClientRect(), t));
}
function BW(e, t, n) {
  const i = nD(e, n), { scroll: r } = t;
  return r && (eo(i.x, r.offset.x), eo(i.y, r.offset.y)), i;
}
const kT = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), no = () => ({
  x: kT(),
  y: kT()
}), TT = () => ({ min: 0, max: 0 }), Ct = () => ({
  x: TT(),
  y: TT()
}), Sv = { current: null }, rD = { current: !1 };
function ZW() {
  if (rD.current = !0, !!dx)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => Sv.current = e.matches;
      e.addEventListener("change", t), t();
    } else
      Sv.current = !1;
}
const VW = /* @__PURE__ */ new WeakMap();
function FW(e, t, n) {
  for (const i in t) {
    const r = t[i], s = n[i];
    if (sn(r))
      e.addValue(i, r);
    else if (sn(s))
      e.addValue(i, go(r, { owner: e }));
    else if (s !== r)
      if (e.hasValue(i)) {
        const l = e.getValue(i);
        l.liveStyle === !0 ? l.jump(r) : l.hasAnimated || l.set(r);
      } else {
        const l = e.getStaticValue(i);
        e.addValue(i, go(l !== void 0 ? l : r, { owner: e }));
      }
  }
  for (const i in n)
    t[i] === void 0 && e.removeValue(i);
  return t;
}
const ET = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class HW {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, i) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: i, reducedMotionConfig: r, blockInitialAnimation: s, visualState: l }, c = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = zx, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const y = En.now();
      this.renderScheduledAt < y && (this.renderScheduledAt = y, vt.render(this.render, !1, !0));
    };
    const { latestValues: f, renderState: h } = l;
    this.latestValues = f, this.baseTarget = { ...f }, this.initialValues = n.initial ? { ...f } : {}, this.renderState = h, this.parent = t, this.props = n, this.presenceContext = i, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = r, this.options = c, this.blockInitialAnimation = !!s, this.isControllingVariants = lh(n), this.isVariantNode = ZM(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: p, ...m } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const y in m) {
      const b = m[y];
      f[y] !== void 0 && sn(b) && b.set(f[y]);
    }
  }
  mount(t) {
    this.current = t, VW.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, i) => this.bindToMotionValue(i, n)), rD.current || ZW(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Sv.current, this.parent?.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(), sa(this.notifyUpdate), sa(this.render), this.valueSubscriptions.forEach((t) => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features) {
      const n = this.features[t];
      n && (n.unmount(), n.isMounted = !1);
    }
    this.current = null;
  }
  addChild(t) {
    this.children.add(t), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(t);
  }
  removeChild(t) {
    this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t);
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const i = zo.has(t);
    i && this.onBindTransform && this.onBindTransform();
    const r = n.on("change", (l) => {
      this.latestValues[t] = l, this.props.onUpdate && vt.preRender(this.notifyUpdate), i && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let s;
    window.MotionCheckAppearSync && (s = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      r(), s && s(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in vo) {
      const n = vo[t];
      if (!n)
        continue;
      const { isEnabled: i, Feature: r } = n;
      if (!this.features[t] && r && i(this.props) && (this.features[t] = new r(this)), this.features[t]) {
        const s = this.features[t];
        s.isMounted ? s.update() : (s.mount(), s.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Ct();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let i = 0; i < ET.length; i++) {
      const r = ET[i];
      this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](), delete this.propEventSubscriptions[r]);
      const s = "on" + r, l = t[s];
      l && (this.propEventSubscriptions[r] = this.on(r, l));
    }
    this.prevMotionValues = FW(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const i = this.values.get(t);
    n !== i && (i && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let i = this.values.get(t);
    return i === void 0 && n !== void 0 && (i = go(n === null ? void 0 : n, { owner: this }), this.addValue(t, i)), i;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    let i = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
    return i != null && (typeof i == "string" && (XN(i) || WN(i)) ? i = parseFloat(i) : !iW(i) && oa.test(n) && (i = RM(t, n)), this.setBaseTarget(t, sn(i) ? i.get() : i)), sn(i) ? i.get() : i;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    const { initial: n } = this.props;
    let i;
    if (typeof n == "string" || typeof n == "object") {
      const s = Ux(this.props, n, this.presenceContext?.custom);
      s && (i = s[t]);
    }
    if (n && i !== void 0)
      return i;
    const r = this.getBaseTargetFromProps(this.props, t);
    return r !== void 0 && !sn(r) ? r : this.initialValues[t] !== void 0 && i === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new vx()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
  scheduleRenderMicrotask() {
    Ox.render(this.render);
  }
}
class iD extends HW {
  constructor() {
    super(...arguments), this.KeyframeResolver = HK;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: i }) {
    delete n[t], delete i[t];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    sn(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
function aD(e, { style: t, vars: n }, i, r) {
  const s = e.style;
  let l;
  for (l in t)
    s[l] = t[l];
  r?.applyProjectionStyles(s, i);
  for (l in n)
    s.setProperty(l, n[l]);
}
function qW(e) {
  return window.getComputedStyle(e);
}
class GW extends iD {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = aD;
  }
  readValueFromInstance(t, n) {
    if (zo.has(n))
      return this.projection?.isProjecting ? pv(n) : cK(t, n);
    {
      const i = qW(t), r = (xx(n) ? i.getPropertyValue(n) : i[n]) || 0;
      return typeof r == "string" ? r.trim() : r;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return nD(t, n);
  }
  build(t, n, i) {
    Dx(t, n, i.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, i) {
    return Lx(t, n, i);
  }
}
const sD = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function YW(e, t, n, i) {
  aD(e, t, void 0, i);
  for (const r in t.attrs)
    e.setAttribute(sD.has(r) ? r : Bx(r), t.attrs[r]);
}
class JW extends iD {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Ct;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (zo.has(n)) {
      const i = OM(n);
      return i && i.default || 0;
    }
    return n = sD.has(n) ? n : Bx(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, i) {
    return JM(t, n, i);
  }
  build(t, n, i) {
    HM(t, n, this.isSVGTag, i.transformTemplate, i.style);
  }
  renderInstance(t, n, i, r) {
    YW(t, n, i, r);
  }
  mount(t) {
    this.isSVGTag = GM(t.tagName), super.mount(t);
  }
}
const XW = (e, t) => Px(e) ? new JW(t) : new GW(t, {
  allowProjection: e !== $.Fragment
});
function so(e, t, n) {
  const i = e.getProps();
  return Ux(i, t, n !== void 0 ? n : i.custom, e);
}
const kv = (e) => Array.isArray(e);
function KW(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, go(n));
}
function WW(e) {
  return kv(e) ? e[e.length - 1] || 0 : e;
}
function QW(e, t) {
  const n = so(e, t);
  let { transitionEnd: i = {}, transition: r = {}, ...s } = n || {};
  s = { ...s, ...i };
  for (const l in s) {
    const c = WW(s[l]);
    KW(e, l, c);
  }
}
function eQ(e) {
  return !!(sn(e) && e.add);
}
function Tv(e, t) {
  const n = e.getValue("willChange");
  if (eQ(n))
    return n.add(t);
  if (!n && wi.WillChange) {
    const i = new wi.WillChange("auto");
    e.addValue("willChange", i), i.add(t);
  }
}
function oD(e) {
  return e.props[XM];
}
const tQ = (e) => e !== null;
function nQ(e, { repeat: t, repeatType: n = "loop" }, i) {
  const r = e.filter(tQ), s = t && n !== "loop" && t % 2 === 1 ? 0 : r.length - 1;
  return r[s];
}
const rQ = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, iQ = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), aQ = {
  type: "keyframes",
  duration: 0.8
}, sQ = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, oQ = (e, { keyframes: t }) => t.length > 2 ? aQ : zo.has(e) ? e.startsWith("scale") ? iQ(t[1]) : rQ : sQ;
function lQ({ when: e, delay: t, delayChildren: n, staggerChildren: i, staggerDirection: r, repeat: s, repeatType: l, repeatDelay: c, from: f, elapsed: h, ...p }) {
  return !!Object.keys(p).length;
}
const Zx = (e, t, n, i = {}, r, s) => (l) => {
  const c = Ix(i, e) || {}, f = c.delay || i.delay || 0;
  let { elapsed: h = 0 } = i;
  h = h - /* @__PURE__ */ Vr(f);
  const p = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...c,
    delay: -h,
    onUpdate: (y) => {
      t.set(y), c.onUpdate && c.onUpdate(y);
    },
    onComplete: () => {
      l(), c.onComplete && c.onComplete();
    },
    name: e,
    motionValue: t,
    element: s ? void 0 : r
  };
  lQ(c) || Object.assign(p, oQ(e, p)), p.duration && (p.duration = /* @__PURE__ */ Vr(p.duration)), p.repeatDelay && (p.repeatDelay = /* @__PURE__ */ Vr(p.repeatDelay)), p.from !== void 0 && (p.keyframes[0] = p.from);
  let m = !1;
  if ((p.type === !1 || p.duration === 0 && !p.repeatDelay) && (bv(p), p.delay === 0 && (m = !0)), (wi.instantAnimations || wi.skipAnimations) && (m = !0, bv(p), p.delay = 0), p.allowFlatten = !c.type && !c.ease, m && !s && t.get() !== void 0) {
    const y = nQ(p.keyframes, c);
    if (y !== void 0) {
      vt.update(() => {
        p.onUpdate(y), p.onComplete();
      });
      return;
    }
  }
  return c.isSync ? new Ax(p) : new RK(p);
};
function uQ({ protectedKeys: e, needsAnimating: t }, n) {
  const i = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, i;
}
function lD(e, t, { delay: n = 0, transitionOverride: i, type: r } = {}) {
  let { transition: s = e.getDefaultTransition(), transitionEnd: l, ...c } = t;
  i && (s = i);
  const f = [], h = r && e.animationState && e.animationState.getState()[r];
  for (const p in c) {
    const m = e.getValue(p, e.latestValues[p] ?? null), y = c[p];
    if (y === void 0 || h && uQ(h, p))
      continue;
    const b = {
      delay: n,
      ...Ix(s || {}, p)
    }, x = m.get();
    if (x !== void 0 && !m.isAnimating && !Array.isArray(y) && y === x && !b.velocity)
      continue;
    let w = !1;
    if (window.MotionHandoffAnimation) {
      const T = oD(e);
      if (T) {
        const A = window.MotionHandoffAnimation(T, p, vt);
        A !== null && (b.startTime = A, w = !0);
      }
    }
    Tv(e, p), m.start(Zx(p, m, y, e.shouldReduceMotion && zM.has(p) ? { type: !1 } : b, e, w));
    const k = m.animation;
    k && f.push(k);
  }
  return l && Promise.all(f).then(() => {
    vt.update(() => {
      l && QW(e, l);
    });
  }), f;
}
function uD(e, t, n, i = 0, r = 1) {
  const s = Array.from(e).sort((h, p) => h.sortNodePosition(p)).indexOf(t), l = e.size, c = (l - 1) * i;
  return typeof n == "function" ? n(s, l) : r === 1 ? s * i : c - s * i;
}
function Ev(e, t, n = {}) {
  const i = so(e, t, n.type === "exit" ? e.presenceContext?.custom : void 0);
  let { transition: r = e.getDefaultTransition() || {} } = i || {};
  n.transitionOverride && (r = n.transitionOverride);
  const s = i ? () => Promise.all(lD(e, i, n)) : () => Promise.resolve(), l = e.variantChildren && e.variantChildren.size ? (f = 0) => {
    const { delayChildren: h = 0, staggerChildren: p, staggerDirection: m } = r;
    return cQ(e, t, f, h, p, m, n);
  } : () => Promise.resolve(), { when: c } = r;
  if (c) {
    const [f, h] = c === "beforeChildren" ? [s, l] : [l, s];
    return f().then(() => h());
  } else
    return Promise.all([s(), l(n.delay)]);
}
function cQ(e, t, n = 0, i = 0, r = 0, s = 1, l) {
  const c = [];
  for (const f of e.variantChildren)
    f.notify("AnimationStart", t), c.push(Ev(f, t, {
      ...l,
      delay: n + (typeof i == "function" ? 0 : i) + uD(e.variantChildren, f, i, r, s)
    }).then(() => f.notify("AnimationComplete", t)));
  return Promise.all(c);
}
function dQ(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let i;
  if (Array.isArray(t)) {
    const r = t.map((s) => Ev(e, s, n));
    i = Promise.all(r);
  } else if (typeof t == "string")
    i = Ev(e, t, n);
  else {
    const r = typeof t == "function" ? so(e, t, n.custom) : t;
    i = Promise.all(lD(e, r, n));
  }
  return i.then(() => {
    e.notify("AnimationComplete", t);
  });
}
function cD(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let i = 0; i < n; i++)
    if (t[i] !== e[i])
      return !1;
  return !0;
}
const fQ = Mx.length;
function dD(e) {
  if (!e)
    return;
  if (!e.isControllingVariants) {
    const n = e.parent ? dD(e.parent) || {} : {};
    return e.props.initial !== void 0 && (n.initial = e.props.initial), n;
  }
  const t = {};
  for (let n = 0; n < fQ; n++) {
    const i = Mx[n], r = e.props[i];
    (mu(r) || r === !1) && (t[i] = r);
  }
  return t;
}
const hQ = [...Nx].reverse(), pQ = Nx.length;
function mQ(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: i }) => dQ(e, n, i)));
}
function gQ(e) {
  let t = mQ(e), n = $T(), i = !0;
  const r = (f) => (h, p) => {
    const m = so(e, p, f === "exit" ? e.presenceContext?.custom : void 0);
    if (m) {
      const { transition: y, transitionEnd: b, ...x } = m;
      h = { ...h, ...x, ...b };
    }
    return h;
  };
  function s(f) {
    t = f(e);
  }
  function l(f) {
    const { props: h } = e, p = dD(e.parent) || {}, m = [], y = /* @__PURE__ */ new Set();
    let b = {}, x = 1 / 0;
    for (let k = 0; k < pQ; k++) {
      const T = hQ[k], A = n[T], z = h[T] !== void 0 ? h[T] : p[T], O = mu(z), M = T === f ? A.isActive : null;
      M === !1 && (x = k);
      let N = z === p[T] && z !== h[T] && O;
      if (N && i && e.manuallyAnimateOnMount && (N = !1), A.protectedKeys = { ...b }, // If it isn't active and hasn't *just* been set as inactive
      !A.isActive && M === null || // If we didn't and don't have any defined prop for this animation type
      !z && !A.prevProp || // Or if the prop doesn't define an animation
      oh(z) || typeof z == "boolean")
        continue;
      const U = vQ(A.prevProp, z);
      let Z = U || // If we're making this variant active, we want to always make it active
      T === f && A.isActive && !N && O || // If we removed a higher-priority variant (i is in reverse order)
      k > x && O, re = !1;
      const D = Array.isArray(z) ? z : [z];
      let ae = D.reduce(r(T), {});
      M === !1 && (ae = {});
      const { prevResolvedValues: ie = {} } = A, le = {
        ...ie,
        ...ae
      }, se = (Y) => {
        Z = !0, y.has(Y) && (re = !0, y.delete(Y)), A.needsAnimating[Y] = !0;
        const H = e.getValue(Y);
        H && (H.liveStyle = !1);
      };
      for (const Y in le) {
        const H = ae[Y], ge = ie[Y];
        if (b.hasOwnProperty(Y))
          continue;
        let S = !1;
        kv(H) && kv(ge) ? S = !cD(H, ge) : S = H !== ge, S ? H != null ? se(Y) : y.add(Y) : H !== void 0 && y.has(Y) ? se(Y) : A.protectedKeys[Y] = !0;
      }
      A.prevProp = z, A.prevResolvedValues = ae, A.isActive && (b = { ...b, ...ae }), i && e.blockInitialAnimation && (Z = !1);
      const ce = N && U;
      Z && (!ce || re) && m.push(...D.map((Y) => {
        const H = { type: T };
        if (typeof Y == "string" && i && !ce && e.manuallyAnimateOnMount && e.parent) {
          const { parent: ge } = e, S = so(ge, Y);
          if (ge.enteringChildren && S) {
            const { delayChildren: X } = S.transition || {};
            H.delay = uD(ge.enteringChildren, e, X);
          }
        }
        return {
          animation: Y,
          options: H
        };
      }));
    }
    if (y.size) {
      const k = {};
      if (typeof h.initial != "boolean") {
        const T = so(e, Array.isArray(h.initial) ? h.initial[0] : h.initial);
        T && T.transition && (k.transition = T.transition);
      }
      y.forEach((T) => {
        const A = e.getBaseTarget(T), z = e.getValue(T);
        z && (z.liveStyle = !0), k[T] = A ?? null;
      }), m.push({ animation: k });
    }
    let w = !!m.length;
    return i && (h.initial === !1 || h.initial === h.animate) && !e.manuallyAnimateOnMount && (w = !1), i = !1, w ? t(m) : Promise.resolve();
  }
  function c(f, h) {
    if (n[f].isActive === h)
      return Promise.resolve();
    e.variantChildren?.forEach((m) => m.animationState?.setActive(f, h)), n[f].isActive = h;
    const p = l(f);
    for (const m in n)
      n[m].protectedKeys = {};
    return p;
  }
  return {
    animateChanges: l,
    setActive: c,
    setAnimateFunction: s,
    getState: () => n,
    reset: () => {
      n = $T(), i = !0;
    }
  };
}
function vQ(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !cD(t, e) : !1;
}
function Na(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function $T() {
  return {
    animate: Na(!0),
    whileInView: Na(),
    whileHover: Na(),
    whileTap: Na(),
    whileDrag: Na(),
    whileFocus: Na(),
    exit: Na()
  };
}
class da {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}
class yQ extends da {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = gQ(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    oh(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    this.node.animationState.reset(), this.unmountControls?.();
  }
}
let bQ = 0;
class xQ extends da {
  constructor() {
    super(...arguments), this.id = bQ++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: i } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === i)
      return;
    const r = this.node.animationState.setActive("exit", !t);
    n && !t && r.then(() => {
      n(this.id);
    });
  }
  mount() {
    const { register: t, onExitComplete: n } = this.node.presenceContext || {};
    n && n(this.id), t && (this.unmount = t(this.id));
  }
  unmount() {
  }
}
const wQ = {
  animation: {
    Feature: yQ
  },
  exit: {
    Feature: xQ
  }
};
function vu(e, t, n, i = { passive: !0 }) {
  return e.addEventListener(t, n, i), () => e.removeEventListener(t, n);
}
function Hu(e) {
  return {
    point: {
      x: e.pageX,
      y: e.pageY
    }
  };
}
const _Q = (e) => (t) => Rx(t) && e(t, Hu(t));
function Yl(e, t, n, i) {
  return vu(e, t, _Q(n), i);
}
const fD = 1e-4, SQ = 1 - fD, kQ = 1 + fD, hD = 0.01, TQ = 0 - hD, EQ = 0 + hD;
function mn(e) {
  return e.max - e.min;
}
function $Q(e, t, n) {
  return Math.abs(e - t) <= n;
}
function AT(e, t, n, i = 0.5) {
  e.origin = i, e.originPoint = _t(t.min, t.max, e.origin), e.scale = mn(n) / mn(t), e.translate = _t(n.min, n.max, e.origin) - e.originPoint, (e.scale >= SQ && e.scale <= kQ || isNaN(e.scale)) && (e.scale = 1), (e.translate >= TQ && e.translate <= EQ || isNaN(e.translate)) && (e.translate = 0);
}
function Jl(e, t, n, i) {
  AT(e.x, t.x, n.x, i ? i.originX : void 0), AT(e.y, t.y, n.y, i ? i.originY : void 0);
}
function zT(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + mn(t);
}
function AQ(e, t, n) {
  zT(e.x, t.x, n.x), zT(e.y, t.y, n.y);
}
function IT(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + mn(t);
}
function Xl(e, t, n) {
  IT(e.x, t.x, n.x), IT(e.y, t.y, n.y);
}
function lr(e) {
  return [e("x"), e("y")];
}
const pD = ({ current: e }) => e ? e.ownerDocument.defaultView : null, CT = (e, t) => Math.abs(e - t);
function zQ(e, t) {
  const n = CT(e.x, t.x), i = CT(e.y, t.y);
  return Math.sqrt(n ** 2 + i ** 2);
}
class mD {
  constructor(t, n, { transformPagePoint: i, contextWindow: r = window, dragSnapToOrigin: s = !1, distanceThreshold: l = 3 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const y = ag(this.lastMoveEventInfo, this.history), b = this.startEvent !== null, x = zQ(y.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!b && !x)
        return;
      const { point: w } = y, { timestamp: k } = tn;
      this.history.push({ ...w, timestamp: k });
      const { onStart: T, onMove: A } = this.handlers;
      b || (T && T(this.lastMoveEvent, y), this.startEvent = this.lastMoveEvent), A && A(this.lastMoveEvent, y);
    }, this.handlePointerMove = (y, b) => {
      this.lastMoveEvent = y, this.lastMoveEventInfo = ig(b, this.transformPagePoint), vt.update(this.updatePoint, !0);
    }, this.handlePointerUp = (y, b) => {
      this.end();
      const { onEnd: x, onSessionEnd: w, resumeAnimation: k } = this.handlers;
      if (this.dragSnapToOrigin && k && k(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const T = ag(y.type === "pointercancel" ? this.lastMoveEventInfo : ig(b, this.transformPagePoint), this.history);
      this.startEvent && x && x(y, T), w && w(y, T);
    }, !Rx(t))
      return;
    this.dragSnapToOrigin = s, this.handlers = n, this.transformPagePoint = i, this.distanceThreshold = l, this.contextWindow = r || window;
    const c = Hu(t), f = ig(c, this.transformPagePoint), { point: h } = f, { timestamp: p } = tn;
    this.history = [{ ...h, timestamp: p }];
    const { onSessionStart: m } = n;
    m && m(t, ag(f, this.history)), this.removeListeners = Zu(Yl(this.contextWindow, "pointermove", this.handlePointerMove), Yl(this.contextWindow, "pointerup", this.handlePointerUp), Yl(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), sa(this.updatePoint);
  }
}
function ig(e, t) {
  return t ? { point: t(e.point) } : e;
}
function OT(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function ag({ point: e }, t) {
  return {
    point: e,
    delta: OT(e, gD(t)),
    offset: OT(e, IQ(t)),
    velocity: CQ(t, 0.1)
  };
}
function IQ(e) {
  return e[0];
}
function gD(e) {
  return e[e.length - 1];
}
function CQ(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, i = null;
  const r = gD(e);
  for (; n >= 0 && (i = e[n], !(r.timestamp - i.timestamp > /* @__PURE__ */ Vr(t))); )
    n--;
  if (!i)
    return { x: 0, y: 0 };
  const s = /* @__PURE__ */ Fr(r.timestamp - i.timestamp);
  if (s === 0)
    return { x: 0, y: 0 };
  const l = {
    x: (r.x - i.x) / s,
    y: (r.y - i.y) / s
  };
  return l.x === 1 / 0 && (l.x = 0), l.y === 1 / 0 && (l.y = 0), l;
}
function OQ(e, { min: t, max: n }, i) {
  return t !== void 0 && e < t ? e = i ? _t(t, e, i.min) : Math.max(e, t) : n !== void 0 && e > n && (e = i ? _t(n, e, i.max) : Math.min(e, n)), e;
}
function RT(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function RQ(e, { top: t, left: n, bottom: i, right: r }) {
  return {
    x: RT(e.x, n, r),
    y: RT(e.y, t, i)
  };
}
function NT(e, t) {
  let n = t.min - e.min, i = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, i] = [i, n]), { min: n, max: i };
}
function NQ(e, t) {
  return {
    x: NT(e.x, t.x),
    y: NT(e.y, t.y)
  };
}
function MQ(e, t) {
  let n = 0.5;
  const i = mn(e), r = mn(t);
  return r > i ? n = /* @__PURE__ */ fu(t.min, t.max - i, e.min) : i > r && (n = /* @__PURE__ */ fu(e.min, e.max - r, t.min)), xi(0, 1, n);
}
function DQ(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
const $v = 0.35;
function jQ(e = $v) {
  return e === !1 ? e = 0 : e === !0 && (e = $v), {
    x: MT(e, "left", "right"),
    y: MT(e, "top", "bottom")
  };
}
function MT(e, t, n) {
  return {
    min: DT(e, t),
    max: DT(e, n)
  };
}
function DT(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const PQ = /* @__PURE__ */ new WeakMap();
class UQ {
  constructor(t) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Ct(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1, distanceThreshold: i } = {}) {
    const { presenceContext: r } = this.visualElement;
    if (r && r.isPresent === !1)
      return;
    const s = (m) => {
      const { dragSnapToOrigin: y } = this.getProps();
      y ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(Hu(m).point);
    }, l = (m, y) => {
      const { drag: b, dragPropagation: x, onDragStart: w } = this.getProps();
      if (b && !x && (this.openDragLock && this.openDragLock(), this.openDragLock = XK(b), !this.openDragLock))
        return;
      this.latestPointerEvent = m, this.latestPanInfo = y, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), lr((T) => {
        let A = this.getAxisMotionValue(T).get() || 0;
        if (Hr.test(A)) {
          const { projection: z } = this.visualElement;
          if (z && z.layout) {
            const O = z.layout.layoutBox[T];
            O && (A = mn(O) * (parseFloat(A) / 100));
          }
        }
        this.originPoint[T] = A;
      }), w && vt.postRender(() => w(m, y)), Tv(this.visualElement, "transform");
      const { animationState: k } = this.visualElement;
      k && k.setActive("whileDrag", !0);
    }, c = (m, y) => {
      this.latestPointerEvent = m, this.latestPanInfo = y;
      const { dragPropagation: b, dragDirectionLock: x, onDirectionLock: w, onDrag: k } = this.getProps();
      if (!b && !this.openDragLock)
        return;
      const { offset: T } = y;
      if (x && this.currentDirection === null) {
        this.currentDirection = LQ(T), this.currentDirection !== null && w && w(this.currentDirection);
        return;
      }
      this.updateAxis("x", y.point, T), this.updateAxis("y", y.point, T), this.visualElement.render(), k && k(m, y);
    }, f = (m, y) => {
      this.latestPointerEvent = m, this.latestPanInfo = y, this.stop(m, y), this.latestPointerEvent = null, this.latestPanInfo = null;
    }, h = () => lr((m) => this.getAnimationState(m) === "paused" && this.getAxisMotionValue(m).animation?.play()), { dragSnapToOrigin: p } = this.getProps();
    this.panSession = new mD(t, {
      onSessionStart: s,
      onStart: l,
      onMove: c,
      onSessionEnd: f,
      resumeAnimation: h
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: p,
      distanceThreshold: i,
      contextWindow: pD(this.visualElement)
    });
  }
  /**
   * @internal
   */
  stop(t, n) {
    const i = t || this.latestPointerEvent, r = n || this.latestPanInfo, s = this.isDragging;
    if (this.cancel(), !s || !r || !i)
      return;
    const { velocity: l } = r;
    this.startAnimation(l);
    const { onDragEnd: c } = this.getProps();
    c && vt.postRender(() => c(i, r));
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: i } = this.getProps();
    !i && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1);
  }
  updateAxis(t, n, i) {
    const { drag: r } = this.getProps();
    if (!i || !zd(t, r, this.currentDirection))
      return;
    const s = this.getAxisMotionValue(t);
    let l = this.originPoint[t] + i[t];
    this.constraints && this.constraints[t] && (l = OQ(l, this.constraints[t], this.elastic[t])), s.set(l);
  }
  resolveConstraints() {
    const { dragConstraints: t, dragElastic: n } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, r = this.constraints;
    t && Qs(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && i ? this.constraints = RQ(i.layoutBox, t) : this.constraints = !1, this.elastic = jQ(n), r !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && lr((s) => {
      this.constraints !== !1 && this.getAxisMotionValue(s) && (this.constraints[s] = DQ(i.layoutBox[s], this.constraints[s]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !Qs(t))
      return !1;
    const i = t.current, { projection: r } = this.visualElement;
    if (!r || !r.layout)
      return !1;
    const s = BW(i, r.root, this.visualElement.getTransformPagePoint());
    let l = NQ(r.layout.layoutBox, s);
    if (n) {
      const c = n(PW(l));
      this.hasMutatedConstraints = !!c, c && (l = QM(c));
    }
    return l;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: i, dragElastic: r, dragTransition: s, dragSnapToOrigin: l, onDragTransitionEnd: c } = this.getProps(), f = this.constraints || {}, h = lr((p) => {
      if (!zd(p, n, this.currentDirection))
        return;
      let m = f && f[p] || {};
      l && (m = { min: 0, max: 0 });
      const y = r ? 200 : 1e6, b = r ? 40 : 1e7, x = {
        type: "inertia",
        velocity: i ? t[p] : 0,
        bounceStiffness: y,
        bounceDamping: b,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...s,
        ...m
      };
      return this.startAxisValueAnimation(p, x);
    });
    return Promise.all(h).then(c);
  }
  startAxisValueAnimation(t, n) {
    const i = this.getAxisMotionValue(t);
    return Tv(this.visualElement, t), i.start(Zx(t, i, 0, n, this.visualElement, !1));
  }
  stopAnimation() {
    lr((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    lr((t) => this.getAxisMotionValue(t).animation?.pause());
  }
  getAnimationState(t) {
    return this.getAxisMotionValue(t).animation?.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`, i = this.visualElement.getProps(), r = i[n];
    return r || this.visualElement.getValue(t, (i.initial ? i.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    lr((n) => {
      const { drag: i } = this.getProps();
      if (!zd(n, i, this.currentDirection))
        return;
      const { projection: r } = this.visualElement, s = this.getAxisMotionValue(n);
      if (r && r.layout) {
        const { min: l, max: c } = r.layout.layoutBox[n];
        s.set(t[n] - _t(l, c, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: i } = this.visualElement;
    if (!Qs(n) || !i || !this.constraints)
      return;
    this.stopAnimation();
    const r = { x: 0, y: 0 };
    lr((l) => {
      const c = this.getAxisMotionValue(l);
      if (c && this.constraints !== !1) {
        const f = c.get();
        r[l] = MQ({ min: f, max: f }, this.constraints[l]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    this.visualElement.current.style.transform = s ? s({}, "") : "none", i.root && i.root.updateScroll(), i.updateLayout(), this.resolveConstraints(), lr((l) => {
      if (!zd(l, t, null))
        return;
      const c = this.getAxisMotionValue(l), { min: f, max: h } = this.constraints[l];
      c.set(_t(f, h, r[l]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    PQ.set(this.visualElement, this);
    const t = this.visualElement.current, n = Yl(t, "pointerdown", (f) => {
      const { drag: h, dragListener: p = !0 } = this.getProps();
      h && p && this.start(f);
    }), i = () => {
      const { dragConstraints: f } = this.getProps();
      Qs(f) && f.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: r } = this.visualElement, s = r.addEventListener("measure", i);
    r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), vt.read(i);
    const l = vu(window, "resize", () => this.scalePositionWithinConstraints()), c = r.addEventListener("didUpdate", (({ delta: f, hasLayoutChanged: h }) => {
      this.isDragging && h && (lr((p) => {
        const m = this.getAxisMotionValue(p);
        m && (this.originPoint[p] += f[p].translate, m.set(m.get() + f[p].translate));
      }), this.visualElement.render());
    }));
    return () => {
      l(), n(), s(), c && c();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: i = !1, dragPropagation: r = !1, dragConstraints: s = !1, dragElastic: l = $v, dragMomentum: c = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: i,
      dragPropagation: r,
      dragConstraints: s,
      dragElastic: l,
      dragMomentum: c
    };
  }
}
function zd(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function LQ(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
class BQ extends da {
  constructor(t) {
    super(t), this.removeGroupControls = cr, this.removeListeners = cr, this.controls = new UQ(t);
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || cr;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const jT = (e) => (t, n) => {
  e && vt.postRender(() => e(t, n));
};
class ZQ extends da {
  constructor() {
    super(...arguments), this.removePointerDownListener = cr;
  }
  onPointerDown(t) {
    this.session = new mD(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: pD(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: i, onPanEnd: r } = this.node.getProps();
    return {
      onSessionStart: jT(t),
      onStart: jT(n),
      onMove: i,
      onEnd: (s, l) => {
        delete this.session, r && vt.postRender(() => r(s, l));
      }
    };
  }
  mount() {
    this.removePointerDownListener = Yl(this.node.current, "pointerdown", (t) => this.onPointerDown(t));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const Fd = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function PT(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const Nl = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (ze.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = PT(e, t.target.x), i = PT(e, t.target.y);
    return `${n}% ${i}%`;
  }
}, VQ = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const i = e, r = oa.parse(e);
    if (r.length > 5)
      return i;
    const s = oa.createTransformer(e), l = typeof r[0] != "number" ? 1 : 0, c = n.x.scale * t.x, f = n.y.scale * t.y;
    r[0 + l] /= c, r[1 + l] /= f;
    const h = _t(c, f, 0.5);
    return typeof r[2 + l] == "number" && (r[2 + l] /= h), typeof r[3 + l] == "number" && (r[3 + l] /= h), s(r);
  }
};
let sg = !1;
class FQ extends $.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: i, layoutId: r } = this.props, { projection: s } = t;
    fW(HQ), s && (n.group && n.group.add(s), i && i.register && r && i.register(s), sg && s.root.didUpdate(), s.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), s.setOptions({
      ...s.options,
      onExitComplete: () => this.safeToRemove()
    })), Fd.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: i, drag: r, isPresent: s } = this.props, { projection: l } = i;
    return l && (l.isPresent = s, sg = !0, r || t.layoutDependency !== n || n === void 0 || t.isPresent !== s ? l.willUpdate() : this.safeToRemove(), t.isPresent !== s && (s ? l.promote() : l.relegate() || vt.postRender(() => {
      const c = l.getStack();
      (!c || !c.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t && (t.root.didUpdate(), Ox.postRender(() => {
      !t.currentAnimation && t.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: i } = this.props, { projection: r } = t;
    sg = !0, r && (r.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(r), i && i.deregister && i.deregister(r));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function vD(e) {
  const [t, n] = aW(), i = $.useContext(JN);
  return C.jsx(FQ, { ...e, layoutGroup: i, switchLayoutGroup: $.useContext(KM), isPresent: t, safeToRemove: n });
}
const HQ = {
  borderRadius: {
    ...Nl,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Nl,
  borderTopRightRadius: Nl,
  borderBottomLeftRadius: Nl,
  borderBottomRightRadius: Nl,
  boxShadow: VQ
};
function qQ(e, t, n) {
  const i = sn(e) ? e : go(e);
  return i.start(Zx("", i, t, n)), i.animation;
}
const GQ = (e, t) => e.depth - t.depth;
class YQ {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    hx(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    px(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(GQ), this.isDirty = !1, this.children.forEach(t);
  }
}
function JQ(e, t) {
  const n = En.now(), i = ({ timestamp: r }) => {
    const s = r - n;
    s >= t && (sa(i), e(s - t));
  };
  return vt.setup(i, !0), () => sa(i);
}
const yD = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], XQ = yD.length, UT = (e) => typeof e == "string" ? parseFloat(e) : e, LT = (e) => typeof e == "number" || ze.test(e);
function KQ(e, t, n, i, r, s) {
  r ? (e.opacity = _t(0, n.opacity ?? 1, WQ(i)), e.opacityExit = _t(t.opacity ?? 1, 0, QQ(i))) : s && (e.opacity = _t(t.opacity ?? 1, n.opacity ?? 1, i));
  for (let l = 0; l < XQ; l++) {
    const c = `border${yD[l]}Radius`;
    let f = BT(t, c), h = BT(n, c);
    if (f === void 0 && h === void 0)
      continue;
    f || (f = 0), h || (h = 0), f === 0 || h === 0 || LT(f) === LT(h) ? (e[c] = Math.max(_t(UT(f), UT(h), i), 0), (Hr.test(h) || Hr.test(f)) && (e[c] += "%")) : e[c] = h;
  }
  (t.rotate || n.rotate) && (e.rotate = _t(t.rotate || 0, n.rotate || 0, i));
}
function BT(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const WQ = /* @__PURE__ */ bD(0, 0.5, sM), QQ = /* @__PURE__ */ bD(0.5, 0.95, cr);
function bD(e, t, n) {
  return (i) => i < e ? 0 : i > t ? 1 : n(/* @__PURE__ */ fu(e, t, i));
}
function ZT(e, t) {
  e.min = t.min, e.max = t.max;
}
function sr(e, t) {
  ZT(e.x, t.x), ZT(e.y, t.y);
}
function VT(e, t) {
  e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin;
}
function FT(e, t, n, i, r) {
  return e -= t, e = wf(e, 1 / n, i), r !== void 0 && (e = wf(e, 1 / r, i)), e;
}
function eee(e, t = 0, n = 1, i = 0.5, r, s = e, l = e) {
  if (Hr.test(t) && (t = parseFloat(t), t = _t(l.min, l.max, t / 100) - l.min), typeof t != "number")
    return;
  let c = _t(s.min, s.max, i);
  e === s && (c -= t), e.min = FT(e.min, t, n, c, r), e.max = FT(e.max, t, n, c, r);
}
function HT(e, t, [n, i, r], s, l) {
  eee(e, t[n], t[i], t[r], t.scale, s, l);
}
const tee = ["x", "scaleX", "originX"], nee = ["y", "scaleY", "originY"];
function qT(e, t, n, i) {
  HT(e.x, t, tee, n ? n.x : void 0, i ? i.x : void 0), HT(e.y, t, nee, n ? n.y : void 0, i ? i.y : void 0);
}
function GT(e) {
  return e.translate === 0 && e.scale === 1;
}
function xD(e) {
  return GT(e.x) && GT(e.y);
}
function YT(e, t) {
  return e.min === t.min && e.max === t.max;
}
function ree(e, t) {
  return YT(e.x, t.x) && YT(e.y, t.y);
}
function JT(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
}
function wD(e, t) {
  return JT(e.x, t.x) && JT(e.y, t.y);
}
function XT(e) {
  return mn(e.x) / mn(e.y);
}
function KT(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
}
class iee {
  constructor() {
    this.members = [];
  }
  add(t) {
    hx(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (px(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((r) => t === r);
    if (n === 0)
      return !1;
    let i;
    for (let r = n; r >= 0; r--) {
      const s = this.members[r];
      if (s.isPresent !== !1) {
        i = s;
        break;
      }
    }
    return i ? (this.promote(i), !0) : !1;
  }
  promote(t, n) {
    const i = this.lead;
    if (t !== i && (this.prevLead = i, this.lead = t, t.show(), i)) {
      i.instance && i.scheduleRender(), t.scheduleRender(), t.resumeFrom = i, n && (t.resumeFrom.preserveOpacity = !0), i.snapshot && (t.snapshot = i.snapshot, t.snapshot.latestValues = i.animationValues || i.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
      const { crossfade: r } = t.options;
      r === !1 && i.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: i } = t;
      n.onExitComplete && n.onExitComplete(), i && i.options.onExitComplete && i.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function aee(e, t, n) {
  let i = "";
  const r = e.x.translate / t.x, s = e.y.translate / t.y, l = n?.z || 0;
  if ((r || s || l) && (i = `translate3d(${r}px, ${s}px, ${l}px) `), (t.x !== 1 || t.y !== 1) && (i += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { transformPerspective: h, rotate: p, rotateX: m, rotateY: y, skewX: b, skewY: x } = n;
    h && (i = `perspective(${h}px) ${i}`), p && (i += `rotate(${p}deg) `), m && (i += `rotateX(${m}deg) `), y && (i += `rotateY(${y}deg) `), b && (i += `skewX(${b}deg) `), x && (i += `skewY(${x}deg) `);
  }
  const c = e.x.scale * t.x, f = e.y.scale * t.y;
  return (c !== 1 || f !== 1) && (i += `scale(${c}, ${f})`), i || "none";
}
const og = ["", "X", "Y", "Z"], see = 1e3;
let oee = 0;
function lg(e, t, n, i) {
  const { latestValues: r } = t;
  r[e] && (n[e] = r[e], t.setStaticValue(e, 0), i && (i[e] = 0));
}
function _D(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: t } = e.options;
  if (!t)
    return;
  const n = oD(t);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: r, layoutId: s } = e.options;
    window.MotionCancelOptimisedAnimation(n, "transform", vt, !(r || s));
  }
  const { parent: i } = e;
  i && !i.hasCheckedOptimisedAppear && _D(i);
}
function SD({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: i, resetTransform: r }) {
  return class {
    constructor(l = {}, c = t?.()) {
      this.id = oee++, this.animationId = 0, this.animationCommitId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(cee), this.nodes.forEach(pee), this.nodes.forEach(mee), this.nodes.forEach(dee);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = l, this.root = c ? c.root || c : this, this.path = c ? [...c.path, c] : [], this.parent = c, this.depth = c ? c.depth + 1 : 0;
      for (let f = 0; f < this.path.length; f++)
        this.path[f].shouldResetTransform = !0;
      this.root === this && (this.nodes = new YQ());
    }
    addEventListener(l, c) {
      return this.eventHandlers.has(l) || this.eventHandlers.set(l, new vx()), this.eventHandlers.get(l).add(c);
    }
    notifyListeners(l, ...c) {
      const f = this.eventHandlers.get(l);
      f && f.notify(...c);
    }
    hasListeners(l) {
      return this.eventHandlers.has(l);
    }
    /**
     * Lifecycles
     */
    mount(l) {
      if (this.instance)
        return;
      this.isSVG = PM(l) && !nW(l), this.instance = l;
      const { layoutId: c, layout: f, visualElement: h } = this.options;
      if (h && !h.current && h.mount(l), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (f || c) && (this.isLayoutDirty = !0), e) {
        let p, m = 0;
        const y = () => this.root.updateBlockedByResize = !1;
        vt.read(() => {
          m = window.innerWidth;
        }), e(l, () => {
          const b = window.innerWidth;
          b !== m && (m = b, this.root.updateBlockedByResize = !0, p && p(), p = JQ(y, 250), Fd.hasAnimatedSinceResize && (Fd.hasAnimatedSinceResize = !1, this.nodes.forEach(eE)));
        });
      }
      c && this.root.registerSharedNode(c, this), this.options.animate !== !1 && h && (c || f) && this.addEventListener("didUpdate", ({ delta: p, hasLayoutChanged: m, hasRelativeLayoutChanged: y, layout: b }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const x = this.options.transition || h.getDefaultTransition() || xee, { onLayoutAnimationStart: w, onLayoutAnimationComplete: k } = h.getProps(), T = !this.targetLayout || !wD(this.targetLayout, b), A = !m && y;
        if (this.options.layoutRoot || this.resumeFrom || A || m && (T || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
          const z = {
            ...Ix(x, "layout"),
            onPlay: w,
            onComplete: k
          };
          (h.shouldReduceMotion || this.options.layoutRoot) && (z.delay = 0, z.type = !1), this.startAnimation(z), this.setAnimationOrigin(p, A);
        } else
          m || eE(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = b;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const l = this.getStack();
      l && l.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), sa(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(gee), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: l } = this.options;
      return l && l.getProps().transformTemplate;
    }
    willUpdate(l = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && _D(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let p = 0; p < this.path.length; p++) {
        const m = this.path[p];
        m.shouldResetTransform = !0, m.updateScroll("snapshot"), m.options.layoutRoot && m.willUpdate(!1);
      }
      const { layoutId: c, layout: f } = this.options;
      if (c === void 0 && !f)
        return;
      const h = this.getTransformTemplate();
      this.prevTransformTemplateValue = h ? h(this.latestValues, "") : void 0, this.updateSnapshot(), l && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(WT);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(QT);
        return;
      }
      this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(hee), this.nodes.forEach(lee), this.nodes.forEach(uee)) : this.nodes.forEach(QT), this.clearAllSnapshots();
      const c = En.now();
      tn.delta = xi(0, 1e3 / 60, c - tn.timestamp), tn.timestamp = c, tn.isProcessing = !0, Xm.update.process(tn), Xm.preRender.process(tn), Xm.render.process(tn), tn.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, Ox.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(fee), this.sharedNodes.forEach(vee);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, vt.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      vt.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !mn(this.snapshot.measuredBox.x) && !mn(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let f = 0; f < this.path.length; f++)
          this.path[f].updateScroll();
      const l = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = Ct(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: c } = this.options;
      c && c.notify("LayoutMeasure", this.layout.layoutBox, l ? l.layoutBox : void 0);
    }
    updateScroll(l = "measure") {
      let c = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === l && (c = !1), c && this.instance) {
        const f = i(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: l,
          isRoot: f,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : f
        };
      }
    }
    resetTransform() {
      if (!r)
        return;
      const l = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, c = this.projectionDelta && !xD(this.projectionDelta), f = this.getTransformTemplate(), h = f ? f(this.latestValues, "") : void 0, p = h !== this.prevTransformTemplateValue;
      l && this.instance && (c || Da(this.latestValues) || p) && (r(this.instance, h), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(l = !0) {
      const c = this.measurePageBox();
      let f = this.removeElementScroll(c);
      return l && (f = this.removeTransform(f)), wee(f), {
        animationId: this.root.animationId,
        measuredBox: c,
        layoutBox: f,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: l } = this.options;
      if (!l)
        return Ct();
      const c = l.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(_ee))) {
        const { scroll: h } = this.root;
        h && (eo(c.x, h.offset.x), eo(c.y, h.offset.y));
      }
      return c;
    }
    removeElementScroll(l) {
      const c = Ct();
      if (sr(c, l), this.scroll?.wasRoot)
        return c;
      for (let f = 0; f < this.path.length; f++) {
        const h = this.path[f], { scroll: p, options: m } = h;
        h !== this.root && p && m.layoutScroll && (p.wasRoot && sr(c, l), eo(c.x, p.offset.x), eo(c.y, p.offset.y));
      }
      return c;
    }
    applyTransform(l, c = !1) {
      const f = Ct();
      sr(f, l);
      for (let h = 0; h < this.path.length; h++) {
        const p = this.path[h];
        !c && p.options.layoutScroll && p.scroll && p !== p.root && to(f, {
          x: -p.scroll.offset.x,
          y: -p.scroll.offset.y
        }), Da(p.latestValues) && to(f, p.latestValues);
      }
      return Da(this.latestValues) && to(f, this.latestValues), f;
    }
    removeTransform(l) {
      const c = Ct();
      sr(c, l);
      for (let f = 0; f < this.path.length; f++) {
        const h = this.path[f];
        if (!h.instance || !Da(h.latestValues))
          continue;
        wv(h.latestValues) && h.updateSnapshot();
        const p = Ct(), m = h.measurePageBox();
        sr(p, m), qT(c, h.latestValues, h.snapshot ? h.snapshot.layoutBox : void 0, p);
      }
      return Da(this.latestValues) && qT(c, this.latestValues), c;
    }
    setTargetDelta(l) {
      this.targetDelta = l, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(l) {
      this.options = {
        ...this.options,
        ...l,
        crossfade: l.crossfade !== void 0 ? l.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== tn.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(l = !1) {
      const c = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = c.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = c.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = c.isSharedProjectionDirty);
      const f = !!this.resumingFrom || this !== c;
      if (!(l || f && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: p, layoutId: m } = this.options;
      if (!(!this.layout || !(p || m))) {
        if (this.resolvedRelativeTargetAt = tn.timestamp, !this.targetDelta && !this.relativeTarget) {
          const y = this.getClosestProjectingParent();
          y && y.layout && this.animationProgress !== 1 ? (this.relativeParent = y, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Ct(), this.relativeTargetOrigin = Ct(), Xl(this.relativeTargetOrigin, this.layout.layoutBox, y.layout.layoutBox), sr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Ct(), this.targetWithTransforms = Ct()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), AQ(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : sr(this.target, this.layout.layoutBox), tD(this.target, this.targetDelta)) : sr(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {
          this.attemptToResolveRelativeTarget = !1;
          const y = this.getClosestProjectingParent();
          y && !!y.resumingFrom == !!this.resumingFrom && !y.options.layoutScroll && y.target && this.animationProgress !== 1 ? (this.relativeParent = y, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Ct(), this.relativeTargetOrigin = Ct(), Xl(this.relativeTargetOrigin, this.target, y.target), sr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || wv(this.parent.latestValues) || eD(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      const l = this.getLead(), c = !!this.resumingFrom || this !== l;
      let f = !0;
      if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (f = !1), c && (this.isSharedProjectionDirty || this.isTransformDirty) && (f = !1), this.resolvedRelativeTargetAt === tn.timestamp && (f = !1), f)
        return;
      const { layout: h, layoutId: p } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(h || p))
        return;
      sr(this.layoutCorrected, this.layout.layoutBox);
      const m = this.treeScale.x, y = this.treeScale.y;
      LW(this.layoutCorrected, this.treeScale, this.path, c), l.layout && !l.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (l.target = l.layout.layoutBox, l.targetWithTransforms = Ct());
      const { target: b } = l;
      if (!b) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (VT(this.prevProjectionDelta.x, this.projectionDelta.x), VT(this.prevProjectionDelta.y, this.projectionDelta.y)), Jl(this.projectionDelta, this.layoutCorrected, b, this.latestValues), (this.treeScale.x !== m || this.treeScale.y !== y || !KT(this.projectionDelta.x, this.prevProjectionDelta.x) || !KT(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", b));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(l = !0) {
      if (this.options.visualElement?.scheduleRender(), l) {
        const c = this.getStack();
        c && c.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = no(), this.projectionDelta = no(), this.projectionDeltaWithTransform = no();
    }
    setAnimationOrigin(l, c = !1) {
      const f = this.snapshot, h = f ? f.latestValues : {}, p = { ...this.latestValues }, m = no();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !c;
      const y = Ct(), b = f ? f.source : void 0, x = this.layout ? this.layout.source : void 0, w = b !== x, k = this.getStack(), T = !k || k.members.length <= 1, A = !!(w && !T && this.options.crossfade === !0 && !this.path.some(bee));
      this.animationProgress = 0;
      let z;
      this.mixTargetDelta = (O) => {
        const M = O / 1e3;
        tE(m.x, l.x, M), tE(m.y, l.y, M), this.setTargetDelta(m), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Xl(y, this.layout.layoutBox, this.relativeParent.layout.layoutBox), yee(this.relativeTarget, this.relativeTargetOrigin, y, M), z && ree(this.relativeTarget, z) && (this.isProjectionDirty = !1), z || (z = Ct()), sr(z, this.relativeTarget)), w && (this.animationValues = p, KQ(p, h, this.latestValues, M, A, T)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = M;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(l) {
      this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (sa(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = vt.update(() => {
        Fd.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = go(0)), this.currentAnimation = qQ(this.motionValue, [0, 1e3], {
          ...l,
          velocity: 0,
          isSync: !0,
          onUpdate: (c) => {
            this.mixTargetDelta(c), l.onUpdate && l.onUpdate(c);
          },
          onStop: () => {
          },
          onComplete: () => {
            l.onComplete && l.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const l = this.getStack();
      l && l.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(see), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const l = this.getLead();
      let { targetWithTransforms: c, target: f, layout: h, latestValues: p } = l;
      if (!(!c || !f || !h)) {
        if (this !== l && this.layout && h && kD(this.options.animationType, this.layout.layoutBox, h.layoutBox)) {
          f = this.target || Ct();
          const m = mn(this.layout.layoutBox.x);
          f.x.min = l.target.x.min, f.x.max = f.x.min + m;
          const y = mn(this.layout.layoutBox.y);
          f.y.min = l.target.y.min, f.y.max = f.y.min + y;
        }
        sr(c, f), to(c, p), Jl(this.projectionDeltaWithTransform, this.layoutCorrected, c, p);
      }
    }
    registerSharedNode(l, c) {
      this.sharedNodes.has(l) || this.sharedNodes.set(l, new iee()), this.sharedNodes.get(l).add(c);
      const h = c.options.initialPromotionConfig;
      c.promote({
        transition: h ? h.transition : void 0,
        preserveFollowOpacity: h && h.shouldPreserveFollowOpacity ? h.shouldPreserveFollowOpacity(c) : void 0
      });
    }
    isLead() {
      const l = this.getStack();
      return l ? l.lead === this : !0;
    }
    getLead() {
      const { layoutId: l } = this.options;
      return l ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId: l } = this.options;
      return l ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId: l } = this.options;
      if (l)
        return this.root.sharedNodes.get(l);
    }
    promote({ needsReset: l, transition: c, preserveFollowOpacity: f } = {}) {
      const h = this.getStack();
      h && h.promote(this, f), l && (this.projectionDelta = void 0, this.needsReset = !0), c && this.setOptions({ transition: c });
    }
    relegate() {
      const l = this.getStack();
      return l ? l.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: l } = this.options;
      if (!l)
        return;
      let c = !1;
      const { latestValues: f } = l;
      if ((f.z || f.rotate || f.rotateX || f.rotateY || f.rotateZ || f.skewX || f.skewY) && (c = !0), !c)
        return;
      const h = {};
      f.z && lg("z", l, h, this.animationValues);
      for (let p = 0; p < og.length; p++)
        lg(`rotate${og[p]}`, l, h, this.animationValues), lg(`skew${og[p]}`, l, h, this.animationValues);
      l.render();
      for (const p in h)
        l.setStaticValue(p, h[p]), this.animationValues && (this.animationValues[p] = h[p]);
      l.scheduleRender();
    }
    applyProjectionStyles(l, c) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        l.visibility = "hidden";
        return;
      }
      const f = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = !1, l.visibility = "", l.opacity = "", l.pointerEvents = Vd(c?.pointerEvents) || "", l.transform = f ? f(this.latestValues, "") : "none";
        return;
      }
      const h = this.getLead();
      if (!this.projectionDelta || !this.layout || !h.target) {
        this.options.layoutId && (l.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, l.pointerEvents = Vd(c?.pointerEvents) || ""), this.hasProjected && !Da(this.latestValues) && (l.transform = f ? f({}, "") : "none", this.hasProjected = !1);
        return;
      }
      l.visibility = "";
      const p = h.animationValues || h.latestValues;
      this.applyTransformsToTarget();
      let m = aee(this.projectionDeltaWithTransform, this.treeScale, p);
      f && (m = f(p, m)), l.transform = m;
      const { x: y, y: b } = this.projectionDelta;
      l.transformOrigin = `${y.origin * 100}% ${b.origin * 100}% 0`, h.animationValues ? l.opacity = h === this ? p.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : p.opacityExit : l.opacity = h === this ? p.opacity !== void 0 ? p.opacity : "" : p.opacityExit !== void 0 ? p.opacityExit : 0;
      for (const x in gu) {
        if (p[x] === void 0)
          continue;
        const { correct: w, applyTo: k, isCSSVariable: T } = gu[x], A = m === "none" ? p[x] : w(p[x], h);
        if (k) {
          const z = k.length;
          for (let O = 0; O < z; O++)
            l[k[O]] = A;
        } else
          T ? this.options.visualElement.renderState.vars[x] = A : l[x] = A;
      }
      this.options.layoutId && (l.pointerEvents = h === this ? Vd(c?.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((l) => l.currentAnimation?.stop()), this.root.nodes.forEach(WT), this.root.sharedNodes.clear();
    }
  };
}
function lee(e) {
  e.updateLayout();
}
function uee(e) {
  const t = e.resumeFrom?.snapshot || e.snapshot;
  if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) {
    const { layoutBox: n, measuredBox: i } = e.layout, { animationType: r } = e.options, s = t.source !== e.layout.source;
    r === "size" ? lr((p) => {
      const m = s ? t.measuredBox[p] : t.layoutBox[p], y = mn(m);
      m.min = n[p].min, m.max = m.min + y;
    }) : kD(r, t.layoutBox, n) && lr((p) => {
      const m = s ? t.measuredBox[p] : t.layoutBox[p], y = mn(n[p]);
      m.max = m.min + y, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[p].max = e.relativeTarget[p].min + y);
    });
    const l = no();
    Jl(l, n, t.layoutBox);
    const c = no();
    s ? Jl(c, e.applyTransform(i, !0), t.measuredBox) : Jl(c, n, t.layoutBox);
    const f = !xD(l);
    let h = !1;
    if (!e.resumeFrom) {
      const p = e.getClosestProjectingParent();
      if (p && !p.resumeFrom) {
        const { snapshot: m, layout: y } = p;
        if (m && y) {
          const b = Ct();
          Xl(b, t.layoutBox, m.layoutBox);
          const x = Ct();
          Xl(x, n, y.layoutBox), wD(b, x) || (h = !0), p.options.layoutRoot && (e.relativeTarget = x, e.relativeTargetOrigin = b, e.relativeParent = p);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: n,
      snapshot: t,
      delta: c,
      layoutDelta: l,
      hasLayoutChanged: f,
      hasRelativeLayoutChanged: h
    });
  } else if (e.isLead()) {
    const { onExitComplete: n } = e.options;
    n && n();
  }
  e.options.transition = void 0;
}
function cee(e) {
  e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function dee(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function fee(e) {
  e.clearSnapshot();
}
function WT(e) {
  e.clearMeasurements();
}
function QT(e) {
  e.isLayoutDirty = !1;
}
function hee(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function eE(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function pee(e) {
  e.resolveTargetDelta();
}
function mee(e) {
  e.calcProjection();
}
function gee(e) {
  e.resetSkewAndRotation();
}
function vee(e) {
  e.removeLeadSnapshot();
}
function tE(e, t, n) {
  e.translate = _t(t.translate, 0, n), e.scale = _t(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function nE(e, t, n, i) {
  e.min = _t(t.min, n.min, i), e.max = _t(t.max, n.max, i);
}
function yee(e, t, n, i) {
  nE(e.x, t.x, n.x, i), nE(e.y, t.y, n.y, i);
}
function bee(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const xee = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, rE = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), iE = rE("applewebkit/") && !rE("chrome/") ? Math.round : cr;
function aE(e) {
  e.min = iE(e.min), e.max = iE(e.max);
}
function wee(e) {
  aE(e.x), aE(e.y);
}
function kD(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !$Q(XT(t), XT(n), 0.2);
}
function _ee(e) {
  return e !== e.root && e.scroll?.wasRoot;
}
const See = SD({
  attachResizeListener: (e, t) => vu(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), ug = {
  current: void 0
}, TD = SD({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!ug.current) {
      const e = new See({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), ug.current = e;
    }
    return ug.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), kee = {
  pan: {
    Feature: ZQ
  },
  drag: {
    Feature: BQ,
    ProjectionNode: TD,
    MeasureLayout: vD
  }
};
function sE(e, t, n) {
  const { props: i } = e;
  e.animationState && i.whileHover && e.animationState.setActive("whileHover", n === "Start");
  const r = "onHover" + n, s = i[r];
  s && vt.postRender(() => s(t, Hu(t)));
}
class Tee extends da {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = KK(t, (n, i) => (sE(this.node, i, "Start"), (r) => sE(this.node, r, "End"))));
  }
  unmount() {
  }
}
class Eee extends da {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Zu(vu(this.node.current, "focus", () => this.onFocus()), vu(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function oE(e, t, n) {
  const { props: i } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled)
    return;
  e.animationState && i.whileTap && e.animationState.setActive("whileTap", n === "Start");
  const r = "onTap" + (n === "End" ? "" : n), s = i[r];
  s && vt.postRender(() => s(t, Hu(t)));
}
class $ee extends da {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = tW(t, (n, i) => (oE(this.node, i, "Start"), (r, { success: s }) => oE(this.node, r, s ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const Av = /* @__PURE__ */ new WeakMap(), cg = /* @__PURE__ */ new WeakMap(), Aee = (e) => {
  const t = Av.get(e.target);
  t && t(e);
}, zee = (e) => {
  e.forEach(Aee);
};
function Iee({ root: e, ...t }) {
  const n = e || document;
  cg.has(n) || cg.set(n, {});
  const i = cg.get(n), r = JSON.stringify(t);
  return i[r] || (i[r] = new IntersectionObserver(zee, { root: e, ...t })), i[r];
}
function Cee(e, t, n) {
  const i = Iee(t);
  return Av.set(e, n), i.observe(e), () => {
    Av.delete(e), i.unobserve(e);
  };
}
const Oee = {
  some: 0,
  all: 1
};
class Ree extends da {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: i, amount: r = "some", once: s } = t, l = {
      root: n ? n.current : void 0,
      rootMargin: i,
      threshold: typeof r == "number" ? r : Oee[r]
    }, c = (f) => {
      const { isIntersecting: h } = f;
      if (this.isInView === h || (this.isInView = h, s && !h && this.hasEnteredView))
        return;
      h && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", h);
      const { onViewportEnter: p, onViewportLeave: m } = this.node.getProps(), y = h ? p : m;
      y && y(f);
    };
    return Cee(this.node.current, l, c);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(Nee(t, n)) && this.startObserver();
  }
  unmount() {
  }
}
function Nee({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const Mee = {
  inView: {
    Feature: Ree
  },
  tap: {
    Feature: $ee
  },
  focus: {
    Feature: Eee
  },
  hover: {
    Feature: Tee
  }
}, Dee = {
  layout: {
    ProjectionNode: TD,
    MeasureLayout: vD
  }
}, jee = {
  ...wQ,
  ...Mee,
  ...kee,
  ...Dee
}, yo = /* @__PURE__ */ jW(jee, XW);
function Pee(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const Uee = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Lee = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Bee = {};
function lE(e, t) {
  return (Bee.jsx ? Lee : Uee).test(e);
}
const Zee = /[ \t\n\f\r]/g;
function Vee(e) {
  return typeof e == "object" ? e.type === "text" ? uE(e.value) : !1 : uE(e);
}
function uE(e) {
  return e.replace(Zee, "") === "";
}
class qu {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, i) {
    this.normal = n, this.property = t, i && (this.space = i);
  }
}
qu.prototype.normal = {};
qu.prototype.property = {};
qu.prototype.space = void 0;
function ED(e, t) {
  const n = {}, i = {};
  for (const r of e)
    Object.assign(n, r.property), Object.assign(i, r.normal);
  return new qu(n, i, t);
}
function zv(e) {
  return e.toLowerCase();
}
class zn {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
zn.prototype.attribute = "";
zn.prototype.booleanish = !1;
zn.prototype.boolean = !1;
zn.prototype.commaOrSpaceSeparated = !1;
zn.prototype.commaSeparated = !1;
zn.prototype.defined = !1;
zn.prototype.mustUseProperty = !1;
zn.prototype.number = !1;
zn.prototype.overloadedBoolean = !1;
zn.prototype.property = "";
zn.prototype.spaceSeparated = !1;
zn.prototype.space = void 0;
let Fee = 0;
const De = ns(), Mt = ns(), Iv = ns(), ue = ns(), ut = ns(), oo = ns(), Ln = ns();
function ns() {
  return 2 ** ++Fee;
}
const Cv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: De,
  booleanish: Mt,
  commaOrSpaceSeparated: Ln,
  commaSeparated: oo,
  number: ue,
  overloadedBoolean: Iv,
  spaceSeparated: ut
}, Symbol.toStringTag, { value: "Module" })), dg = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(Cv)
);
class Vx extends zn {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, i, r) {
    let s = -1;
    if (super(t, n), cE(this, "space", r), typeof i == "number")
      for (; ++s < dg.length; ) {
        const l = dg[s];
        cE(this, dg[s], (i & Cv[l]) === Cv[l]);
      }
  }
}
Vx.prototype.defined = !0;
function cE(e, t, n) {
  n && (e[t] = n);
}
function Io(e) {
  const t = {}, n = {};
  for (const [i, r] of Object.entries(e.properties)) {
    const s = new Vx(
      i,
      e.transform(e.attributes || {}, i),
      r,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(i) && (s.mustUseProperty = !0), t[i] = s, n[zv(i)] = i, n[zv(s.attribute)] = i;
  }
  return new qu(t, n, e.space);
}
const $D = Io({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Mt,
    ariaAutoComplete: null,
    ariaBusy: Mt,
    ariaChecked: Mt,
    ariaColCount: ue,
    ariaColIndex: ue,
    ariaColSpan: ue,
    ariaControls: ut,
    ariaCurrent: null,
    ariaDescribedBy: ut,
    ariaDetails: null,
    ariaDisabled: Mt,
    ariaDropEffect: ut,
    ariaErrorMessage: null,
    ariaExpanded: Mt,
    ariaFlowTo: ut,
    ariaGrabbed: Mt,
    ariaHasPopup: null,
    ariaHidden: Mt,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: ut,
    ariaLevel: ue,
    ariaLive: null,
    ariaModal: Mt,
    ariaMultiLine: Mt,
    ariaMultiSelectable: Mt,
    ariaOrientation: null,
    ariaOwns: ut,
    ariaPlaceholder: null,
    ariaPosInSet: ue,
    ariaPressed: Mt,
    ariaReadOnly: Mt,
    ariaRelevant: null,
    ariaRequired: Mt,
    ariaRoleDescription: ut,
    ariaRowCount: ue,
    ariaRowIndex: ue,
    ariaRowSpan: ue,
    ariaSelected: Mt,
    ariaSetSize: ue,
    ariaSort: null,
    ariaValueMax: ue,
    ariaValueMin: ue,
    ariaValueNow: ue,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function AD(e, t) {
  return t in e ? e[t] : t;
}
function zD(e, t) {
  return AD(e, t.toLowerCase());
}
const Hee = Io({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: oo,
    acceptCharset: ut,
    accessKey: ut,
    action: null,
    allow: null,
    allowFullScreen: De,
    allowPaymentRequest: De,
    allowUserMedia: De,
    alt: null,
    as: null,
    async: De,
    autoCapitalize: null,
    autoComplete: ut,
    autoFocus: De,
    autoPlay: De,
    blocking: ut,
    capture: null,
    charSet: null,
    checked: De,
    cite: null,
    className: ut,
    cols: ue,
    colSpan: null,
    content: null,
    contentEditable: Mt,
    controls: De,
    controlsList: ut,
    coords: ue | oo,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: De,
    defer: De,
    dir: null,
    dirName: null,
    disabled: De,
    download: Iv,
    draggable: Mt,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: De,
    formTarget: null,
    headers: ut,
    height: ue,
    hidden: Iv,
    high: ue,
    href: null,
    hrefLang: null,
    htmlFor: ut,
    httpEquiv: ut,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: De,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: De,
    itemId: null,
    itemProp: ut,
    itemRef: ut,
    itemScope: De,
    itemType: ut,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: De,
    low: ue,
    manifest: null,
    max: null,
    maxLength: ue,
    media: null,
    method: null,
    min: null,
    minLength: ue,
    multiple: De,
    muted: De,
    name: null,
    nonce: null,
    noModule: De,
    noValidate: De,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: De,
    optimum: ue,
    pattern: null,
    ping: ut,
    placeholder: null,
    playsInline: De,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: De,
    referrerPolicy: null,
    rel: ut,
    required: De,
    reversed: De,
    rows: ue,
    rowSpan: ue,
    sandbox: ut,
    scope: null,
    scoped: De,
    seamless: De,
    selected: De,
    shadowRootClonable: De,
    shadowRootDelegatesFocus: De,
    shadowRootMode: null,
    shape: null,
    size: ue,
    sizes: null,
    slot: null,
    span: ue,
    spellCheck: Mt,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: ue,
    step: null,
    style: null,
    tabIndex: ue,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: De,
    useMap: null,
    value: Mt,
    width: ue,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: ut,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: ue,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: ue,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: De,
    // Lists. Use CSS to reduce space between items instead
    declare: De,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: ue,
    // `<img>` and `<object>`
    leftMargin: ue,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: ue,
    // `<body>`
    marginWidth: ue,
    // `<body>`
    noResize: De,
    // `<frame>`
    noHref: De,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: De,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: De,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: ue,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Mt,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: ue,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: ue,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: De,
    disableRemotePlayback: De,
    prefix: null,
    property: null,
    results: ue,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: zD
}), qee = Io({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: Ln,
    accentHeight: ue,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: ue,
    amplitude: ue,
    arabicForm: null,
    ascent: ue,
    attributeName: null,
    attributeType: null,
    azimuth: ue,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: ue,
    by: null,
    calcMode: null,
    capHeight: ue,
    className: ut,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: ue,
    diffuseConstant: ue,
    direction: null,
    display: null,
    dur: null,
    divisor: ue,
    dominantBaseline: null,
    download: De,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: ue,
    enableBackground: null,
    end: null,
    event: null,
    exponent: ue,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: ue,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: oo,
    g2: oo,
    glyphName: oo,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: ue,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: ue,
    horizOriginX: ue,
    horizOriginY: ue,
    id: null,
    ideographic: ue,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: ue,
    k: ue,
    k1: ue,
    k2: ue,
    k3: ue,
    k4: ue,
    kernelMatrix: Ln,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: ue,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: ue,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: ue,
    overlineThickness: ue,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: ue,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: ut,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: ue,
    pointsAtY: ue,
    pointsAtZ: ue,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Ln,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Ln,
    rev: Ln,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Ln,
    requiredFeatures: Ln,
    requiredFonts: Ln,
    requiredFormats: Ln,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: ue,
    specularExponent: ue,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: ue,
    strikethroughThickness: ue,
    string: null,
    stroke: null,
    strokeDashArray: Ln,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: ue,
    strokeOpacity: ue,
    strokeWidth: null,
    style: null,
    surfaceScale: ue,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Ln,
    tabIndex: ue,
    tableValues: null,
    target: null,
    targetX: ue,
    targetY: ue,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Ln,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: ue,
    underlineThickness: ue,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: ue,
    values: null,
    vAlphabetic: ue,
    vMathematical: ue,
    vectorEffect: null,
    vHanging: ue,
    vIdeographic: ue,
    version: null,
    vertAdvY: ue,
    vertOriginX: ue,
    vertOriginY: ue,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: ue,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: AD
}), ID = Io({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), CD = Io({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: zD
}), OD = Io({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), Gee = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, Yee = /[A-Z]/g, dE = /-[a-z]/g, Jee = /^data[-\w.:]+$/i;
function Xee(e, t) {
  const n = zv(t);
  let i = t, r = zn;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && Jee.test(t)) {
    if (t.charAt(4) === "-") {
      const s = t.slice(5).replace(dE, Wee);
      i = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = t.slice(4);
      if (!dE.test(s)) {
        let l = s.replace(Yee, Kee);
        l.charAt(0) !== "-" && (l = "-" + l), t = "data" + l;
      }
    }
    r = Vx;
  }
  return new r(i, t);
}
function Kee(e) {
  return "-" + e.toLowerCase();
}
function Wee(e) {
  return e.charAt(1).toUpperCase();
}
const Qee = ED([$D, Hee, ID, CD, OD], "html"), Fx = ED([$D, qee, ID, CD, OD], "svg");
function ete(e) {
  return e.join(" ").trim();
}
var Hs = {}, fg, fE;
function tte() {
  if (fE) return fg;
  fE = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, i = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, r = /^:\s*/, s = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, l = /^[;\s]*/, c = /^\s+|\s+$/g, f = `
`, h = "/", p = "*", m = "", y = "comment", b = "declaration";
  fg = function(w, k) {
    if (typeof w != "string")
      throw new TypeError("First argument must be a string");
    if (!w) return [];
    k = k || {};
    var T = 1, A = 1;
    function z(le) {
      var se = le.match(t);
      se && (T += se.length);
      var ce = le.lastIndexOf(f);
      A = ~ce ? le.length - ce : A + le.length;
    }
    function O() {
      var le = { line: T, column: A };
      return function(se) {
        return se.position = new M(le), Z(), se;
      };
    }
    function M(le) {
      this.start = le, this.end = { line: T, column: A }, this.source = k.source;
    }
    M.prototype.content = w;
    function N(le) {
      var se = new Error(
        k.source + ":" + T + ":" + A + ": " + le
      );
      if (se.reason = le, se.filename = k.source, se.line = T, se.column = A, se.source = w, !k.silent) throw se;
    }
    function U(le) {
      var se = le.exec(w);
      if (se) {
        var ce = se[0];
        return z(ce), w = w.slice(ce.length), se;
      }
    }
    function Z() {
      U(n);
    }
    function re(le) {
      var se;
      for (le = le || []; se = D(); )
        se !== !1 && le.push(se);
      return le;
    }
    function D() {
      var le = O();
      if (!(h != w.charAt(0) || p != w.charAt(1))) {
        for (var se = 2; m != w.charAt(se) && (p != w.charAt(se) || h != w.charAt(se + 1)); )
          ++se;
        if (se += 2, m === w.charAt(se - 1))
          return N("End of comment missing");
        var ce = w.slice(2, se - 2);
        return A += 2, z(ce), w = w.slice(se), A += 2, le({
          type: y,
          comment: ce
        });
      }
    }
    function ae() {
      var le = O(), se = U(i);
      if (se) {
        if (D(), !U(r)) return N("property missing ':'");
        var ce = U(s), L = le({
          type: b,
          property: x(se[0].replace(e, m)),
          value: ce ? x(ce[0].replace(e, m)) : m
        });
        return U(l), L;
      }
    }
    function ie() {
      var le = [];
      re(le);
      for (var se; se = ae(); )
        se !== !1 && (le.push(se), re(le));
      return le;
    }
    return Z(), ie();
  };
  function x(w) {
    return w ? w.replace(c, m) : m;
  }
  return fg;
}
var hE;
function nte() {
  if (hE) return Hs;
  hE = 1;
  var e = Hs && Hs.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(Hs, "__esModule", { value: !0 }), Hs.default = n;
  var t = e(tte());
  function n(i, r) {
    var s = null;
    if (!i || typeof i != "string")
      return s;
    var l = (0, t.default)(i), c = typeof r == "function";
    return l.forEach(function(f) {
      if (f.type === "declaration") {
        var h = f.property, p = f.value;
        c ? r(h, p, f) : p && (s = s || {}, s[h] = p);
      }
    }), s;
  }
  return Hs;
}
var Ml = {}, pE;
function rte() {
  if (pE) return Ml;
  pE = 1, Object.defineProperty(Ml, "__esModule", { value: !0 }), Ml.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, i = /^-(webkit|moz|ms|o|khtml)-/, r = /^-(ms)-/, s = function(h) {
    return !h || n.test(h) || e.test(h);
  }, l = function(h, p) {
    return p.toUpperCase();
  }, c = function(h, p) {
    return "".concat(p, "-");
  }, f = function(h, p) {
    return p === void 0 && (p = {}), s(h) ? h : (h = h.toLowerCase(), p.reactCompat ? h = h.replace(r, c) : h = h.replace(i, c), h.replace(t, l));
  };
  return Ml.camelCase = f, Ml;
}
var Dl, mE;
function ite() {
  if (mE) return Dl;
  mE = 1;
  var e = Dl && Dl.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  }, t = e(nte()), n = rte();
  function i(r, s) {
    var l = {};
    return !r || typeof r != "string" || (0, t.default)(r, function(c, f) {
      c && f && (l[(0, n.camelCase)(c, s)] = f);
    }), l;
  }
  return i.default = i, Dl = i, Dl;
}
var ate = ite();
const ste = /* @__PURE__ */ la(ate), RD = ND("end"), Hx = ND("start");
function ND(e) {
  return t;
  function t(n) {
    const i = n && n.position && n.position[e] || {};
    if (typeof i.line == "number" && i.line > 0 && typeof i.column == "number" && i.column > 0)
      return {
        line: i.line,
        column: i.column,
        offset: typeof i.offset == "number" && i.offset > -1 ? i.offset : void 0
      };
  }
}
function ote(e) {
  const t = Hx(e), n = RD(e);
  if (t && n)
    return { start: t, end: n };
}
function Kl(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? gE(e.position) : "start" in e || "end" in e ? gE(e) : "line" in e || "column" in e ? Ov(e) : "";
}
function Ov(e) {
  return vE(e && e.line) + ":" + vE(e && e.column);
}
function gE(e) {
  return Ov(e && e.start) + "-" + Ov(e && e.end);
}
function vE(e) {
  return e && typeof e == "number" ? e : 1;
}
class ln extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, i) {
    super(), typeof n == "string" && (i = n, n = void 0);
    let r = "", s = {}, l = !1;
    if (n && ("line" in n && "column" in n ? s = { place: n } : "start" in n && "end" in n ? s = { place: n } : "type" in n ? s = {
      ancestors: [n],
      place: n.position
    } : s = { ...n }), typeof t == "string" ? r = t : !s.cause && t && (l = !0, r = t.message, s.cause = t), !s.ruleId && !s.source && typeof i == "string") {
      const f = i.indexOf(":");
      f === -1 ? s.ruleId = i : (s.source = i.slice(0, f), s.ruleId = i.slice(f + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const f = s.ancestors[s.ancestors.length - 1];
      f && (s.place = f.position);
    }
    const c = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = c ? c.column : void 0, this.fatal = void 0, this.file = "", this.message = r, this.line = c ? c.line : void 0, this.name = Kl(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = l && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
ln.prototype.file = "";
ln.prototype.name = "";
ln.prototype.reason = "";
ln.prototype.message = "";
ln.prototype.stack = "";
ln.prototype.column = void 0;
ln.prototype.line = void 0;
ln.prototype.ancestors = void 0;
ln.prototype.cause = void 0;
ln.prototype.fatal = void 0;
ln.prototype.place = void 0;
ln.prototype.ruleId = void 0;
ln.prototype.source = void 0;
const qx = {}.hasOwnProperty, lte = /* @__PURE__ */ new Map(), ute = /[A-Z]/g, cte = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), dte = /* @__PURE__ */ new Set(["td", "th"]), MD = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function fte(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let i;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    i = xte(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    i = bte(n, t.jsx, t.jsxs);
  }
  const r = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: i,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? Fx : Qee,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, s = DD(r, e, void 0);
  return s && typeof s != "string" ? s : r.create(
    e,
    r.Fragment,
    { children: s || void 0 },
    void 0
  );
}
function DD(e, t, n) {
  if (t.type === "element")
    return hte(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return pte(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return gte(e, t, n);
  if (t.type === "mdxjsEsm")
    return mte(e, t);
  if (t.type === "root")
    return vte(e, t, n);
  if (t.type === "text")
    return yte(e, t);
}
function hte(e, t, n) {
  const i = e.schema;
  let r = i;
  t.tagName.toLowerCase() === "svg" && i.space === "html" && (r = Fx, e.schema = r), e.ancestors.push(t);
  const s = PD(e, t.tagName, !1), l = wte(e, t);
  let c = Yx(e, t);
  return cte.has(t.tagName) && (c = c.filter(function(f) {
    return typeof f == "string" ? !Vee(f) : !0;
  })), jD(e, l, s, t), Gx(l, c), e.ancestors.pop(), e.schema = i, e.create(t, s, l, n);
}
function pte(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const i = t.data.estree.body[0];
    return i.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(i.expression);
  }
  yu(e, t.position);
}
function mte(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  yu(e, t.position);
}
function gte(e, t, n) {
  const i = e.schema;
  let r = i;
  t.name === "svg" && i.space === "html" && (r = Fx, e.schema = r), e.ancestors.push(t);
  const s = t.name === null ? e.Fragment : PD(e, t.name, !0), l = _te(e, t), c = Yx(e, t);
  return jD(e, l, s, t), Gx(l, c), e.ancestors.pop(), e.schema = i, e.create(t, s, l, n);
}
function vte(e, t, n) {
  const i = {};
  return Gx(i, Yx(e, t)), e.create(t, e.Fragment, i, n);
}
function yte(e, t) {
  return t.value;
}
function jD(e, t, n, i) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = i);
}
function Gx(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function bte(e, t, n) {
  return i;
  function i(r, s, l, c) {
    const h = Array.isArray(l.children) ? n : t;
    return c ? h(s, l, c) : h(s, l);
  }
}
function xte(e, t) {
  return n;
  function n(i, r, s, l) {
    const c = Array.isArray(s.children), f = Hx(i);
    return t(
      r,
      s,
      l,
      c,
      {
        columnNumber: f ? f.column - 1 : void 0,
        fileName: e,
        lineNumber: f ? f.line : void 0
      },
      void 0
    );
  }
}
function wte(e, t) {
  const n = {};
  let i, r;
  for (r in t.properties)
    if (r !== "children" && qx.call(t.properties, r)) {
      const s = Ste(e, r, t.properties[r]);
      if (s) {
        const [l, c] = s;
        e.tableCellAlignToStyle && l === "align" && typeof c == "string" && dte.has(t.tagName) ? i = c : n[l] = c;
      }
    }
  if (i) {
    const s = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    s[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = i;
  }
  return n;
}
function _te(e, t) {
  const n = {};
  for (const i of t.attributes)
    if (i.type === "mdxJsxExpressionAttribute")
      if (i.data && i.data.estree && e.evaluater) {
        const s = i.data.estree.body[0];
        s.type;
        const l = s.expression;
        l.type;
        const c = l.properties[0];
        c.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(c.argument)
        );
      } else
        yu(e, t.position);
    else {
      const r = i.name;
      let s;
      if (i.value && typeof i.value == "object")
        if (i.value.data && i.value.data.estree && e.evaluater) {
          const c = i.value.data.estree.body[0];
          c.type, s = e.evaluater.evaluateExpression(c.expression);
        } else
          yu(e, t.position);
      else
        s = i.value === null ? !0 : i.value;
      n[r] = /** @type {Props[keyof Props]} */
      s;
    }
  return n;
}
function Yx(e, t) {
  const n = [];
  let i = -1;
  const r = e.passKeys ? /* @__PURE__ */ new Map() : lte;
  for (; ++i < t.children.length; ) {
    const s = t.children[i];
    let l;
    if (e.passKeys) {
      const f = s.type === "element" ? s.tagName : s.type === "mdxJsxFlowElement" || s.type === "mdxJsxTextElement" ? s.name : void 0;
      if (f) {
        const h = r.get(f) || 0;
        l = f + "-" + h, r.set(f, h + 1);
      }
    }
    const c = DD(e, s, l);
    c !== void 0 && n.push(c);
  }
  return n;
}
function Ste(e, t, n) {
  const i = Xee(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = i.commaSeparated ? Pee(n) : ete(n)), i.property === "style") {
      let r = typeof n == "object" ? n : kte(e, String(n));
      return e.stylePropertyNameCase === "css" && (r = Tte(r)), ["style", r];
    }
    return [
      e.elementAttributeNameCase === "react" && i.space ? Gee[i.property] || i.property : i.attribute,
      n
    ];
  }
}
function kte(e, t) {
  try {
    return ste(t, { reactCompat: !0 });
  } catch (n) {
    if (e.ignoreInvalidStyle)
      return {};
    const i = (
      /** @type {Error} */
      n
    ), r = new ln("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: i,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw r.file = e.filePath || void 0, r.url = MD + "#cannot-parse-style-attribute", r;
  }
}
function PD(e, t, n) {
  let i;
  if (!n)
    i = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const r = t.split(".");
    let s = -1, l;
    for (; ++s < r.length; ) {
      const c = lE(r[s]) ? { type: "Identifier", name: r[s] } : { type: "Literal", value: r[s] };
      l = l ? {
        type: "MemberExpression",
        object: l,
        property: c,
        computed: !!(s && c.type === "Literal"),
        optional: !1
      } : c;
    }
    i = l;
  } else
    i = lE(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (i.type === "Literal") {
    const r = (
      /** @type {string | number} */
      i.value
    );
    return qx.call(e.components, r) ? e.components[r] : r;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(i);
  yu(e);
}
function yu(e, t) {
  const n = new ln(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = MD + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function Tte(e) {
  const t = {};
  let n;
  for (n in e)
    qx.call(e, n) && (t[Ete(n)] = e[n]);
  return t;
}
function Ete(e) {
  let t = e.replace(ute, $te);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function $te(e) {
  return "-" + e.toLowerCase();
}
const hg = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, Ate = {};
function Jx(e, t) {
  const n = Ate, i = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, r = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return UD(e, i, r);
}
function UD(e, t, n) {
  if (zte(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return yE(e.children, t, n);
  }
  return Array.isArray(e) ? yE(e, t, n) : "";
}
function yE(e, t, n) {
  const i = [];
  let r = -1;
  for (; ++r < e.length; )
    i[r] = UD(e[r], t, n);
  return i.join("");
}
function zte(e) {
  return !!(e && typeof e == "object");
}
const bE = document.createElement("i");
function Xx(e) {
  const t = "&" + e + ";";
  bE.innerHTML = t;
  const n = bE.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n
  );
}
function Hn(e, t, n, i) {
  const r = e.length;
  let s = 0, l;
  if (t < 0 ? t = -t > r ? 0 : r + t : t = t > r ? r : t, n = n > 0 ? n : 0, i.length < 1e4)
    l = Array.from(i), l.unshift(t, n), e.splice(...l);
  else
    for (n && e.splice(t, n); s < i.length; )
      l = i.slice(s, s + 1e4), l.unshift(t, 0), e.splice(...l), s += 1e4, t += 1e4;
}
function ur(e, t) {
  return e.length > 0 ? (Hn(e, e.length, 0, t), e) : t;
}
const xE = {}.hasOwnProperty;
function LD(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    Ite(t, e[n]);
  return t;
}
function Ite(e, t) {
  let n;
  for (n in t) {
    const r = (xE.call(e, n) ? e[n] : void 0) || (e[n] = {}), s = t[n];
    let l;
    if (s)
      for (l in s) {
        xE.call(r, l) || (r[l] = []);
        const c = s[l];
        Cte(
          // @ts-expect-error Looks like a list.
          r[l],
          Array.isArray(c) ? c : c ? [c] : []
        );
      }
  }
}
function Cte(e, t) {
  let n = -1;
  const i = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : i).push(t[n]);
  Hn(e, 0, 0, i);
}
function BD(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function Sr(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const pn = fa(/[A-Za-z]/), on = fa(/[\dA-Za-z]/), Ote = fa(/[#-'*+\--9=?A-Z^-~]/);
function _f(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const Rv = fa(/\d/), Rte = fa(/[\dA-Fa-f]/), Nte = fa(/[!-/:-@[-`{-~]/);
function Se(e) {
  return e !== null && e < -2;
}
function ot(e) {
  return e !== null && (e < 0 || e === 32);
}
function Fe(e) {
  return e === -2 || e === -1 || e === 32;
}
const uh = fa(new RegExp("\\p{P}|\\p{S}", "u")), Ka = fa(/\s/);
function fa(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function Co(e) {
  const t = [];
  let n = -1, i = 0, r = 0;
  for (; ++n < e.length; ) {
    const s = e.charCodeAt(n);
    let l = "";
    if (s === 37 && on(e.charCodeAt(n + 1)) && on(e.charCodeAt(n + 2)))
      r = 2;
    else if (s < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (l = String.fromCharCode(s));
    else if (s > 55295 && s < 57344) {
      const c = e.charCodeAt(n + 1);
      s < 56320 && c > 56319 && c < 57344 ? (l = String.fromCharCode(s, c), r = 1) : l = "";
    } else
      l = String.fromCharCode(s);
    l && (t.push(e.slice(i, n), encodeURIComponent(l)), i = n + r + 1, l = ""), r && (n += r, r = 0);
  }
  return t.join("") + e.slice(i);
}
function Ge(e, t, n, i) {
  const r = i ? i - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return l;
  function l(f) {
    return Fe(f) ? (e.enter(n), c(f)) : t(f);
  }
  function c(f) {
    return Fe(f) && s++ < r ? (e.consume(f), c) : (e.exit(n), t(f));
  }
}
const Mte = {
  tokenize: Dte
};
function Dte(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, i, r);
  let n;
  return t;
  function i(c) {
    if (c === null) {
      e.consume(c);
      return;
    }
    return e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), Ge(e, t, "linePrefix");
  }
  function r(c) {
    return e.enter("paragraph"), s(c);
  }
  function s(c) {
    const f = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = f), n = f, l(c);
  }
  function l(c) {
    if (c === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(c);
      return;
    }
    return Se(c) ? (e.consume(c), e.exit("chunkText"), s) : (e.consume(c), l);
  }
}
const jte = {
  tokenize: Pte
}, wE = {
  tokenize: Ute
};
function Pte(e) {
  const t = this, n = [];
  let i = 0, r, s, l;
  return c;
  function c(z) {
    if (i < n.length) {
      const O = n[i];
      return t.containerState = O[1], e.attempt(O[0].continuation, f, h)(z);
    }
    return h(z);
  }
  function f(z) {
    if (i++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, r && A();
      const O = t.events.length;
      let M = O, N;
      for (; M--; )
        if (t.events[M][0] === "exit" && t.events[M][1].type === "chunkFlow") {
          N = t.events[M][1].end;
          break;
        }
      T(i);
      let U = O;
      for (; U < t.events.length; )
        t.events[U][1].end = {
          ...N
        }, U++;
      return Hn(t.events, M + 1, 0, t.events.slice(O)), t.events.length = U, h(z);
    }
    return c(z);
  }
  function h(z) {
    if (i === n.length) {
      if (!r)
        return y(z);
      if (r.currentConstruct && r.currentConstruct.concrete)
        return x(z);
      t.interrupt = !!(r.currentConstruct && !r._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(wE, p, m)(z);
  }
  function p(z) {
    return r && A(), T(i), y(z);
  }
  function m(z) {
    return t.parser.lazy[t.now().line] = i !== n.length, l = t.now().offset, x(z);
  }
  function y(z) {
    return t.containerState = {}, e.attempt(wE, b, x)(z);
  }
  function b(z) {
    return i++, n.push([t.currentConstruct, t.containerState]), y(z);
  }
  function x(z) {
    if (z === null) {
      r && A(), T(0), e.consume(z);
      return;
    }
    return r = r || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: r,
      contentType: "flow",
      previous: s
    }), w(z);
  }
  function w(z) {
    if (z === null) {
      k(e.exit("chunkFlow"), !0), T(0), e.consume(z);
      return;
    }
    return Se(z) ? (e.consume(z), k(e.exit("chunkFlow")), i = 0, t.interrupt = void 0, c) : (e.consume(z), w);
  }
  function k(z, O) {
    const M = t.sliceStream(z);
    if (O && M.push(null), z.previous = s, s && (s.next = z), s = z, r.defineSkip(z.start), r.write(M), t.parser.lazy[z.start.line]) {
      let N = r.events.length;
      for (; N--; )
        if (
          // The token starts before the line ending
          r.events[N][1].start.offset < l && // and either is not ended yet
          (!r.events[N][1].end || // or ends after it.
          r.events[N][1].end.offset > l)
        )
          return;
      const U = t.events.length;
      let Z = U, re, D;
      for (; Z--; )
        if (t.events[Z][0] === "exit" && t.events[Z][1].type === "chunkFlow") {
          if (re) {
            D = t.events[Z][1].end;
            break;
          }
          re = !0;
        }
      for (T(i), N = U; N < t.events.length; )
        t.events[N][1].end = {
          ...D
        }, N++;
      Hn(t.events, Z + 1, 0, t.events.slice(U)), t.events.length = N;
    }
  }
  function T(z) {
    let O = n.length;
    for (; O-- > z; ) {
      const M = n[O];
      t.containerState = M[1], M[0].exit.call(t, e);
    }
    n.length = z;
  }
  function A() {
    r.write([null]), s = void 0, r = void 0, t.containerState._closeFlow = void 0;
  }
}
function Ute(e, t, n) {
  return Ge(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function bo(e) {
  if (e === null || ot(e) || Ka(e))
    return 1;
  if (uh(e))
    return 2;
}
function ch(e, t, n) {
  const i = [];
  let r = -1;
  for (; ++r < e.length; ) {
    const s = e[r].resolveAll;
    s && !i.includes(s) && (t = s(t, n), i.push(s));
  }
  return t;
}
const Nv = {
  name: "attention",
  resolveAll: Lte,
  tokenize: Bte
};
function Lte(e, t) {
  let n = -1, i, r, s, l, c, f, h, p;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (i = n; i--; )
        if (e[i][0] === "exit" && e[i][1].type === "attentionSequence" && e[i][1]._open && // If the markers are the same:
        t.sliceSerialize(e[i][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[i][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[i][1].end.offset - e[i][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          f = e[i][1].end.offset - e[i][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const m = {
            ...e[i][1].end
          }, y = {
            ...e[n][1].start
          };
          _E(m, -f), _E(y, f), l = {
            type: f > 1 ? "strongSequence" : "emphasisSequence",
            start: m,
            end: {
              ...e[i][1].end
            }
          }, c = {
            type: f > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: y
          }, s = {
            type: f > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[i][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, r = {
            type: f > 1 ? "strong" : "emphasis",
            start: {
              ...l.start
            },
            end: {
              ...c.end
            }
          }, e[i][1].end = {
            ...l.start
          }, e[n][1].start = {
            ...c.end
          }, h = [], e[i][1].end.offset - e[i][1].start.offset && (h = ur(h, [["enter", e[i][1], t], ["exit", e[i][1], t]])), h = ur(h, [["enter", r, t], ["enter", l, t], ["exit", l, t], ["enter", s, t]]), h = ur(h, ch(t.parser.constructs.insideSpan.null, e.slice(i + 1, n), t)), h = ur(h, [["exit", s, t], ["enter", c, t], ["exit", c, t], ["exit", r, t]]), e[n][1].end.offset - e[n][1].start.offset ? (p = 2, h = ur(h, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : p = 0, Hn(e, i - 1, n - i + 3, h), n = i + h.length - p - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function Bte(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, i = this.previous, r = bo(i);
  let s;
  return l;
  function l(f) {
    return s = f, e.enter("attentionSequence"), c(f);
  }
  function c(f) {
    if (f === s)
      return e.consume(f), c;
    const h = e.exit("attentionSequence"), p = bo(f), m = !p || p === 2 && r || n.includes(f), y = !r || r === 2 && p || n.includes(i);
    return h._open = !!(s === 42 ? m : m && (r || !y)), h._close = !!(s === 42 ? y : y && (p || !m)), t(f);
  }
}
function _E(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const Zte = {
  name: "autolink",
  tokenize: Vte
};
function Vte(e, t, n) {
  let i = 0;
  return r;
  function r(b) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(b), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), s;
  }
  function s(b) {
    return pn(b) ? (e.consume(b), l) : b === 64 ? n(b) : h(b);
  }
  function l(b) {
    return b === 43 || b === 45 || b === 46 || on(b) ? (i = 1, c(b)) : h(b);
  }
  function c(b) {
    return b === 58 ? (e.consume(b), i = 0, f) : (b === 43 || b === 45 || b === 46 || on(b)) && i++ < 32 ? (e.consume(b), c) : (i = 0, h(b));
  }
  function f(b) {
    return b === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(b), e.exit("autolinkMarker"), e.exit("autolink"), t) : b === null || b === 32 || b === 60 || _f(b) ? n(b) : (e.consume(b), f);
  }
  function h(b) {
    return b === 64 ? (e.consume(b), p) : Ote(b) ? (e.consume(b), h) : n(b);
  }
  function p(b) {
    return on(b) ? m(b) : n(b);
  }
  function m(b) {
    return b === 46 ? (e.consume(b), i = 0, p) : b === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(b), e.exit("autolinkMarker"), e.exit("autolink"), t) : y(b);
  }
  function y(b) {
    if ((b === 45 || on(b)) && i++ < 63) {
      const x = b === 45 ? y : m;
      return e.consume(b), x;
    }
    return n(b);
  }
}
const Gu = {
  partial: !0,
  tokenize: Fte
};
function Fte(e, t, n) {
  return i;
  function i(s) {
    return Fe(s) ? Ge(e, r, "linePrefix")(s) : r(s);
  }
  function r(s) {
    return s === null || Se(s) ? t(s) : n(s);
  }
}
const ZD = {
  continuation: {
    tokenize: qte
  },
  exit: Gte,
  name: "blockQuote",
  tokenize: Hte
};
function Hte(e, t, n) {
  const i = this;
  return r;
  function r(l) {
    if (l === 62) {
      const c = i.containerState;
      return c.open || (e.enter("blockQuote", {
        _container: !0
      }), c.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(l), e.exit("blockQuoteMarker"), s;
    }
    return n(l);
  }
  function s(l) {
    return Fe(l) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(l), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(l));
  }
}
function qte(e, t, n) {
  const i = this;
  return r;
  function r(l) {
    return Fe(l) ? Ge(e, s, "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(l) : s(l);
  }
  function s(l) {
    return e.attempt(ZD, t, n)(l);
  }
}
function Gte(e) {
  e.exit("blockQuote");
}
const VD = {
  name: "characterEscape",
  tokenize: Yte
};
function Yte(e, t, n) {
  return i;
  function i(s) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(s), e.exit("escapeMarker"), r;
  }
  function r(s) {
    return Nte(s) ? (e.enter("characterEscapeValue"), e.consume(s), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(s);
  }
}
const FD = {
  name: "characterReference",
  tokenize: Jte
};
function Jte(e, t, n) {
  const i = this;
  let r = 0, s, l;
  return c;
  function c(m) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(m), e.exit("characterReferenceMarker"), f;
  }
  function f(m) {
    return m === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(m), e.exit("characterReferenceMarkerNumeric"), h) : (e.enter("characterReferenceValue"), s = 31, l = on, p(m));
  }
  function h(m) {
    return m === 88 || m === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(m), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), s = 6, l = Rte, p) : (e.enter("characterReferenceValue"), s = 7, l = Rv, p(m));
  }
  function p(m) {
    if (m === 59 && r) {
      const y = e.exit("characterReferenceValue");
      return l === on && !Xx(i.sliceSerialize(y)) ? n(m) : (e.enter("characterReferenceMarker"), e.consume(m), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return l(m) && r++ < s ? (e.consume(m), p) : n(m);
  }
}
const SE = {
  partial: !0,
  tokenize: Kte
}, kE = {
  concrete: !0,
  name: "codeFenced",
  tokenize: Xte
};
function Xte(e, t, n) {
  const i = this, r = {
    partial: !0,
    tokenize: M
  };
  let s = 0, l = 0, c;
  return f;
  function f(N) {
    return h(N);
  }
  function h(N) {
    const U = i.events[i.events.length - 1];
    return s = U && U[1].type === "linePrefix" ? U[2].sliceSerialize(U[1], !0).length : 0, c = N, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), p(N);
  }
  function p(N) {
    return N === c ? (l++, e.consume(N), p) : l < 3 ? n(N) : (e.exit("codeFencedFenceSequence"), Fe(N) ? Ge(e, m, "whitespace")(N) : m(N));
  }
  function m(N) {
    return N === null || Se(N) ? (e.exit("codeFencedFence"), i.interrupt ? t(N) : e.check(SE, w, O)(N)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), y(N));
  }
  function y(N) {
    return N === null || Se(N) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), m(N)) : Fe(N) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Ge(e, b, "whitespace")(N)) : N === 96 && N === c ? n(N) : (e.consume(N), y);
  }
  function b(N) {
    return N === null || Se(N) ? m(N) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), x(N));
  }
  function x(N) {
    return N === null || Se(N) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), m(N)) : N === 96 && N === c ? n(N) : (e.consume(N), x);
  }
  function w(N) {
    return e.attempt(r, O, k)(N);
  }
  function k(N) {
    return e.enter("lineEnding"), e.consume(N), e.exit("lineEnding"), T;
  }
  function T(N) {
    return s > 0 && Fe(N) ? Ge(e, A, "linePrefix", s + 1)(N) : A(N);
  }
  function A(N) {
    return N === null || Se(N) ? e.check(SE, w, O)(N) : (e.enter("codeFlowValue"), z(N));
  }
  function z(N) {
    return N === null || Se(N) ? (e.exit("codeFlowValue"), A(N)) : (e.consume(N), z);
  }
  function O(N) {
    return e.exit("codeFenced"), t(N);
  }
  function M(N, U, Z) {
    let re = 0;
    return D;
    function D(ce) {
      return N.enter("lineEnding"), N.consume(ce), N.exit("lineEnding"), ae;
    }
    function ae(ce) {
      return N.enter("codeFencedFence"), Fe(ce) ? Ge(N, ie, "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(ce) : ie(ce);
    }
    function ie(ce) {
      return ce === c ? (N.enter("codeFencedFenceSequence"), le(ce)) : Z(ce);
    }
    function le(ce) {
      return ce === c ? (re++, N.consume(ce), le) : re >= l ? (N.exit("codeFencedFenceSequence"), Fe(ce) ? Ge(N, se, "whitespace")(ce) : se(ce)) : Z(ce);
    }
    function se(ce) {
      return ce === null || Se(ce) ? (N.exit("codeFencedFence"), U(ce)) : Z(ce);
    }
  }
}
function Kte(e, t, n) {
  const i = this;
  return r;
  function r(l) {
    return l === null ? n(l) : (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), s);
  }
  function s(l) {
    return i.parser.lazy[i.now().line] ? n(l) : t(l);
  }
}
const pg = {
  name: "codeIndented",
  tokenize: Qte
}, Wte = {
  partial: !0,
  tokenize: ene
};
function Qte(e, t, n) {
  const i = this;
  return r;
  function r(h) {
    return e.enter("codeIndented"), Ge(e, s, "linePrefix", 5)(h);
  }
  function s(h) {
    const p = i.events[i.events.length - 1];
    return p && p[1].type === "linePrefix" && p[2].sliceSerialize(p[1], !0).length >= 4 ? l(h) : n(h);
  }
  function l(h) {
    return h === null ? f(h) : Se(h) ? e.attempt(Wte, l, f)(h) : (e.enter("codeFlowValue"), c(h));
  }
  function c(h) {
    return h === null || Se(h) ? (e.exit("codeFlowValue"), l(h)) : (e.consume(h), c);
  }
  function f(h) {
    return e.exit("codeIndented"), t(h);
  }
}
function ene(e, t, n) {
  const i = this;
  return r;
  function r(l) {
    return i.parser.lazy[i.now().line] ? n(l) : Se(l) ? (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), r) : Ge(e, s, "linePrefix", 5)(l);
  }
  function s(l) {
    const c = i.events[i.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? t(l) : Se(l) ? r(l) : n(l);
  }
}
const tne = {
  name: "codeText",
  previous: rne,
  resolve: nne,
  tokenize: ine
};
function nne(e) {
  let t = e.length - 4, n = 3, i, r;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (i = n; ++i < t; )
      if (e[i][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (i = n - 1, t++; ++i <= t; )
    r === void 0 ? i !== t && e[i][1].type !== "lineEnding" && (r = i) : (i === t || e[i][1].type === "lineEnding") && (e[r][1].type = "codeTextData", i !== r + 2 && (e[r][1].end = e[i - 1][1].end, e.splice(r + 2, i - r - 2), t -= i - r - 2, i = r + 2), r = void 0);
  return e;
}
function rne(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function ine(e, t, n) {
  let i = 0, r, s;
  return l;
  function l(m) {
    return e.enter("codeText"), e.enter("codeTextSequence"), c(m);
  }
  function c(m) {
    return m === 96 ? (e.consume(m), i++, c) : (e.exit("codeTextSequence"), f(m));
  }
  function f(m) {
    return m === null ? n(m) : m === 32 ? (e.enter("space"), e.consume(m), e.exit("space"), f) : m === 96 ? (s = e.enter("codeTextSequence"), r = 0, p(m)) : Se(m) ? (e.enter("lineEnding"), e.consume(m), e.exit("lineEnding"), f) : (e.enter("codeTextData"), h(m));
  }
  function h(m) {
    return m === null || m === 32 || m === 96 || Se(m) ? (e.exit("codeTextData"), f(m)) : (e.consume(m), h);
  }
  function p(m) {
    return m === 96 ? (e.consume(m), r++, p) : r === i ? (e.exit("codeTextSequence"), e.exit("codeText"), t(m)) : (s.type = "codeTextData", h(m));
  }
}
class ane {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const i = n ?? Number.POSITIVE_INFINITY;
    return i < this.left.length ? this.left.slice(t, i) : t > this.left.length ? this.right.slice(this.right.length - i + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - i + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, i) {
    const r = n || 0;
    this.setCursor(Math.trunc(t));
    const s = this.right.splice(this.right.length - r, Number.POSITIVE_INFINITY);
    return i && jl(this.left, i), s.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), jl(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), jl(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        jl(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        jl(this.left, n.reverse());
      }
  }
}
function jl(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function HD(e) {
  const t = {};
  let n = -1, i, r, s, l, c, f, h;
  const p = new ane(e);
  for (; ++n < p.length; ) {
    for (; n in t; )
      n = t[n];
    if (i = p.get(n), n && i[1].type === "chunkFlow" && p.get(n - 1)[1].type === "listItemPrefix" && (f = i[1]._tokenizer.events, s = 0, s < f.length && f[s][1].type === "lineEndingBlank" && (s += 2), s < f.length && f[s][1].type === "content"))
      for (; ++s < f.length && f[s][1].type !== "content"; )
        f[s][1].type === "chunkText" && (f[s][1]._isInFirstContentOfListItem = !0, s++);
    if (i[0] === "enter")
      i[1].contentType && (Object.assign(t, sne(p, n)), n = t[n], h = !0);
    else if (i[1]._container) {
      for (s = n, r = void 0; s--; )
        if (l = p.get(s), l[1].type === "lineEnding" || l[1].type === "lineEndingBlank")
          l[0] === "enter" && (r && (p.get(r)[1].type = "lineEndingBlank"), l[1].type = "lineEnding", r = s);
        else if (!(l[1].type === "linePrefix" || l[1].type === "listItemIndent")) break;
      r && (i[1].end = {
        ...p.get(r)[1].start
      }, c = p.slice(r, n), c.unshift(i), p.splice(r, n - r + 1, c));
    }
  }
  return Hn(e, 0, Number.POSITIVE_INFINITY, p.slice(0)), !h;
}
function sne(e, t) {
  const n = e.get(t)[1], i = e.get(t)[2];
  let r = t - 1;
  const s = [];
  let l = n._tokenizer;
  l || (l = i.parser[n.contentType](n.start), n._contentTypeTextTrailing && (l._contentTypeTextTrailing = !0));
  const c = l.events, f = [], h = {};
  let p, m, y = -1, b = n, x = 0, w = 0;
  const k = [w];
  for (; b; ) {
    for (; e.get(++r)[1] !== b; )
      ;
    s.push(r), b._tokenizer || (p = i.sliceStream(b), b.next || p.push(null), m && l.defineSkip(b.start), b._isInFirstContentOfListItem && (l._gfmTasklistFirstContentOfListItem = !0), l.write(p), b._isInFirstContentOfListItem && (l._gfmTasklistFirstContentOfListItem = void 0)), m = b, b = b.next;
  }
  for (b = n; ++y < c.length; )
    // Find a void token that includes a break.
    c[y][0] === "exit" && c[y - 1][0] === "enter" && c[y][1].type === c[y - 1][1].type && c[y][1].start.line !== c[y][1].end.line && (w = y + 1, k.push(w), b._tokenizer = void 0, b.previous = void 0, b = b.next);
  for (l.events = [], b ? (b._tokenizer = void 0, b.previous = void 0) : k.pop(), y = k.length; y--; ) {
    const T = c.slice(k[y], k[y + 1]), A = s.pop();
    f.push([A, A + T.length - 1]), e.splice(A, 2, T);
  }
  for (f.reverse(), y = -1; ++y < f.length; )
    h[x + f[y][0]] = x + f[y][1], x += f[y][1] - f[y][0] - 1;
  return h;
}
const one = {
  resolve: une,
  tokenize: cne
}, lne = {
  partial: !0,
  tokenize: dne
};
function une(e) {
  return HD(e), e;
}
function cne(e, t) {
  let n;
  return i;
  function i(c) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), r(c);
  }
  function r(c) {
    return c === null ? s(c) : Se(c) ? e.check(lne, l, s)(c) : (e.consume(c), r);
  }
  function s(c) {
    return e.exit("chunkContent"), e.exit("content"), t(c);
  }
  function l(c) {
    return e.consume(c), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, r;
  }
}
function dne(e, t, n) {
  const i = this;
  return r;
  function r(l) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), Ge(e, s, "linePrefix");
  }
  function s(l) {
    if (l === null || Se(l))
      return n(l);
    const c = i.events[i.events.length - 1];
    return !i.parser.constructs.disable.null.includes("codeIndented") && c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? t(l) : e.interrupt(i.parser.constructs.flow, n, t)(l);
  }
}
function qD(e, t, n, i, r, s, l, c, f) {
  const h = f || Number.POSITIVE_INFINITY;
  let p = 0;
  return m;
  function m(T) {
    return T === 60 ? (e.enter(i), e.enter(r), e.enter(s), e.consume(T), e.exit(s), y) : T === null || T === 32 || T === 41 || _f(T) ? n(T) : (e.enter(i), e.enter(l), e.enter(c), e.enter("chunkString", {
      contentType: "string"
    }), w(T));
  }
  function y(T) {
    return T === 62 ? (e.enter(s), e.consume(T), e.exit(s), e.exit(r), e.exit(i), t) : (e.enter(c), e.enter("chunkString", {
      contentType: "string"
    }), b(T));
  }
  function b(T) {
    return T === 62 ? (e.exit("chunkString"), e.exit(c), y(T)) : T === null || T === 60 || Se(T) ? n(T) : (e.consume(T), T === 92 ? x : b);
  }
  function x(T) {
    return T === 60 || T === 62 || T === 92 ? (e.consume(T), b) : b(T);
  }
  function w(T) {
    return !p && (T === null || T === 41 || ot(T)) ? (e.exit("chunkString"), e.exit(c), e.exit(l), e.exit(i), t(T)) : p < h && T === 40 ? (e.consume(T), p++, w) : T === 41 ? (e.consume(T), p--, w) : T === null || T === 32 || T === 40 || _f(T) ? n(T) : (e.consume(T), T === 92 ? k : w);
  }
  function k(T) {
    return T === 40 || T === 41 || T === 92 ? (e.consume(T), w) : w(T);
  }
}
function GD(e, t, n, i, r, s) {
  const l = this;
  let c = 0, f;
  return h;
  function h(b) {
    return e.enter(i), e.enter(r), e.consume(b), e.exit(r), e.enter(s), p;
  }
  function p(b) {
    return c > 999 || b === null || b === 91 || b === 93 && !f || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    b === 94 && !c && "_hiddenFootnoteSupport" in l.parser.constructs ? n(b) : b === 93 ? (e.exit(s), e.enter(r), e.consume(b), e.exit(r), e.exit(i), t) : Se(b) ? (e.enter("lineEnding"), e.consume(b), e.exit("lineEnding"), p) : (e.enter("chunkString", {
      contentType: "string"
    }), m(b));
  }
  function m(b) {
    return b === null || b === 91 || b === 93 || Se(b) || c++ > 999 ? (e.exit("chunkString"), p(b)) : (e.consume(b), f || (f = !Fe(b)), b === 92 ? y : m);
  }
  function y(b) {
    return b === 91 || b === 92 || b === 93 ? (e.consume(b), c++, m) : m(b);
  }
}
function YD(e, t, n, i, r, s) {
  let l;
  return c;
  function c(y) {
    return y === 34 || y === 39 || y === 40 ? (e.enter(i), e.enter(r), e.consume(y), e.exit(r), l = y === 40 ? 41 : y, f) : n(y);
  }
  function f(y) {
    return y === l ? (e.enter(r), e.consume(y), e.exit(r), e.exit(i), t) : (e.enter(s), h(y));
  }
  function h(y) {
    return y === l ? (e.exit(s), f(l)) : y === null ? n(y) : Se(y) ? (e.enter("lineEnding"), e.consume(y), e.exit("lineEnding"), Ge(e, h, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), p(y));
  }
  function p(y) {
    return y === l || y === null || Se(y) ? (e.exit("chunkString"), h(y)) : (e.consume(y), y === 92 ? m : p);
  }
  function m(y) {
    return y === l || y === 92 ? (e.consume(y), p) : p(y);
  }
}
function Wl(e, t) {
  let n;
  return i;
  function i(r) {
    return Se(r) ? (e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), n = !0, i) : Fe(r) ? Ge(e, i, n ? "linePrefix" : "lineSuffix")(r) : t(r);
  }
}
const fne = {
  name: "definition",
  tokenize: pne
}, hne = {
  partial: !0,
  tokenize: mne
};
function pne(e, t, n) {
  const i = this;
  let r;
  return s;
  function s(b) {
    return e.enter("definition"), l(b);
  }
  function l(b) {
    return GD.call(
      i,
      e,
      c,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(b);
  }
  function c(b) {
    return r = Sr(i.sliceSerialize(i.events[i.events.length - 1][1]).slice(1, -1)), b === 58 ? (e.enter("definitionMarker"), e.consume(b), e.exit("definitionMarker"), f) : n(b);
  }
  function f(b) {
    return ot(b) ? Wl(e, h)(b) : h(b);
  }
  function h(b) {
    return qD(
      e,
      p,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(b);
  }
  function p(b) {
    return e.attempt(hne, m, m)(b);
  }
  function m(b) {
    return Fe(b) ? Ge(e, y, "whitespace")(b) : y(b);
  }
  function y(b) {
    return b === null || Se(b) ? (e.exit("definition"), i.parser.defined.push(r), t(b)) : n(b);
  }
}
function mne(e, t, n) {
  return i;
  function i(c) {
    return ot(c) ? Wl(e, r)(c) : n(c);
  }
  function r(c) {
    return YD(e, s, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(c);
  }
  function s(c) {
    return Fe(c) ? Ge(e, l, "whitespace")(c) : l(c);
  }
  function l(c) {
    return c === null || Se(c) ? t(c) : n(c);
  }
}
const gne = {
  name: "hardBreakEscape",
  tokenize: vne
};
function vne(e, t, n) {
  return i;
  function i(s) {
    return e.enter("hardBreakEscape"), e.consume(s), r;
  }
  function r(s) {
    return Se(s) ? (e.exit("hardBreakEscape"), t(s)) : n(s);
  }
}
const yne = {
  name: "headingAtx",
  resolve: bne,
  tokenize: xne
};
function bne(e, t) {
  let n = e.length - 2, i = 3, r, s;
  return e[i][1].type === "whitespace" && (i += 2), n - 2 > i && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (i === n - 1 || n - 4 > i && e[n - 2][1].type === "whitespace") && (n -= i + 1 === n ? 2 : 4), n > i && (r = {
    type: "atxHeadingText",
    start: e[i][1].start,
    end: e[n][1].end
  }, s = {
    type: "chunkText",
    start: e[i][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Hn(e, i, n - i + 1, [["enter", r, t], ["enter", s, t], ["exit", s, t], ["exit", r, t]])), e;
}
function xne(e, t, n) {
  let i = 0;
  return r;
  function r(p) {
    return e.enter("atxHeading"), s(p);
  }
  function s(p) {
    return e.enter("atxHeadingSequence"), l(p);
  }
  function l(p) {
    return p === 35 && i++ < 6 ? (e.consume(p), l) : p === null || ot(p) ? (e.exit("atxHeadingSequence"), c(p)) : n(p);
  }
  function c(p) {
    return p === 35 ? (e.enter("atxHeadingSequence"), f(p)) : p === null || Se(p) ? (e.exit("atxHeading"), t(p)) : Fe(p) ? Ge(e, c, "whitespace")(p) : (e.enter("atxHeadingText"), h(p));
  }
  function f(p) {
    return p === 35 ? (e.consume(p), f) : (e.exit("atxHeadingSequence"), c(p));
  }
  function h(p) {
    return p === null || p === 35 || ot(p) ? (e.exit("atxHeadingText"), c(p)) : (e.consume(p), h);
  }
}
const wne = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], TE = ["pre", "script", "style", "textarea"], _ne = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: Tne,
  tokenize: Ene
}, Sne = {
  partial: !0,
  tokenize: Ane
}, kne = {
  partial: !0,
  tokenize: $ne
};
function Tne(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function Ene(e, t, n) {
  const i = this;
  let r, s, l, c, f;
  return h;
  function h(I) {
    return p(I);
  }
  function p(I) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(I), m;
  }
  function m(I) {
    return I === 33 ? (e.consume(I), y) : I === 47 ? (e.consume(I), s = !0, w) : I === 63 ? (e.consume(I), r = 3, i.interrupt ? t : S) : pn(I) ? (e.consume(I), l = String.fromCharCode(I), k) : n(I);
  }
  function y(I) {
    return I === 45 ? (e.consume(I), r = 2, b) : I === 91 ? (e.consume(I), r = 5, c = 0, x) : pn(I) ? (e.consume(I), r = 4, i.interrupt ? t : S) : n(I);
  }
  function b(I) {
    return I === 45 ? (e.consume(I), i.interrupt ? t : S) : n(I);
  }
  function x(I) {
    const he = "CDATA[";
    return I === he.charCodeAt(c++) ? (e.consume(I), c === he.length ? i.interrupt ? t : ie : x) : n(I);
  }
  function w(I) {
    return pn(I) ? (e.consume(I), l = String.fromCharCode(I), k) : n(I);
  }
  function k(I) {
    if (I === null || I === 47 || I === 62 || ot(I)) {
      const he = I === 47, Ie = l.toLowerCase();
      return !he && !s && TE.includes(Ie) ? (r = 1, i.interrupt ? t(I) : ie(I)) : wne.includes(l.toLowerCase()) ? (r = 6, he ? (e.consume(I), T) : i.interrupt ? t(I) : ie(I)) : (r = 7, i.interrupt && !i.parser.lazy[i.now().line] ? n(I) : s ? A(I) : z(I));
    }
    return I === 45 || on(I) ? (e.consume(I), l += String.fromCharCode(I), k) : n(I);
  }
  function T(I) {
    return I === 62 ? (e.consume(I), i.interrupt ? t : ie) : n(I);
  }
  function A(I) {
    return Fe(I) ? (e.consume(I), A) : D(I);
  }
  function z(I) {
    return I === 47 ? (e.consume(I), D) : I === 58 || I === 95 || pn(I) ? (e.consume(I), O) : Fe(I) ? (e.consume(I), z) : D(I);
  }
  function O(I) {
    return I === 45 || I === 46 || I === 58 || I === 95 || on(I) ? (e.consume(I), O) : M(I);
  }
  function M(I) {
    return I === 61 ? (e.consume(I), N) : Fe(I) ? (e.consume(I), M) : z(I);
  }
  function N(I) {
    return I === null || I === 60 || I === 61 || I === 62 || I === 96 ? n(I) : I === 34 || I === 39 ? (e.consume(I), f = I, U) : Fe(I) ? (e.consume(I), N) : Z(I);
  }
  function U(I) {
    return I === f ? (e.consume(I), f = null, re) : I === null || Se(I) ? n(I) : (e.consume(I), U);
  }
  function Z(I) {
    return I === null || I === 34 || I === 39 || I === 47 || I === 60 || I === 61 || I === 62 || I === 96 || ot(I) ? M(I) : (e.consume(I), Z);
  }
  function re(I) {
    return I === 47 || I === 62 || Fe(I) ? z(I) : n(I);
  }
  function D(I) {
    return I === 62 ? (e.consume(I), ae) : n(I);
  }
  function ae(I) {
    return I === null || Se(I) ? ie(I) : Fe(I) ? (e.consume(I), ae) : n(I);
  }
  function ie(I) {
    return I === 45 && r === 2 ? (e.consume(I), L) : I === 60 && r === 1 ? (e.consume(I), Y) : I === 62 && r === 4 ? (e.consume(I), X) : I === 63 && r === 3 ? (e.consume(I), S) : I === 93 && r === 5 ? (e.consume(I), ge) : Se(I) && (r === 6 || r === 7) ? (e.exit("htmlFlowData"), e.check(Sne, fe, le)(I)) : I === null || Se(I) ? (e.exit("htmlFlowData"), le(I)) : (e.consume(I), ie);
  }
  function le(I) {
    return e.check(kne, se, fe)(I);
  }
  function se(I) {
    return e.enter("lineEnding"), e.consume(I), e.exit("lineEnding"), ce;
  }
  function ce(I) {
    return I === null || Se(I) ? le(I) : (e.enter("htmlFlowData"), ie(I));
  }
  function L(I) {
    return I === 45 ? (e.consume(I), S) : ie(I);
  }
  function Y(I) {
    return I === 47 ? (e.consume(I), l = "", H) : ie(I);
  }
  function H(I) {
    if (I === 62) {
      const he = l.toLowerCase();
      return TE.includes(he) ? (e.consume(I), X) : ie(I);
    }
    return pn(I) && l.length < 8 ? (e.consume(I), l += String.fromCharCode(I), H) : ie(I);
  }
  function ge(I) {
    return I === 93 ? (e.consume(I), S) : ie(I);
  }
  function S(I) {
    return I === 62 ? (e.consume(I), X) : I === 45 && r === 2 ? (e.consume(I), S) : ie(I);
  }
  function X(I) {
    return I === null || Se(I) ? (e.exit("htmlFlowData"), fe(I)) : (e.consume(I), X);
  }
  function fe(I) {
    return e.exit("htmlFlow"), t(I);
  }
}
function $ne(e, t, n) {
  const i = this;
  return r;
  function r(l) {
    return Se(l) ? (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), s) : n(l);
  }
  function s(l) {
    return i.parser.lazy[i.now().line] ? n(l) : t(l);
  }
}
function Ane(e, t, n) {
  return i;
  function i(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), e.attempt(Gu, t, n);
  }
}
const zne = {
  name: "htmlText",
  tokenize: Ine
};
function Ine(e, t, n) {
  const i = this;
  let r, s, l;
  return c;
  function c(S) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(S), f;
  }
  function f(S) {
    return S === 33 ? (e.consume(S), h) : S === 47 ? (e.consume(S), M) : S === 63 ? (e.consume(S), z) : pn(S) ? (e.consume(S), Z) : n(S);
  }
  function h(S) {
    return S === 45 ? (e.consume(S), p) : S === 91 ? (e.consume(S), s = 0, x) : pn(S) ? (e.consume(S), A) : n(S);
  }
  function p(S) {
    return S === 45 ? (e.consume(S), b) : n(S);
  }
  function m(S) {
    return S === null ? n(S) : S === 45 ? (e.consume(S), y) : Se(S) ? (l = m, Y(S)) : (e.consume(S), m);
  }
  function y(S) {
    return S === 45 ? (e.consume(S), b) : m(S);
  }
  function b(S) {
    return S === 62 ? L(S) : S === 45 ? y(S) : m(S);
  }
  function x(S) {
    const X = "CDATA[";
    return S === X.charCodeAt(s++) ? (e.consume(S), s === X.length ? w : x) : n(S);
  }
  function w(S) {
    return S === null ? n(S) : S === 93 ? (e.consume(S), k) : Se(S) ? (l = w, Y(S)) : (e.consume(S), w);
  }
  function k(S) {
    return S === 93 ? (e.consume(S), T) : w(S);
  }
  function T(S) {
    return S === 62 ? L(S) : S === 93 ? (e.consume(S), T) : w(S);
  }
  function A(S) {
    return S === null || S === 62 ? L(S) : Se(S) ? (l = A, Y(S)) : (e.consume(S), A);
  }
  function z(S) {
    return S === null ? n(S) : S === 63 ? (e.consume(S), O) : Se(S) ? (l = z, Y(S)) : (e.consume(S), z);
  }
  function O(S) {
    return S === 62 ? L(S) : z(S);
  }
  function M(S) {
    return pn(S) ? (e.consume(S), N) : n(S);
  }
  function N(S) {
    return S === 45 || on(S) ? (e.consume(S), N) : U(S);
  }
  function U(S) {
    return Se(S) ? (l = U, Y(S)) : Fe(S) ? (e.consume(S), U) : L(S);
  }
  function Z(S) {
    return S === 45 || on(S) ? (e.consume(S), Z) : S === 47 || S === 62 || ot(S) ? re(S) : n(S);
  }
  function re(S) {
    return S === 47 ? (e.consume(S), L) : S === 58 || S === 95 || pn(S) ? (e.consume(S), D) : Se(S) ? (l = re, Y(S)) : Fe(S) ? (e.consume(S), re) : L(S);
  }
  function D(S) {
    return S === 45 || S === 46 || S === 58 || S === 95 || on(S) ? (e.consume(S), D) : ae(S);
  }
  function ae(S) {
    return S === 61 ? (e.consume(S), ie) : Se(S) ? (l = ae, Y(S)) : Fe(S) ? (e.consume(S), ae) : re(S);
  }
  function ie(S) {
    return S === null || S === 60 || S === 61 || S === 62 || S === 96 ? n(S) : S === 34 || S === 39 ? (e.consume(S), r = S, le) : Se(S) ? (l = ie, Y(S)) : Fe(S) ? (e.consume(S), ie) : (e.consume(S), se);
  }
  function le(S) {
    return S === r ? (e.consume(S), r = void 0, ce) : S === null ? n(S) : Se(S) ? (l = le, Y(S)) : (e.consume(S), le);
  }
  function se(S) {
    return S === null || S === 34 || S === 39 || S === 60 || S === 61 || S === 96 ? n(S) : S === 47 || S === 62 || ot(S) ? re(S) : (e.consume(S), se);
  }
  function ce(S) {
    return S === 47 || S === 62 || ot(S) ? re(S) : n(S);
  }
  function L(S) {
    return S === 62 ? (e.consume(S), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(S);
  }
  function Y(S) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(S), e.exit("lineEnding"), H;
  }
  function H(S) {
    return Fe(S) ? Ge(e, ge, "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(S) : ge(S);
  }
  function ge(S) {
    return e.enter("htmlTextData"), l(S);
  }
}
const Kx = {
  name: "labelEnd",
  resolveAll: Nne,
  resolveTo: Mne,
  tokenize: Dne
}, Cne = {
  tokenize: jne
}, One = {
  tokenize: Pne
}, Rne = {
  tokenize: Une
};
function Nne(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const i = e[t][1];
    if (n.push(e[t]), i.type === "labelImage" || i.type === "labelLink" || i.type === "labelEnd") {
      const r = i.type === "labelImage" ? 4 : 2;
      i.type = "data", t += r;
    }
  }
  return e.length !== n.length && Hn(e, 0, e.length, n), e;
}
function Mne(e, t) {
  let n = e.length, i = 0, r, s, l, c;
  for (; n--; )
    if (r = e[n][1], s) {
      if (r.type === "link" || r.type === "labelLink" && r._inactive)
        break;
      e[n][0] === "enter" && r.type === "labelLink" && (r._inactive = !0);
    } else if (l) {
      if (e[n][0] === "enter" && (r.type === "labelImage" || r.type === "labelLink") && !r._balanced && (s = n, r.type !== "labelLink")) {
        i = 2;
        break;
      }
    } else r.type === "labelEnd" && (l = n);
  const f = {
    type: e[s][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[s][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, h = {
    type: "label",
    start: {
      ...e[s][1].start
    },
    end: {
      ...e[l][1].end
    }
  }, p = {
    type: "labelText",
    start: {
      ...e[s + i + 2][1].end
    },
    end: {
      ...e[l - 2][1].start
    }
  };
  return c = [["enter", f, t], ["enter", h, t]], c = ur(c, e.slice(s + 1, s + i + 3)), c = ur(c, [["enter", p, t]]), c = ur(c, ch(t.parser.constructs.insideSpan.null, e.slice(s + i + 4, l - 3), t)), c = ur(c, [["exit", p, t], e[l - 2], e[l - 1], ["exit", h, t]]), c = ur(c, e.slice(l + 1)), c = ur(c, [["exit", f, t]]), Hn(e, s, e.length, c), e;
}
function Dne(e, t, n) {
  const i = this;
  let r = i.events.length, s, l;
  for (; r--; )
    if ((i.events[r][1].type === "labelImage" || i.events[r][1].type === "labelLink") && !i.events[r][1]._balanced) {
      s = i.events[r][1];
      break;
    }
  return c;
  function c(y) {
    return s ? s._inactive ? m(y) : (l = i.parser.defined.includes(Sr(i.sliceSerialize({
      start: s.end,
      end: i.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(y), e.exit("labelMarker"), e.exit("labelEnd"), f) : n(y);
  }
  function f(y) {
    return y === 40 ? e.attempt(Cne, p, l ? p : m)(y) : y === 91 ? e.attempt(One, p, l ? h : m)(y) : l ? p(y) : m(y);
  }
  function h(y) {
    return e.attempt(Rne, p, m)(y);
  }
  function p(y) {
    return t(y);
  }
  function m(y) {
    return s._balanced = !0, n(y);
  }
}
function jne(e, t, n) {
  return i;
  function i(m) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(m), e.exit("resourceMarker"), r;
  }
  function r(m) {
    return ot(m) ? Wl(e, s)(m) : s(m);
  }
  function s(m) {
    return m === 41 ? p(m) : qD(e, l, c, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(m);
  }
  function l(m) {
    return ot(m) ? Wl(e, f)(m) : p(m);
  }
  function c(m) {
    return n(m);
  }
  function f(m) {
    return m === 34 || m === 39 || m === 40 ? YD(e, h, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(m) : p(m);
  }
  function h(m) {
    return ot(m) ? Wl(e, p)(m) : p(m);
  }
  function p(m) {
    return m === 41 ? (e.enter("resourceMarker"), e.consume(m), e.exit("resourceMarker"), e.exit("resource"), t) : n(m);
  }
}
function Pne(e, t, n) {
  const i = this;
  return r;
  function r(c) {
    return GD.call(i, e, s, l, "reference", "referenceMarker", "referenceString")(c);
  }
  function s(c) {
    return i.parser.defined.includes(Sr(i.sliceSerialize(i.events[i.events.length - 1][1]).slice(1, -1))) ? t(c) : n(c);
  }
  function l(c) {
    return n(c);
  }
}
function Une(e, t, n) {
  return i;
  function i(s) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), r;
  }
  function r(s) {
    return s === 93 ? (e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), e.exit("reference"), t) : n(s);
  }
}
const Lne = {
  name: "labelStartImage",
  resolveAll: Kx.resolveAll,
  tokenize: Bne
};
function Bne(e, t, n) {
  const i = this;
  return r;
  function r(c) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(c), e.exit("labelImageMarker"), s;
  }
  function s(c) {
    return c === 91 ? (e.enter("labelMarker"), e.consume(c), e.exit("labelMarker"), e.exit("labelImage"), l) : n(c);
  }
  function l(c) {
    return c === 94 && "_hiddenFootnoteSupport" in i.parser.constructs ? n(c) : t(c);
  }
}
const Zne = {
  name: "labelStartLink",
  resolveAll: Kx.resolveAll,
  tokenize: Vne
};
function Vne(e, t, n) {
  const i = this;
  return r;
  function r(l) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(l), e.exit("labelMarker"), e.exit("labelLink"), s;
  }
  function s(l) {
    return l === 94 && "_hiddenFootnoteSupport" in i.parser.constructs ? n(l) : t(l);
  }
}
const mg = {
  name: "lineEnding",
  tokenize: Fne
};
function Fne(e, t) {
  return n;
  function n(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), Ge(e, t, "linePrefix");
  }
}
const Hd = {
  name: "thematicBreak",
  tokenize: Hne
};
function Hne(e, t, n) {
  let i = 0, r;
  return s;
  function s(h) {
    return e.enter("thematicBreak"), l(h);
  }
  function l(h) {
    return r = h, c(h);
  }
  function c(h) {
    return h === r ? (e.enter("thematicBreakSequence"), f(h)) : i >= 3 && (h === null || Se(h)) ? (e.exit("thematicBreak"), t(h)) : n(h);
  }
  function f(h) {
    return h === r ? (e.consume(h), i++, f) : (e.exit("thematicBreakSequence"), Fe(h) ? Ge(e, c, "whitespace")(h) : c(h));
  }
}
const kn = {
  continuation: {
    tokenize: Jne
  },
  exit: Kne,
  name: "list",
  tokenize: Yne
}, qne = {
  partial: !0,
  tokenize: Wne
}, Gne = {
  partial: !0,
  tokenize: Xne
};
function Yne(e, t, n) {
  const i = this, r = i.events[i.events.length - 1];
  let s = r && r[1].type === "linePrefix" ? r[2].sliceSerialize(r[1], !0).length : 0, l = 0;
  return c;
  function c(b) {
    const x = i.containerState.type || (b === 42 || b === 43 || b === 45 ? "listUnordered" : "listOrdered");
    if (x === "listUnordered" ? !i.containerState.marker || b === i.containerState.marker : Rv(b)) {
      if (i.containerState.type || (i.containerState.type = x, e.enter(x, {
        _container: !0
      })), x === "listUnordered")
        return e.enter("listItemPrefix"), b === 42 || b === 45 ? e.check(Hd, n, h)(b) : h(b);
      if (!i.interrupt || b === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), f(b);
    }
    return n(b);
  }
  function f(b) {
    return Rv(b) && ++l < 10 ? (e.consume(b), f) : (!i.interrupt || l < 2) && (i.containerState.marker ? b === i.containerState.marker : b === 41 || b === 46) ? (e.exit("listItemValue"), h(b)) : n(b);
  }
  function h(b) {
    return e.enter("listItemMarker"), e.consume(b), e.exit("listItemMarker"), i.containerState.marker = i.containerState.marker || b, e.check(
      Gu,
      // Cant be empty when interrupting.
      i.interrupt ? n : p,
      e.attempt(qne, y, m)
    );
  }
  function p(b) {
    return i.containerState.initialBlankLine = !0, s++, y(b);
  }
  function m(b) {
    return Fe(b) ? (e.enter("listItemPrefixWhitespace"), e.consume(b), e.exit("listItemPrefixWhitespace"), y) : n(b);
  }
  function y(b) {
    return i.containerState.size = s + i.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(b);
  }
}
function Jne(e, t, n) {
  const i = this;
  return i.containerState._closeFlow = void 0, e.check(Gu, r, s);
  function r(c) {
    return i.containerState.furtherBlankLines = i.containerState.furtherBlankLines || i.containerState.initialBlankLine, Ge(e, t, "listItemIndent", i.containerState.size + 1)(c);
  }
  function s(c) {
    return i.containerState.furtherBlankLines || !Fe(c) ? (i.containerState.furtherBlankLines = void 0, i.containerState.initialBlankLine = void 0, l(c)) : (i.containerState.furtherBlankLines = void 0, i.containerState.initialBlankLine = void 0, e.attempt(Gne, t, l)(c));
  }
  function l(c) {
    return i.containerState._closeFlow = !0, i.interrupt = void 0, Ge(e, e.attempt(kn, t, n), "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(c);
  }
}
function Xne(e, t, n) {
  const i = this;
  return Ge(e, r, "listItemIndent", i.containerState.size + 1);
  function r(s) {
    const l = i.events[i.events.length - 1];
    return l && l[1].type === "listItemIndent" && l[2].sliceSerialize(l[1], !0).length === i.containerState.size ? t(s) : n(s);
  }
}
function Kne(e) {
  e.exit(this.containerState.type);
}
function Wne(e, t, n) {
  const i = this;
  return Ge(e, r, "listItemPrefixWhitespace", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function r(s) {
    const l = i.events[i.events.length - 1];
    return !Fe(s) && l && l[1].type === "listItemPrefixWhitespace" ? t(s) : n(s);
  }
}
const EE = {
  name: "setextUnderline",
  resolveTo: Qne,
  tokenize: ere
};
function Qne(e, t) {
  let n = e.length, i, r, s;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        i = n;
        break;
      }
      e[n][1].type === "paragraph" && (r = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !s && e[n][1].type === "definition" && (s = n);
  const l = {
    type: "setextHeading",
    start: {
      ...e[i][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[r][1].type = "setextHeadingText", s ? (e.splice(r, 0, ["enter", l, t]), e.splice(s + 1, 0, ["exit", e[i][1], t]), e[i][1].end = {
    ...e[s][1].end
  }) : e[i][1] = l, e.push(["exit", l, t]), e;
}
function ere(e, t, n) {
  const i = this;
  let r;
  return s;
  function s(h) {
    let p = i.events.length, m;
    for (; p--; )
      if (i.events[p][1].type !== "lineEnding" && i.events[p][1].type !== "linePrefix" && i.events[p][1].type !== "content") {
        m = i.events[p][1].type === "paragraph";
        break;
      }
    return !i.parser.lazy[i.now().line] && (i.interrupt || m) ? (e.enter("setextHeadingLine"), r = h, l(h)) : n(h);
  }
  function l(h) {
    return e.enter("setextHeadingLineSequence"), c(h);
  }
  function c(h) {
    return h === r ? (e.consume(h), c) : (e.exit("setextHeadingLineSequence"), Fe(h) ? Ge(e, f, "lineSuffix")(h) : f(h));
  }
  function f(h) {
    return h === null || Se(h) ? (e.exit("setextHeadingLine"), t(h)) : n(h);
  }
}
const tre = {
  tokenize: nre
};
function nre(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    Gu,
    i,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, r, Ge(e, e.attempt(this.parser.constructs.flow, r, e.attempt(one, r)), "linePrefix"))
  );
  return n;
  function i(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(s), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function r(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const rre = {
  resolveAll: XD()
}, ire = JD("string"), are = JD("text");
function JD(e) {
  return {
    resolveAll: XD(e === "text" ? sre : void 0),
    tokenize: t
  };
  function t(n) {
    const i = this, r = this.parser.constructs[e], s = n.attempt(r, l, c);
    return l;
    function l(p) {
      return h(p) ? s(p) : c(p);
    }
    function c(p) {
      if (p === null) {
        n.consume(p);
        return;
      }
      return n.enter("data"), n.consume(p), f;
    }
    function f(p) {
      return h(p) ? (n.exit("data"), s(p)) : (n.consume(p), f);
    }
    function h(p) {
      if (p === null)
        return !0;
      const m = r[p];
      let y = -1;
      if (m)
        for (; ++y < m.length; ) {
          const b = m[y];
          if (!b.previous || b.previous.call(i, i.previous))
            return !0;
        }
      return !1;
    }
  }
}
function XD(e) {
  return t;
  function t(n, i) {
    let r = -1, s;
    for (; ++r <= n.length; )
      s === void 0 ? n[r] && n[r][1].type === "data" && (s = r, r++) : (!n[r] || n[r][1].type !== "data") && (r !== s + 2 && (n[s][1].end = n[r - 1][1].end, n.splice(s + 2, r - s - 2), r = s + 2), s = void 0);
    return e ? e(n, i) : n;
  }
}
function sre(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const i = e[n - 1][1], r = t.sliceStream(i);
      let s = r.length, l = -1, c = 0, f;
      for (; s--; ) {
        const h = r[s];
        if (typeof h == "string") {
          for (l = h.length; h.charCodeAt(l - 1) === 32; )
            c++, l--;
          if (l) break;
          l = -1;
        } else if (h === -2)
          f = !0, c++;
        else if (h !== -1) {
          s++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (c = 0), c) {
        const h = {
          type: n === e.length || f || c < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: s ? l : i.start._bufferIndex + l,
            _index: i.start._index + s,
            line: i.end.line,
            column: i.end.column - c,
            offset: i.end.offset - c
          },
          end: {
            ...i.end
          }
        };
        i.end = {
          ...h.start
        }, i.start.offset === i.end.offset ? Object.assign(i, h) : (e.splice(n, 0, ["enter", h, t], ["exit", h, t]), n += 2);
      }
      n++;
    }
  return e;
}
const ore = {
  42: kn,
  43: kn,
  45: kn,
  48: kn,
  49: kn,
  50: kn,
  51: kn,
  52: kn,
  53: kn,
  54: kn,
  55: kn,
  56: kn,
  57: kn,
  62: ZD
}, lre = {
  91: fne
}, ure = {
  [-2]: pg,
  [-1]: pg,
  32: pg
}, cre = {
  35: yne,
  42: Hd,
  45: [EE, Hd],
  60: _ne,
  61: EE,
  95: Hd,
  96: kE,
  126: kE
}, dre = {
  38: FD,
  92: VD
}, fre = {
  [-5]: mg,
  [-4]: mg,
  [-3]: mg,
  33: Lne,
  38: FD,
  42: Nv,
  60: [Zte, zne],
  91: Zne,
  92: [gne, VD],
  93: Kx,
  95: Nv,
  96: tne
}, hre = {
  null: [Nv, rre]
}, pre = {
  null: [42, 95]
}, mre = {
  null: []
}, gre = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: pre,
  contentInitial: lre,
  disable: mre,
  document: ore,
  flow: cre,
  flowInitial: ure,
  insideSpan: hre,
  string: dre,
  text: fre
}, Symbol.toStringTag, { value: "Module" }));
function vre(e, t, n) {
  let i = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const r = {}, s = [];
  let l = [], c = [];
  const f = {
    attempt: U(M),
    check: U(N),
    consume: A,
    enter: z,
    exit: O,
    interrupt: U(N, {
      interrupt: !0
    })
  }, h = {
    code: null,
    containerState: {},
    defineSkip: w,
    events: [],
    now: x,
    parser: e,
    previous: null,
    sliceSerialize: y,
    sliceStream: b,
    write: m
  };
  let p = t.tokenize.call(h, f);
  return t.resolveAll && s.push(t), h;
  function m(ae) {
    return l = ur(l, ae), k(), l[l.length - 1] !== null ? [] : (Z(t, 0), h.events = ch(s, h.events, h), h.events);
  }
  function y(ae, ie) {
    return bre(b(ae), ie);
  }
  function b(ae) {
    return yre(l, ae);
  }
  function x() {
    const {
      _bufferIndex: ae,
      _index: ie,
      line: le,
      column: se,
      offset: ce
    } = i;
    return {
      _bufferIndex: ae,
      _index: ie,
      line: le,
      column: se,
      offset: ce
    };
  }
  function w(ae) {
    r[ae.line] = ae.column, D();
  }
  function k() {
    let ae;
    for (; i._index < l.length; ) {
      const ie = l[i._index];
      if (typeof ie == "string")
        for (ae = i._index, i._bufferIndex < 0 && (i._bufferIndex = 0); i._index === ae && i._bufferIndex < ie.length; )
          T(ie.charCodeAt(i._bufferIndex));
      else
        T(ie);
    }
  }
  function T(ae) {
    p = p(ae);
  }
  function A(ae) {
    Se(ae) ? (i.line++, i.column = 1, i.offset += ae === -3 ? 2 : 1, D()) : ae !== -1 && (i.column++, i.offset++), i._bufferIndex < 0 ? i._index++ : (i._bufferIndex++, i._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    l[i._index].length && (i._bufferIndex = -1, i._index++)), h.previous = ae;
  }
  function z(ae, ie) {
    const le = ie || {};
    return le.type = ae, le.start = x(), h.events.push(["enter", le, h]), c.push(le), le;
  }
  function O(ae) {
    const ie = c.pop();
    return ie.end = x(), h.events.push(["exit", ie, h]), ie;
  }
  function M(ae, ie) {
    Z(ae, ie.from);
  }
  function N(ae, ie) {
    ie.restore();
  }
  function U(ae, ie) {
    return le;
    function le(se, ce, L) {
      let Y, H, ge, S;
      return Array.isArray(se) ? (
        /* c8 ignore next 1 */
        fe(se)
      ) : "tokenize" in se ? (
        // Looks like a construct.
        fe([
          /** @type {Construct} */
          se
        ])
      ) : X(se);
      function X(pe) {
        return Ce;
        function Ce(Pe) {
          const kt = Pe !== null && pe[Pe], Kt = Pe !== null && pe.null, un = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(kt) ? kt : kt ? [kt] : [],
            ...Array.isArray(Kt) ? Kt : Kt ? [Kt] : []
          ];
          return fe(un)(Pe);
        }
      }
      function fe(pe) {
        return Y = pe, H = 0, pe.length === 0 ? L : I(pe[H]);
      }
      function I(pe) {
        return Ce;
        function Ce(Pe) {
          return S = re(), ge = pe, pe.partial || (h.currentConstruct = pe), pe.name && h.parser.constructs.disable.null.includes(pe.name) ? Ie() : pe.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            ie ? Object.assign(Object.create(h), ie) : h,
            f,
            he,
            Ie
          )(Pe);
        }
      }
      function he(pe) {
        return ae(ge, S), ce;
      }
      function Ie(pe) {
        return S.restore(), ++H < Y.length ? I(Y[H]) : L;
      }
    }
  }
  function Z(ae, ie) {
    ae.resolveAll && !s.includes(ae) && s.push(ae), ae.resolve && Hn(h.events, ie, h.events.length - ie, ae.resolve(h.events.slice(ie), h)), ae.resolveTo && (h.events = ae.resolveTo(h.events, h));
  }
  function re() {
    const ae = x(), ie = h.previous, le = h.currentConstruct, se = h.events.length, ce = Array.from(c);
    return {
      from: se,
      restore: L
    };
    function L() {
      i = ae, h.previous = ie, h.currentConstruct = le, h.events.length = se, c = ce, D();
    }
  }
  function D() {
    i.line in r && i.column < 2 && (i.column = r[i.line], i.offset += r[i.line] - 1);
  }
}
function yre(e, t) {
  const n = t.start._index, i = t.start._bufferIndex, r = t.end._index, s = t.end._bufferIndex;
  let l;
  if (n === r)
    l = [e[n].slice(i, s)];
  else {
    if (l = e.slice(n, r), i > -1) {
      const c = l[0];
      typeof c == "string" ? l[0] = c.slice(i) : l.shift();
    }
    s > 0 && l.push(e[r].slice(0, s));
  }
  return l;
}
function bre(e, t) {
  let n = -1;
  const i = [];
  let r;
  for (; ++n < e.length; ) {
    const s = e[n];
    let l;
    if (typeof s == "string")
      l = s;
    else switch (s) {
      case -5: {
        l = "\r";
        break;
      }
      case -4: {
        l = `
`;
        break;
      }
      case -3: {
        l = `\r
`;
        break;
      }
      case -2: {
        l = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && r) continue;
        l = " ";
        break;
      }
      default:
        l = String.fromCharCode(s);
    }
    r = s === -2, i.push(l);
  }
  return i.join("");
}
function xre(e) {
  const i = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      LD([gre, ...(e || {}).extensions || []])
    ),
    content: r(Mte),
    defined: [],
    document: r(jte),
    flow: r(tre),
    lazy: {},
    string: r(ire),
    text: r(are)
  };
  return i;
  function r(s) {
    return l;
    function l(c) {
      return vre(i, s, c);
    }
  }
}
function wre(e) {
  for (; !HD(e); )
    ;
  return e;
}
const $E = /[\0\t\n\r]/g;
function _re() {
  let e = 1, t = "", n = !0, i;
  return r;
  function r(s, l, c) {
    const f = [];
    let h, p, m, y, b;
    for (s = t + (typeof s == "string" ? s.toString() : new TextDecoder(l || void 0).decode(s)), m = 0, t = "", n && (s.charCodeAt(0) === 65279 && m++, n = void 0); m < s.length; ) {
      if ($E.lastIndex = m, h = $E.exec(s), y = h && h.index !== void 0 ? h.index : s.length, b = s.charCodeAt(y), !h) {
        t = s.slice(m);
        break;
      }
      if (b === 10 && m === y && i)
        f.push(-3), i = void 0;
      else
        switch (i && (f.push(-5), i = void 0), m < y && (f.push(s.slice(m, y)), e += y - m), b) {
          case 0: {
            f.push(65533), e++;
            break;
          }
          case 9: {
            for (p = Math.ceil(e / 4) * 4, f.push(-2); e++ < p; ) f.push(-1);
            break;
          }
          case 10: {
            f.push(-4), e = 1;
            break;
          }
          default:
            i = !0, e = 1;
        }
      m = y + 1;
    }
    return c && (i && f.push(-5), t && f.push(t), f.push(null)), f;
  }
}
const Sre = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function kre(e) {
  return e.replace(Sre, Tre);
}
function Tre(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const r = n.charCodeAt(1), s = r === 120 || r === 88;
    return BD(n.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return Xx(n) || e;
}
const KD = {}.hasOwnProperty;
function Ere(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), $re(n)(wre(xre(n).document().write(_re()(e, t, !0))));
}
function $re(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(Ro),
      autolinkProtocol: re,
      autolinkEmail: re,
      atxHeading: s(Ju),
      blockQuote: s(Kt),
      characterEscape: re,
      characterReference: re,
      codeFenced: s(un),
      codeFencedFenceInfo: l,
      codeFencedFenceMeta: l,
      codeIndented: s(un, l),
      codeText: s(Jn, l),
      codeTextData: re,
      data: re,
      codeFlowValue: re,
      definition: s(Cr),
      definitionDestinationString: l,
      definitionLabelString: l,
      definitionTitleString: l,
      emphasis: s(Oo),
      hardBreakEscape: s(Xu),
      hardBreakTrailing: s(Xu),
      htmlFlow: s(In, l),
      htmlFlowData: re,
      htmlText: s(In, l),
      htmlTextData: re,
      image: s(ph),
      label: l,
      link: s(Ro),
      listItem: s(rs),
      listItemValue: y,
      listOrdered: s(No, m),
      listUnordered: s(No),
      paragraph: s(mh),
      reference: I,
      referenceString: l,
      resourceDestinationString: l,
      resourceTitleString: l,
      setextHeading: s(Ju),
      strong: s(Ku),
      thematicBreak: s(vh)
    },
    exit: {
      atxHeading: f(),
      atxHeadingSequence: M,
      autolink: f(),
      autolinkEmail: kt,
      autolinkProtocol: Pe,
      blockQuote: f(),
      characterEscapeValue: D,
      characterReferenceMarkerHexadecimal: Ie,
      characterReferenceMarkerNumeric: Ie,
      characterReferenceValue: pe,
      characterReference: Ce,
      codeFenced: f(k),
      codeFencedFence: w,
      codeFencedFenceInfo: b,
      codeFencedFenceMeta: x,
      codeFlowValue: D,
      codeIndented: f(T),
      codeText: f(ce),
      codeTextData: D,
      data: D,
      definition: f(),
      definitionDestinationString: O,
      definitionLabelString: A,
      definitionTitleString: z,
      emphasis: f(),
      hardBreakEscape: f(ie),
      hardBreakTrailing: f(ie),
      htmlFlow: f(le),
      htmlFlowData: D,
      htmlText: f(se),
      htmlTextData: D,
      image: f(Y),
      label: ge,
      labelText: H,
      lineEnding: ae,
      link: f(L),
      listItem: f(),
      listOrdered: f(),
      listUnordered: f(),
      paragraph: f(),
      referenceString: he,
      resourceDestinationString: S,
      resourceTitleString: X,
      resource: fe,
      setextHeading: f(Z),
      setextHeadingLineSequence: U,
      setextHeadingText: N,
      strong: f(),
      thematicBreak: f()
    }
  };
  WD(t, (e || {}).mdastExtensions || []);
  const n = {};
  return i;
  function i(J) {
    let oe = {
      type: "root",
      children: []
    };
    const _e = {
      stack: [oe],
      tokenStack: [],
      config: t,
      enter: c,
      exit: h,
      buffer: l,
      resume: p,
      data: n
    }, $e = [];
    let Qe = -1;
    for (; ++Qe < J.length; )
      if (J[Qe][1].type === "listOrdered" || J[Qe][1].type === "listUnordered")
        if (J[Qe][0] === "enter")
          $e.push(Qe);
        else {
          const Cn = $e.pop();
          Qe = r(J, Cn, Qe);
        }
    for (Qe = -1; ++Qe < J.length; ) {
      const Cn = t[J[Qe][0]];
      KD.call(Cn, J[Qe][1].type) && Cn[J[Qe][1].type].call(Object.assign({
        sliceSerialize: J[Qe][2].sliceSerialize
      }, _e), J[Qe][1]);
    }
    if (_e.tokenStack.length > 0) {
      const Cn = _e.tokenStack[_e.tokenStack.length - 1];
      (Cn[1] || AE).call(_e, void 0, Cn[0]);
    }
    for (oe.position = {
      start: Ji(J.length > 0 ? J[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Ji(J.length > 0 ? J[J.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, Qe = -1; ++Qe < t.transforms.length; )
      oe = t.transforms[Qe](oe) || oe;
    return oe;
  }
  function r(J, oe, _e) {
    let $e = oe - 1, Qe = -1, Cn = !1, Kr, yn, Or, On;
    for (; ++$e <= _e; ) {
      const Ht = J[$e];
      switch (Ht[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Ht[0] === "enter" ? Qe++ : Qe--, On = void 0;
          break;
        }
        case "lineEndingBlank": {
          Ht[0] === "enter" && (Kr && !On && !Qe && !Or && (Or = $e), On = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          On = void 0;
      }
      if (!Qe && Ht[0] === "enter" && Ht[1].type === "listItemPrefix" || Qe === -1 && Ht[0] === "exit" && (Ht[1].type === "listUnordered" || Ht[1].type === "listOrdered")) {
        if (Kr) {
          let Xn = $e;
          for (yn = void 0; Xn--; ) {
            const hr = J[Xn];
            if (hr[1].type === "lineEnding" || hr[1].type === "lineEndingBlank") {
              if (hr[0] === "exit") continue;
              yn && (J[yn][1].type = "lineEndingBlank", Cn = !0), hr[1].type = "lineEnding", yn = Xn;
            } else if (!(hr[1].type === "linePrefix" || hr[1].type === "blockQuotePrefix" || hr[1].type === "blockQuotePrefixWhitespace" || hr[1].type === "blockQuoteMarker" || hr[1].type === "listItemIndent")) break;
          }
          Or && (!yn || Or < yn) && (Kr._spread = !0), Kr.end = Object.assign({}, yn ? J[yn][1].start : Ht[1].end), J.splice(yn || $e, 0, ["exit", Kr, Ht[2]]), $e++, _e++;
        }
        if (Ht[1].type === "listItemPrefix") {
          const Xn = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Ht[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          Kr = Xn, J.splice($e, 0, ["enter", Xn, Ht[2]]), $e++, _e++, Or = void 0, On = !0;
        }
      }
    }
    return J[oe][1]._spread = Cn, _e;
  }
  function s(J, oe) {
    return _e;
    function _e($e) {
      c.call(this, J($e), $e), oe && oe.call(this, $e);
    }
  }
  function l() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function c(J, oe, _e) {
    this.stack[this.stack.length - 1].children.push(J), this.stack.push(J), this.tokenStack.push([oe, _e || void 0]), J.position = {
      start: Ji(oe.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function f(J) {
    return oe;
    function oe(_e) {
      J && J.call(this, _e), h.call(this, _e);
    }
  }
  function h(J, oe) {
    const _e = this.stack.pop(), $e = this.tokenStack.pop();
    if ($e)
      $e[0].type !== J.type && (oe ? oe.call(this, J, $e[0]) : ($e[1] || AE).call(this, J, $e[0]));
    else throw new Error("Cannot close `" + J.type + "` (" + Kl({
      start: J.start,
      end: J.end
    }) + "): its not open");
    _e.position.end = Ji(J.end);
  }
  function p() {
    return Jx(this.stack.pop());
  }
  function m() {
    this.data.expectingFirstListItemValue = !0;
  }
  function y(J) {
    if (this.data.expectingFirstListItemValue) {
      const oe = this.stack[this.stack.length - 2];
      oe.start = Number.parseInt(this.sliceSerialize(J), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function b() {
    const J = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.lang = J;
  }
  function x() {
    const J = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.meta = J;
  }
  function w() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function k() {
    const J = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.value = J.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function T() {
    const J = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.value = J.replace(/(\r?\n|\r)$/g, "");
  }
  function A(J) {
    const oe = this.resume(), _e = this.stack[this.stack.length - 1];
    _e.label = oe, _e.identifier = Sr(this.sliceSerialize(J)).toLowerCase();
  }
  function z() {
    const J = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.title = J;
  }
  function O() {
    const J = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.url = J;
  }
  function M(J) {
    const oe = this.stack[this.stack.length - 1];
    if (!oe.depth) {
      const _e = this.sliceSerialize(J).length;
      oe.depth = _e;
    }
  }
  function N() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function U(J) {
    const oe = this.stack[this.stack.length - 1];
    oe.depth = this.sliceSerialize(J).codePointAt(0) === 61 ? 1 : 2;
  }
  function Z() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function re(J) {
    const _e = this.stack[this.stack.length - 1].children;
    let $e = _e[_e.length - 1];
    (!$e || $e.type !== "text") && ($e = gh(), $e.position = {
      start: Ji(J.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, _e.push($e)), this.stack.push($e);
  }
  function D(J) {
    const oe = this.stack.pop();
    oe.value += this.sliceSerialize(J), oe.position.end = Ji(J.end);
  }
  function ae(J) {
    const oe = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const _e = oe.children[oe.children.length - 1];
      _e.position.end = Ji(J.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(oe.type) && (re.call(this, J), D.call(this, J));
  }
  function ie() {
    this.data.atHardBreak = !0;
  }
  function le() {
    const J = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.value = J;
  }
  function se() {
    const J = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.value = J;
  }
  function ce() {
    const J = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.value = J;
  }
  function L() {
    const J = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const oe = this.data.referenceType || "shortcut";
      J.type += "Reference", J.referenceType = oe, delete J.url, delete J.title;
    } else
      delete J.identifier, delete J.label;
    this.data.referenceType = void 0;
  }
  function Y() {
    const J = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const oe = this.data.referenceType || "shortcut";
      J.type += "Reference", J.referenceType = oe, delete J.url, delete J.title;
    } else
      delete J.identifier, delete J.label;
    this.data.referenceType = void 0;
  }
  function H(J) {
    const oe = this.sliceSerialize(J), _e = this.stack[this.stack.length - 2];
    _e.label = kre(oe), _e.identifier = Sr(oe).toLowerCase();
  }
  function ge() {
    const J = this.stack[this.stack.length - 1], oe = this.resume(), _e = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, _e.type === "link") {
      const $e = J.children;
      _e.children = $e;
    } else
      _e.alt = oe;
  }
  function S() {
    const J = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.url = J;
  }
  function X() {
    const J = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.title = J;
  }
  function fe() {
    this.data.inReference = void 0;
  }
  function I() {
    this.data.referenceType = "collapsed";
  }
  function he(J) {
    const oe = this.resume(), _e = this.stack[this.stack.length - 1];
    _e.label = oe, _e.identifier = Sr(this.sliceSerialize(J)).toLowerCase(), this.data.referenceType = "full";
  }
  function Ie(J) {
    this.data.characterReferenceType = J.type;
  }
  function pe(J) {
    const oe = this.sliceSerialize(J), _e = this.data.characterReferenceType;
    let $e;
    _e ? ($e = BD(oe, _e === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : $e = Xx(oe);
    const Qe = this.stack[this.stack.length - 1];
    Qe.value += $e;
  }
  function Ce(J) {
    const oe = this.stack.pop();
    oe.position.end = Ji(J.end);
  }
  function Pe(J) {
    D.call(this, J);
    const oe = this.stack[this.stack.length - 1];
    oe.url = this.sliceSerialize(J);
  }
  function kt(J) {
    D.call(this, J);
    const oe = this.stack[this.stack.length - 1];
    oe.url = "mailto:" + this.sliceSerialize(J);
  }
  function Kt() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function un() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Jn() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Cr() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function Oo() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Ju() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Xu() {
    return {
      type: "break"
    };
  }
  function In() {
    return {
      type: "html",
      value: ""
    };
  }
  function ph() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Ro() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function No(J) {
    return {
      type: "list",
      ordered: J.type === "listOrdered",
      start: null,
      spread: J._spread,
      children: []
    };
  }
  function rs(J) {
    return {
      type: "listItem",
      spread: J._spread,
      checked: null,
      children: []
    };
  }
  function mh() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Ku() {
    return {
      type: "strong",
      children: []
    };
  }
  function gh() {
    return {
      type: "text",
      value: ""
    };
  }
  function vh() {
    return {
      type: "thematicBreak"
    };
  }
}
function Ji(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function WD(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const i = t[n];
    Array.isArray(i) ? WD(e, i) : Are(e, i);
  }
}
function Are(e, t) {
  let n;
  for (n in t)
    if (KD.call(t, n))
      switch (n) {
        case "canContainEols": {
          const i = t[n];
          i && e[n].push(...i);
          break;
        }
        case "transforms": {
          const i = t[n];
          i && e[n].push(...i);
          break;
        }
        case "enter":
        case "exit": {
          const i = t[n];
          i && Object.assign(e[n], i);
          break;
        }
      }
}
function AE(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Kl({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Kl({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Kl({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function zre(e) {
  const t = this;
  t.parser = n;
  function n(i) {
    return Ere(i, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function Ire(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Cre(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function Ore(e, t) {
  const n = t.value ? t.value + `
` : "", i = {};
  t.lang && (i.className = ["language-" + t.lang]);
  let r = {
    type: "element",
    tagName: "code",
    properties: i,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (r.data = { meta: t.meta }), e.patch(t, r), r = e.applyData(t, r), r = { type: "element", tagName: "pre", properties: {}, children: [r] }, e.patch(t, r), r;
}
function Rre(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Nre(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Mre(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", i = String(t.identifier).toUpperCase(), r = Co(i.toLowerCase()), s = e.footnoteOrder.indexOf(i);
  let l, c = e.footnoteCounts.get(i);
  c === void 0 ? (c = 0, e.footnoteOrder.push(i), l = e.footnoteOrder.length) : l = s + 1, c += 1, e.footnoteCounts.set(i, c);
  const f = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + r,
      id: n + "fnref-" + r + (c > 1 ? "-" + c : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(l) }]
  };
  e.patch(t, f);
  const h = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [f]
  };
  return e.patch(t, h), e.applyData(t, h);
}
function Dre(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function jre(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function QD(e, t) {
  const n = t.referenceType;
  let i = "]";
  if (n === "collapsed" ? i += "[]" : n === "full" && (i += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + i }];
  const r = e.all(t), s = r[0];
  s && s.type === "text" ? s.value = "[" + s.value : r.unshift({ type: "text", value: "[" });
  const l = r[r.length - 1];
  return l && l.type === "text" ? l.value += i : r.push({ type: "text", value: i }), r;
}
function Pre(e, t) {
  const n = String(t.identifier).toUpperCase(), i = e.definitionById.get(n);
  if (!i)
    return QD(e, t);
  const r = { src: Co(i.url || ""), alt: t.alt };
  i.title !== null && i.title !== void 0 && (r.title = i.title);
  const s = { type: "element", tagName: "img", properties: r, children: [] };
  return e.patch(t, s), e.applyData(t, s);
}
function Ure(e, t) {
  const n = { src: Co(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const i = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, i), e.applyData(t, i);
}
function Lre(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const i = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, i), e.applyData(t, i);
}
function Bre(e, t) {
  const n = String(t.identifier).toUpperCase(), i = e.definitionById.get(n);
  if (!i)
    return QD(e, t);
  const r = { href: Co(i.url || "") };
  i.title !== null && i.title !== void 0 && (r.title = i.title);
  const s = {
    type: "element",
    tagName: "a",
    properties: r,
    children: e.all(t)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function Zre(e, t) {
  const n = { href: Co(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const i = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function Vre(e, t, n) {
  const i = e.all(t), r = n ? Fre(n) : ej(t), s = {}, l = [];
  if (typeof t.checked == "boolean") {
    const p = i[0];
    let m;
    p && p.type === "element" && p.tagName === "p" ? m = p : (m = { type: "element", tagName: "p", properties: {}, children: [] }, i.unshift(m)), m.children.length > 0 && m.children.unshift({ type: "text", value: " " }), m.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), s.className = ["task-list-item"];
  }
  let c = -1;
  for (; ++c < i.length; ) {
    const p = i[c];
    (r || c !== 0 || p.type !== "element" || p.tagName !== "p") && l.push({ type: "text", value: `
` }), p.type === "element" && p.tagName === "p" && !r ? l.push(...p.children) : l.push(p);
  }
  const f = i[i.length - 1];
  f && (r || f.type !== "element" || f.tagName !== "p") && l.push({ type: "text", value: `
` });
  const h = { type: "element", tagName: "li", properties: s, children: l };
  return e.patch(t, h), e.applyData(t, h);
}
function Fre(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let i = -1;
    for (; !t && ++i < n.length; )
      t = ej(n[i]);
  }
  return t;
}
function ej(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function Hre(e, t) {
  const n = {}, i = e.all(t);
  let r = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++r < i.length; ) {
    const l = i[r];
    if (l.type === "element" && l.tagName === "li" && l.properties && Array.isArray(l.properties.className) && l.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const s = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(i, !0)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function qre(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Gre(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function Yre(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Jre(e, t) {
  const n = e.all(t), i = n.shift(), r = [];
  if (i) {
    const l = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([i], !0)
    };
    e.patch(t.children[0], l), r.push(l);
  }
  if (n.length > 0) {
    const l = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, c = Hx(t.children[1]), f = RD(t.children[t.children.length - 1]);
    c && f && (l.position = { start: c, end: f }), r.push(l);
  }
  const s = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(r, !0)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function Xre(e, t, n) {
  const i = n ? n.children : void 0, s = (i ? i.indexOf(t) : 1) === 0 ? "th" : "td", l = n && n.type === "table" ? n.align : void 0, c = l ? l.length : t.children.length;
  let f = -1;
  const h = [];
  for (; ++f < c; ) {
    const m = t.children[f], y = {}, b = l ? l[f] : void 0;
    b && (y.align = b);
    let x = { type: "element", tagName: s, properties: y, children: [] };
    m && (x.children = e.all(m), e.patch(m, x), x = e.applyData(m, x)), h.push(x);
  }
  const p = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(h, !0)
  };
  return e.patch(t, p), e.applyData(t, p);
}
function Kre(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const zE = 9, IE = 32;
function Wre(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let i = n.exec(t), r = 0;
  const s = [];
  for (; i; )
    s.push(
      CE(t.slice(r, i.index), r > 0, !0),
      i[0]
    ), r = i.index + i[0].length, i = n.exec(t);
  return s.push(CE(t.slice(r), r > 0, !1)), s.join("");
}
function CE(e, t, n) {
  let i = 0, r = e.length;
  if (t) {
    let s = e.codePointAt(i);
    for (; s === zE || s === IE; )
      i++, s = e.codePointAt(i);
  }
  if (n) {
    let s = e.codePointAt(r - 1);
    for (; s === zE || s === IE; )
      r--, s = e.codePointAt(r - 1);
  }
  return r > i ? e.slice(i, r) : "";
}
function Qre(e, t) {
  const n = { type: "text", value: Wre(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function eie(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const tie = {
  blockquote: Ire,
  break: Cre,
  code: Ore,
  delete: Rre,
  emphasis: Nre,
  footnoteReference: Mre,
  heading: Dre,
  html: jre,
  imageReference: Pre,
  image: Ure,
  inlineCode: Lre,
  linkReference: Bre,
  link: Zre,
  listItem: Vre,
  list: Hre,
  paragraph: qre,
  // @ts-expect-error: root is different, but hard to type.
  root: Gre,
  strong: Yre,
  table: Jre,
  tableCell: Kre,
  tableRow: Xre,
  text: Qre,
  thematicBreak: eie,
  toml: Id,
  yaml: Id,
  definition: Id,
  footnoteDefinition: Id
};
function Id() {
}
const tj = -1, dh = 0, Ql = 1, Sf = 2, Wx = 3, Qx = 4, ew = 5, tw = 6, nj = 7, rj = 8, OE = typeof self == "object" ? self : globalThis, nie = (e, t) => {
  const n = (r, s) => (e.set(s, r), r), i = (r) => {
    if (e.has(r))
      return e.get(r);
    const [s, l] = t[r];
    switch (s) {
      case dh:
      case tj:
        return n(l, r);
      case Ql: {
        const c = n([], r);
        for (const f of l)
          c.push(i(f));
        return c;
      }
      case Sf: {
        const c = n({}, r);
        for (const [f, h] of l)
          c[i(f)] = i(h);
        return c;
      }
      case Wx:
        return n(new Date(l), r);
      case Qx: {
        const { source: c, flags: f } = l;
        return n(new RegExp(c, f), r);
      }
      case ew: {
        const c = n(/* @__PURE__ */ new Map(), r);
        for (const [f, h] of l)
          c.set(i(f), i(h));
        return c;
      }
      case tw: {
        const c = n(/* @__PURE__ */ new Set(), r);
        for (const f of l)
          c.add(i(f));
        return c;
      }
      case nj: {
        const { name: c, message: f } = l;
        return n(new OE[c](f), r);
      }
      case rj:
        return n(BigInt(l), r);
      case "BigInt":
        return n(Object(BigInt(l)), r);
      case "ArrayBuffer":
        return n(new Uint8Array(l).buffer, l);
      case "DataView": {
        const { buffer: c } = new Uint8Array(l);
        return n(new DataView(c), l);
      }
    }
    return n(new OE[s](l), r);
  };
  return i;
}, RE = (e) => nie(/* @__PURE__ */ new Map(), e)(0), qs = "", { toString: rie } = {}, { keys: iie } = Object, Pl = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [dh, t];
  const n = rie.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Ql, qs];
    case "Object":
      return [Sf, qs];
    case "Date":
      return [Wx, qs];
    case "RegExp":
      return [Qx, qs];
    case "Map":
      return [ew, qs];
    case "Set":
      return [tw, qs];
    case "DataView":
      return [Ql, n];
  }
  return n.includes("Array") ? [Ql, n] : n.includes("Error") ? [nj, n] : [Sf, n];
}, Cd = ([e, t]) => e === dh && (t === "function" || t === "symbol"), aie = (e, t, n, i) => {
  const r = (l, c) => {
    const f = i.push(l) - 1;
    return n.set(c, f), f;
  }, s = (l) => {
    if (n.has(l))
      return n.get(l);
    let [c, f] = Pl(l);
    switch (c) {
      case dh: {
        let p = l;
        switch (f) {
          case "bigint":
            c = rj, p = l.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + f);
            p = null;
            break;
          case "undefined":
            return r([tj], l);
        }
        return r([c, p], l);
      }
      case Ql: {
        if (f) {
          let y = l;
          return f === "DataView" ? y = new Uint8Array(l.buffer) : f === "ArrayBuffer" && (y = new Uint8Array(l)), r([f, [...y]], l);
        }
        const p = [], m = r([c, p], l);
        for (const y of l)
          p.push(s(y));
        return m;
      }
      case Sf: {
        if (f)
          switch (f) {
            case "BigInt":
              return r([f, l.toString()], l);
            case "Boolean":
            case "Number":
            case "String":
              return r([f, l.valueOf()], l);
          }
        if (t && "toJSON" in l)
          return s(l.toJSON());
        const p = [], m = r([c, p], l);
        for (const y of iie(l))
          (e || !Cd(Pl(l[y]))) && p.push([s(y), s(l[y])]);
        return m;
      }
      case Wx:
        return r([c, l.toISOString()], l);
      case Qx: {
        const { source: p, flags: m } = l;
        return r([c, { source: p, flags: m }], l);
      }
      case ew: {
        const p = [], m = r([c, p], l);
        for (const [y, b] of l)
          (e || !(Cd(Pl(y)) || Cd(Pl(b)))) && p.push([s(y), s(b)]);
        return m;
      }
      case tw: {
        const p = [], m = r([c, p], l);
        for (const y of l)
          (e || !Cd(Pl(y))) && p.push(s(y));
        return m;
      }
    }
    const { message: h } = l;
    return r([c, { name: f, message: h }], l);
  };
  return s;
}, NE = (e, { json: t, lossy: n } = {}) => {
  const i = [];
  return aie(!(t || n), !!t, /* @__PURE__ */ new Map(), i)(e), i;
}, kf = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? RE(NE(e, t)) : structuredClone(e)
) : (e, t) => RE(NE(e, t));
function sie(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function oie(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function lie(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || sie, i = e.options.footnoteBackLabel || oie, r = e.options.footnoteLabel || "Footnotes", s = e.options.footnoteLabelTagName || "h2", l = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, c = [];
  let f = -1;
  for (; ++f < e.footnoteOrder.length; ) {
    const h = e.footnoteById.get(
      e.footnoteOrder[f]
    );
    if (!h)
      continue;
    const p = e.all(h), m = String(h.identifier).toUpperCase(), y = Co(m.toLowerCase());
    let b = 0;
    const x = [], w = e.footnoteCounts.get(m);
    for (; w !== void 0 && ++b <= w; ) {
      x.length > 0 && x.push({ type: "text", value: " " });
      let A = typeof n == "string" ? n : n(f, b);
      typeof A == "string" && (A = { type: "text", value: A }), x.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + y + (b > 1 ? "-" + b : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof i == "string" ? i : i(f, b),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(A) ? A : [A]
      });
    }
    const k = p[p.length - 1];
    if (k && k.type === "element" && k.tagName === "p") {
      const A = k.children[k.children.length - 1];
      A && A.type === "text" ? A.value += " " : k.children.push({ type: "text", value: " " }), k.children.push(...x);
    } else
      p.push(...x);
    const T = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + y },
      children: e.wrap(p, !0)
    };
    e.patch(h, T), c.push(T);
  }
  if (c.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: s,
          properties: {
            ...kf(l),
            id: "footnote-label"
          },
          children: [{ type: "text", value: r }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(c, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const fh = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(e) {
    if (e == null)
      return fie;
    if (typeof e == "function")
      return hh(e);
    if (typeof e == "object")
      return Array.isArray(e) ? uie(e) : cie(e);
    if (typeof e == "string")
      return die(e);
    throw new Error("Expected function, string, or object as test");
  })
);
function uie(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = fh(e[n]);
  return hh(i);
  function i(...r) {
    let s = -1;
    for (; ++s < t.length; )
      if (t[s].apply(this, r)) return !0;
    return !1;
  }
}
function cie(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return hh(n);
  function n(i) {
    const r = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      i
    );
    let s;
    for (s in e)
      if (r[s] !== t[s]) return !1;
    return !0;
  }
}
function die(e) {
  return hh(t);
  function t(n) {
    return n && n.type === e;
  }
}
function hh(e) {
  return t;
  function t(n, i, r) {
    return !!(hie(n) && e.call(
      this,
      n,
      typeof i == "number" ? i : void 0,
      r || void 0
    ));
  }
}
function fie() {
  return !0;
}
function hie(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const ij = [], pie = !0, Mv = !1, mie = "skip";
function aj(e, t, n, i) {
  let r;
  typeof t == "function" && typeof n != "function" ? (i = n, n = t) : r = t;
  const s = fh(r), l = i ? -1 : 1;
  c(e, void 0, [])();
  function c(f, h, p) {
    const m = (
      /** @type {Record<string, unknown>} */
      f && typeof f == "object" ? f : {}
    );
    if (typeof m.type == "string") {
      const b = (
        // `hast`
        typeof m.tagName == "string" ? m.tagName : (
          // `xast`
          typeof m.name == "string" ? m.name : void 0
        )
      );
      Object.defineProperty(y, "name", {
        value: "node (" + (f.type + (b ? "<" + b + ">" : "")) + ")"
      });
    }
    return y;
    function y() {
      let b = ij, x, w, k;
      if ((!t || s(f, h, p[p.length - 1] || void 0)) && (b = gie(n(f, p)), b[0] === Mv))
        return b;
      if ("children" in f && f.children) {
        const T = (
          /** @type {UnistParent} */
          f
        );
        if (T.children && b[0] !== mie)
          for (w = (i ? T.children.length : -1) + l, k = p.concat(T); w > -1 && w < T.children.length; ) {
            const A = T.children[w];
            if (x = c(A, w, k)(), x[0] === Mv)
              return x;
            w = typeof x[1] == "number" ? x[1] : w + l;
          }
      }
      return b;
    }
  }
}
function gie(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [pie, e] : e == null ? ij : [e];
}
function nw(e, t, n, i) {
  let r, s, l;
  typeof t == "function" && typeof n != "function" ? (s = void 0, l = t, r = n) : (s = t, l = n, r = i), aj(e, s, c, r);
  function c(f, h) {
    const p = h[h.length - 1], m = p ? p.children.indexOf(f) : void 0;
    return l(f, m, p);
  }
}
const Dv = {}.hasOwnProperty, vie = {};
function yie(e, t) {
  const n = t || vie, i = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), l = { ...tie, ...n.handlers }, c = {
    all: h,
    applyData: xie,
    definitionById: i,
    footnoteById: r,
    footnoteCounts: s,
    footnoteOrder: [],
    handlers: l,
    one: f,
    options: n,
    patch: bie,
    wrap: _ie
  };
  return nw(e, function(p) {
    if (p.type === "definition" || p.type === "footnoteDefinition") {
      const m = p.type === "definition" ? i : r, y = String(p.identifier).toUpperCase();
      m.has(y) || m.set(y, p);
    }
  }), c;
  function f(p, m) {
    const y = p.type, b = c.handlers[y];
    if (Dv.call(c.handlers, y) && b)
      return b(c, p, m);
    if (c.options.passThrough && c.options.passThrough.includes(y)) {
      if ("children" in p) {
        const { children: w, ...k } = p, T = kf(k);
        return T.children = c.all(p), T;
      }
      return kf(p);
    }
    return (c.options.unknownHandler || wie)(c, p, m);
  }
  function h(p) {
    const m = [];
    if ("children" in p) {
      const y = p.children;
      let b = -1;
      for (; ++b < y.length; ) {
        const x = c.one(y[b], p);
        if (x) {
          if (b && y[b - 1].type === "break" && (!Array.isArray(x) && x.type === "text" && (x.value = ME(x.value)), !Array.isArray(x) && x.type === "element")) {
            const w = x.children[0];
            w && w.type === "text" && (w.value = ME(w.value));
          }
          Array.isArray(x) ? m.push(...x) : m.push(x);
        }
      }
    }
    return m;
  }
}
function bie(e, t) {
  e.position && (t.position = ote(e));
}
function xie(e, t) {
  let n = t;
  if (e && e.data) {
    const i = e.data.hName, r = e.data.hChildren, s = e.data.hProperties;
    if (typeof i == "string")
      if (n.type === "element")
        n.tagName = i;
      else {
        const l = "children" in n ? n.children : [n];
        n = { type: "element", tagName: i, properties: {}, children: l };
      }
    n.type === "element" && s && Object.assign(n.properties, kf(s)), "children" in n && n.children && r !== null && r !== void 0 && (n.children = r);
  }
  return n;
}
function wie(e, t) {
  const n = t.data || {}, i = "value" in t && !(Dv.call(n, "hProperties") || Dv.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function _ie(e, t) {
  const n = [];
  let i = -1;
  for (t && n.push({ type: "text", value: `
` }); ++i < e.length; )
    i && n.push({ type: "text", value: `
` }), n.push(e[i]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function ME(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function DE(e, t) {
  const n = yie(e, t), i = n.one(e, void 0), r = lie(n), s = Array.isArray(i) ? { type: "root", children: i } : i || { type: "root", children: [] };
  return r && s.children.push({ type: "text", value: `
` }, r), s;
}
function Sie(e, t) {
  return e && "run" in e ? async function(n, i) {
    const r = (
      /** @type {HastRoot} */
      DE(n, { file: i, ...t })
    );
    await e.run(r, i);
  } : function(n, i) {
    return (
      /** @type {HastRoot} */
      DE(n, { file: i, ...e || t })
    );
  };
}
function jE(e) {
  if (e)
    throw e;
}
var gg, PE;
function kie() {
  if (PE) return gg;
  PE = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, i = Object.getOwnPropertyDescriptor, r = function(h) {
    return typeof Array.isArray == "function" ? Array.isArray(h) : t.call(h) === "[object Array]";
  }, s = function(h) {
    if (!h || t.call(h) !== "[object Object]")
      return !1;
    var p = e.call(h, "constructor"), m = h.constructor && h.constructor.prototype && e.call(h.constructor.prototype, "isPrototypeOf");
    if (h.constructor && !p && !m)
      return !1;
    var y;
    for (y in h)
      ;
    return typeof y > "u" || e.call(h, y);
  }, l = function(h, p) {
    n && p.name === "__proto__" ? n(h, p.name, {
      enumerable: !0,
      configurable: !0,
      value: p.newValue,
      writable: !0
    }) : h[p.name] = p.newValue;
  }, c = function(h, p) {
    if (p === "__proto__")
      if (e.call(h, p)) {
        if (i)
          return i(h, p).value;
      } else return;
    return h[p];
  };
  return gg = function f() {
    var h, p, m, y, b, x, w = arguments[0], k = 1, T = arguments.length, A = !1;
    for (typeof w == "boolean" && (A = w, w = arguments[1] || {}, k = 2), (w == null || typeof w != "object" && typeof w != "function") && (w = {}); k < T; ++k)
      if (h = arguments[k], h != null)
        for (p in h)
          m = c(w, p), y = c(h, p), w !== y && (A && y && (s(y) || (b = r(y))) ? (b ? (b = !1, x = m && r(m) ? m : []) : x = m && s(m) ? m : {}, l(w, { name: p, newValue: f(A, x, y) })) : typeof y < "u" && l(w, { name: p, newValue: y }));
    return w;
  }, gg;
}
var Tie = kie();
const vg = /* @__PURE__ */ la(Tie);
function jv(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function Eie() {
  const e = [], t = { run: n, use: i };
  return t;
  function n(...r) {
    let s = -1;
    const l = r.pop();
    if (typeof l != "function")
      throw new TypeError("Expected function as last argument, not " + l);
    c(null, ...r);
    function c(f, ...h) {
      const p = e[++s];
      let m = -1;
      if (f) {
        l(f);
        return;
      }
      for (; ++m < r.length; )
        (h[m] === null || h[m] === void 0) && (h[m] = r[m]);
      r = h, p ? $ie(p, c)(...h) : l(null, ...h);
    }
  }
  function i(r) {
    if (typeof r != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + r
      );
    return e.push(r), t;
  }
}
function $ie(e, t) {
  let n;
  return i;
  function i(...l) {
    const c = e.length > l.length;
    let f;
    c && l.push(r);
    try {
      f = e.apply(this, l);
    } catch (h) {
      const p = (
        /** @type {Error} */
        h
      );
      if (c && n)
        throw p;
      return r(p);
    }
    c || (f && f.then && typeof f.then == "function" ? f.then(s, r) : f instanceof Error ? r(f) : s(f));
  }
  function r(l, ...c) {
    n || (n = !0, t(l, ...c));
  }
  function s(l) {
    r(null, l);
  }
}
const Ur = { basename: Aie, dirname: zie, extname: Iie, join: Cie, sep: "/" };
function Aie(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Yu(e);
  let n = 0, i = -1, r = e.length, s;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; r--; )
      if (e.codePointAt(r) === 47) {
        if (s) {
          n = r + 1;
          break;
        }
      } else i < 0 && (s = !0, i = r + 1);
    return i < 0 ? "" : e.slice(n, i);
  }
  if (t === e)
    return "";
  let l = -1, c = t.length - 1;
  for (; r--; )
    if (e.codePointAt(r) === 47) {
      if (s) {
        n = r + 1;
        break;
      }
    } else
      l < 0 && (s = !0, l = r + 1), c > -1 && (e.codePointAt(r) === t.codePointAt(c--) ? c < 0 && (i = r) : (c = -1, i = l));
  return n === i ? i = l : i < 0 && (i = e.length), e.slice(n, i);
}
function zie(e) {
  if (Yu(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, i;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (i) {
        t = n;
        break;
      }
    } else i || (i = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function Iie(e) {
  Yu(e);
  let t = e.length, n = -1, i = 0, r = -1, s = 0, l;
  for (; t--; ) {
    const c = e.codePointAt(t);
    if (c === 47) {
      if (l) {
        i = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (l = !0, n = t + 1), c === 46 ? r < 0 ? r = t : s !== 1 && (s = 1) : r > -1 && (s = -1);
  }
  return r < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && r === n - 1 && r === i + 1 ? "" : e.slice(r, n);
}
function Cie(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    Yu(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : Oie(n);
}
function Oie(e) {
  Yu(e);
  const t = e.codePointAt(0) === 47;
  let n = Rie(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function Rie(e, t) {
  let n = "", i = 0, r = -1, s = 0, l = -1, c, f;
  for (; ++l <= e.length; ) {
    if (l < e.length)
      c = e.codePointAt(l);
    else {
      if (c === 47)
        break;
      c = 47;
    }
    if (c === 47) {
      if (!(r === l - 1 || s === 1)) if (r !== l - 1 && s === 2) {
        if (n.length < 2 || i !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (f = n.lastIndexOf("/"), f !== n.length - 1) {
              f < 0 ? (n = "", i = 0) : (n = n.slice(0, f), i = n.length - 1 - n.lastIndexOf("/")), r = l, s = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", i = 0, r = l, s = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", i = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(r + 1, l) : n = e.slice(r + 1, l), i = l - r - 1;
      r = l, s = 0;
    } else c === 46 && s > -1 ? s++ : s = -1;
  }
  return n;
}
function Yu(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const Nie = { cwd: Mie };
function Mie() {
  return "/";
}
function Pv(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function Die(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Pv(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return jie(e);
}
function jie(e) {
  if (e.hostname !== "") {
    const i = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw i.code = "ERR_INVALID_FILE_URL_HOST", i;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const i = t.codePointAt(n + 2);
      if (i === 70 || i === 102) {
        const r = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw r.code = "ERR_INVALID_FILE_URL_PATH", r;
      }
    }
  return decodeURIComponent(t);
}
const yg = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class sj {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? Pv(t) ? n = { path: t } : typeof t == "string" || Pie(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : Nie.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let i = -1;
    for (; ++i < yg.length; ) {
      const s = yg[i];
      s in n && n[s] !== void 0 && n[s] !== null && (this[s] = s === "history" ? [...n[s]] : n[s]);
    }
    let r;
    for (r in n)
      yg.includes(r) || (this[r] = n[r]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Ur.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    xg(t, "basename"), bg(t, "basename"), this.path = Ur.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Ur.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    UE(this.basename, "dirname"), this.path = Ur.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Ur.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (bg(t, "extname"), UE(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Ur.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Pv(t) && (t = Die(t)), xg(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Ur.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    xg(t, "stem"), bg(t, "stem"), this.path = Ur.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, i) {
    const r = this.message(t, n, i);
    throw r.fatal = !0, r;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, i) {
    const r = this.message(t, n, i);
    return r.fatal = void 0, r;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, i) {
    const r = new ln(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      i
    );
    return this.path && (r.name = this.path + ":" + r.name, r.file = this.path), r.fatal = !1, this.messages.push(r), r;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function bg(e, t) {
  if (e && e.includes(Ur.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Ur.sep + "`"
    );
}
function xg(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function UE(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function Pie(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const Uie = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(e) {
    const i = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), r = i[e], s = function() {
      return r.apply(s, arguments);
    };
    return Object.setPrototypeOf(s, i), s;
  })
), Lie = {}.hasOwnProperty;
class rw extends Uie {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = Eie();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new rw()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const i = this.attachers[n];
      t.use(...i);
    }
    return t.data(vg(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (Sg("data", this.frozen), this.namespace[t] = n, this) : Lie.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (Sg("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...i] = this.attachers[this.freezeIndex];
      if (i[0] === !1)
        continue;
      i[0] === !0 && (i[0] = void 0);
      const r = n.call(t, ...i);
      typeof r == "function" && this.transformers.use(r);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Od(t), i = this.parser || this.Parser;
    return wg("parse", i), i(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const i = this;
    return this.freeze(), wg("process", this.parser || this.Parser), _g("process", this.compiler || this.Compiler), n ? r(void 0, n) : new Promise(r);
    function r(s, l) {
      const c = Od(t), f = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        i.parse(c)
      );
      i.run(f, c, function(p, m, y) {
        if (p || !m || !y)
          return h(p);
        const b = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          m
        ), x = i.stringify(b, y);
        Vie(x) ? y.value = x : y.result = x, h(
          p,
          /** @type {VFileWithOutput<CompileResult>} */
          y
        );
      });
      function h(p, m) {
        p || !m ? l(p) : s ? s(m) : n(void 0, m);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, i;
    return this.freeze(), wg("processSync", this.parser || this.Parser), _g("processSync", this.compiler || this.Compiler), this.process(t, r), BE("processSync", "process", n), i;
    function r(s, l) {
      n = !0, jE(s), i = l;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, i) {
    LE(t), this.freeze();
    const r = this.transformers;
    return !i && typeof n == "function" && (i = n, n = void 0), i ? s(void 0, i) : new Promise(s);
    function s(l, c) {
      const f = Od(n);
      r.run(t, f, h);
      function h(p, m, y) {
        const b = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          m || t
        );
        p ? c(p) : l ? l(b) : i(void 0, b, y);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let i = !1, r;
    return this.run(t, n, s), BE("runSync", "run", i), r;
    function s(l, c) {
      jE(l), r = c, i = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const i = Od(n), r = this.compiler || this.Compiler;
    return _g("stringify", r), LE(t), r(t, i);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const i = this.attachers, r = this.namespace;
    if (Sg("use", this.frozen), t != null) if (typeof t == "function")
      f(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? c(t) : l(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function s(h) {
      if (typeof h == "function")
        f(h, []);
      else if (typeof h == "object")
        if (Array.isArray(h)) {
          const [p, ...m] = (
            /** @type {PluginTuple<Array<unknown>>} */
            h
          );
          f(p, m);
        } else
          l(h);
      else
        throw new TypeError("Expected usable value, not `" + h + "`");
    }
    function l(h) {
      if (!("plugins" in h) && !("settings" in h))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      c(h.plugins), h.settings && (r.settings = vg(!0, r.settings, h.settings));
    }
    function c(h) {
      let p = -1;
      if (h != null) if (Array.isArray(h))
        for (; ++p < h.length; ) {
          const m = h[p];
          s(m);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + h + "`");
    }
    function f(h, p) {
      let m = -1, y = -1;
      for (; ++m < i.length; )
        if (i[m][0] === h) {
          y = m;
          break;
        }
      if (y === -1)
        i.push([h, ...p]);
      else if (p.length > 0) {
        let [b, ...x] = p;
        const w = i[y][1];
        jv(w) && jv(b) && (b = vg(!0, w, b)), i[y] = [h, b, ...x];
      }
    }
  }
}
const Bie = new rw().freeze();
function wg(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function _g(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function Sg(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function LE(e) {
  if (!jv(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function BE(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Od(e) {
  return Zie(e) ? e : new sj(e);
}
function Zie(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function Vie(e) {
  return typeof e == "string" || Fie(e);
}
function Fie(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const Hie = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", ZE = [], VE = { allowDangerousHtml: !0 }, qie = /^(https?|ircs?|mailto|xmpp)$/i, Gie = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Yie(e) {
  const t = Jie(e), n = Xie(e);
  return Kie(t.runSync(t.parse(n), n), e);
}
function Jie(e) {
  const t = e.rehypePlugins || ZE, n = e.remarkPlugins || ZE, i = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...VE } : VE;
  return Bie().use(zre).use(n).use(Sie, i).use(t);
}
function Xie(e) {
  const t = e.children || "", n = new sj();
  return typeof t == "string" && (n.value = t), n;
}
function Kie(e, t) {
  const n = t.allowedElements, i = t.allowElement, r = t.components, s = t.disallowedElements, l = t.skipHtml, c = t.unwrapDisallowed, f = t.urlTransform || Wie;
  for (const p of Gie)
    Object.hasOwn(t, p.from) && ("" + p.from + (p.to ? "use `" + p.to + "` instead" : "remove it") + Hie + p.id, void 0);
  return nw(e, h), fte(e, {
    Fragment: C.Fragment,
    components: r,
    ignoreInvalidStyle: !0,
    jsx: C.jsx,
    jsxs: C.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function h(p, m, y) {
    if (p.type === "raw" && y && typeof m == "number")
      return l ? y.children.splice(m, 1) : y.children[m] = { type: "text", value: p.value }, m;
    if (p.type === "element") {
      let b;
      for (b in hg)
        if (Object.hasOwn(hg, b) && Object.hasOwn(p.properties, b)) {
          const x = p.properties[b], w = hg[b];
          (w === null || w.includes(p.tagName)) && (p.properties[b] = f(String(x || ""), b, p));
        }
    }
    if (p.type === "element") {
      let b = n ? !n.includes(p.tagName) : s ? s.includes(p.tagName) : !1;
      if (!b && i && typeof m == "number" && (b = !i(p, m, y)), b && y && typeof m == "number")
        return c && p.children ? y.children.splice(m, 1, ...p.children) : y.children.splice(m, 1), m;
    }
  }
}
function Wie(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), i = e.indexOf("#"), r = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    r !== -1 && t > r || n !== -1 && t > n || i !== -1 && t > i || // It is a protocol, it should be allowed.
    qie.test(e.slice(0, t)) ? e : ""
  );
}
var Qie = (e, t) => typeof e == "string" ? e === t : JSON.stringify(e) === JSON.stringify(t), eae = (e, t) => {
  if (!e || !t) return !1;
  const n = (i) => {
    const { position: r, data: s, ...l } = i || {};
    return l;
  };
  return JSON.stringify(n(e.properties)) === JSON.stringify(n(t.properties)) && Qie(e.children, t.children);
}, iw = (e, t) => eae(e.node, t.node), tae = (e = {}) => Object.fromEntries(
  Object.entries(e ?? {}).map(([t, n]) => {
    if (!n) return [t, n];
    const i = n, r = ({ node: s, ...l }) => /* @__PURE__ */ C.jsx(i, { ...l });
    return [t, $.memo(r, iw)];
  })
), aw = $.createContext(null), oj = () => $.useContext(aw) !== null, nae = ({ children: e, ...t }) => /* @__PURE__ */ C.jsx(aw.Provider, { value: t, children: e }), rae = $.memo(nae, iw), iae = ({ node: e, ...t }) => /* @__PURE__ */ C.jsx("pre", { ...t }), aae = ({ node: e, ...t }) => /* @__PURE__ */ C.jsx("code", { ...t }), sw = ({ node: e, components: { Pre: t, Code: n }, code: i }) => /* @__PURE__ */ C.jsx(t, { children: /* @__PURE__ */ C.jsx(n, { node: e, children: i }) }), sae = () => null, oae = ({
  node: e,
  components: { Pre: t, Code: n, SyntaxHighlighter: i, CodeHeader: r },
  language: s,
  code: l
}) => {
  const c = $.useMemo(() => ({ Pre: t, Code: n }), [t, n]), f = s ? i : sw;
  return /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
    /* @__PURE__ */ C.jsx(r, { node: e, language: s, code: l }),
    /* @__PURE__ */ C.jsx(
      f,
      {
        node: e,
        components: c,
        language: s ?? "unknown",
        code: l
      }
    )
  ] });
}, kg = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var FE;
function lae() {
  return FE || (FE = 1, (function(e) {
    (function() {
      var t = {}.hasOwnProperty;
      function n() {
        for (var s = "", l = 0; l < arguments.length; l++) {
          var c = arguments[l];
          c && (s = r(s, i(c)));
        }
        return s;
      }
      function i(s) {
        if (typeof s == "string" || typeof s == "number")
          return s;
        if (typeof s != "object")
          return "";
        if (Array.isArray(s))
          return n.apply(null, s);
        if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
          return s.toString();
        var l = "";
        for (var c in s)
          t.call(s, c) && s[c] && (l = r(l, c));
        return l;
      }
      function r(s, l) {
        return l ? s ? s + " " + l : s + l : s;
      }
      e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
    })();
  })(kg)), kg.exports;
}
var uae = lae();
const lj = /* @__PURE__ */ la(uae);
var HE = ({
  className: e,
  ...t
}) => ({ className: n, ...i }) => ({
  className: lj(e, n),
  ...t,
  ...i
}), cae = ({
  node: e,
  components: {
    Pre: t,
    Code: n,
    SyntaxHighlighter: i,
    CodeHeader: r
  },
  componentsByLanguage: s = {},
  children: l,
  ...c
}) => {
  const f = $.useContext(aw), h = HE(f), p = Gr((k) => /* @__PURE__ */ C.jsx(t, { ...h(k) })), m = HE(c), y = Gr((k) => /* @__PURE__ */ C.jsx(n, { ...m(k) })), b = /language-(\w+)/.exec(c.className || "")?.[1] ?? "";
  if (typeof l != "string")
    return /* @__PURE__ */ C.jsx(
      sw,
      {
        node: e,
        components: { Pre: p, Code: y },
        code: l
      }
    );
  const x = s[b]?.SyntaxHighlighter ?? i, w = s[b]?.CodeHeader ?? r;
  return /* @__PURE__ */ C.jsx(
    oae,
    {
      node: e,
      components: {
        Pre: p,
        Code: y,
        SyntaxHighlighter: x,
        CodeHeader: w
      },
      language: b || "unknown",
      code: l
    }
  );
}, dae = ({
  node: e,
  components: t,
  componentsByLanguage: n,
  ...i
}) => oj() ? /* @__PURE__ */ C.jsx(
  cae,
  {
    node: e,
    components: t,
    componentsByLanguage: n,
    ...i
  }
) : /* @__PURE__ */ C.jsx(t.Code, { ...i }), fae = $.memo(dae, (e, t) => e.components === t.components && e.componentsByLanguage === t.componentsByLanguage && iw(e, t)), { useSmooth: hae, useSmoothStatus: pae, withSmoothContextProvider: mae } = V$, gae = ({
  components: e,
  componentsByLanguage: t,
  smooth: n = !0,
  preprocess: i,
  ...r
}) => {
  const s = TA(), l = $.useMemo(() => i ? {
    ...s,
    text: i(s.text)
  } : s, [s, i]), { text: c } = hae(l, n), {
    pre: f = iae,
    code: h = aae,
    SyntaxHighlighter: p = sw,
    CodeHeader: m = sae
  } = e ?? {}, y = $.useMemo(() => ({
    Pre: f,
    Code: h,
    SyntaxHighlighter: p,
    CodeHeader: m
  }), [f, h, p, m]), b = Gr((w) => /* @__PURE__ */ C.jsx(
    fae,
    {
      components: y,
      componentsByLanguage: t,
      ...w
    }
  )), x = $.useMemo(() => {
    const { pre: w, code: k, SyntaxHighlighter: T, CodeHeader: A, ...z } = e ?? {};
    return {
      ...z,
      pre: rae,
      code: b
    };
  }, [b, e]);
  return /* @__PURE__ */ C.jsx(Yie, { components: x, ...r, children: c });
}, uj = $.forwardRef(
  ({
    className: e,
    containerProps: t,
    containerComponent: n = "div",
    ...i
  }, r) => {
    const s = pae();
    return /* @__PURE__ */ C.jsx(
      n,
      {
        "data-status": s.type,
        ...t,
        className: lj(e, t?.className),
        ref: r,
        children: /* @__PURE__ */ C.jsx(gae, { ...i })
      }
    );
  }
);
uj.displayName = "MarkdownTextPrimitive";
var vae = mae(
  uj
);
function qE(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let i = 0, r = n.indexOf(t);
  for (; r !== -1; )
    i++, r = n.indexOf(t, r + t.length);
  return i;
}
function yae(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function bae(e, t, n) {
  const r = fh((n || {}).ignore || []), s = xae(t);
  let l = -1;
  for (; ++l < s.length; )
    aj(e, "text", c);
  function c(h, p) {
    let m = -1, y;
    for (; ++m < p.length; ) {
      const b = p[m], x = y ? y.children : void 0;
      if (r(
        b,
        x ? x.indexOf(b) : void 0,
        y
      ))
        return;
      y = b;
    }
    if (y)
      return f(h, p);
  }
  function f(h, p) {
    const m = p[p.length - 1], y = s[l][0], b = s[l][1];
    let x = 0;
    const k = m.children.indexOf(h);
    let T = !1, A = [];
    y.lastIndex = 0;
    let z = y.exec(h.value);
    for (; z; ) {
      const O = z.index, M = {
        index: z.index,
        input: z.input,
        stack: [...p, h]
      };
      let N = b(...z, M);
      if (typeof N == "string" && (N = N.length > 0 ? { type: "text", value: N } : void 0), N === !1 ? y.lastIndex = O + 1 : (x !== O && A.push({
        type: "text",
        value: h.value.slice(x, O)
      }), Array.isArray(N) ? A.push(...N) : N && A.push(N), x = O + z[0].length, T = !0), !y.global)
        break;
      z = y.exec(h.value);
    }
    return T ? (x < h.value.length && A.push({ type: "text", value: h.value.slice(x) }), m.children.splice(k, 1, ...A)) : A = [h], k + A.length;
  }
}
function xae(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let i = -1;
  for (; ++i < n.length; ) {
    const r = n[i];
    t.push([wae(r[0]), _ae(r[1])]);
  }
  return t;
}
function wae(e) {
  return typeof e == "string" ? new RegExp(yae(e), "g") : e;
}
function _ae(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const Tg = "phrasing", Eg = ["autolink", "link", "image", "label"];
function Sae() {
  return {
    transforms: [Iae],
    enter: {
      literalAutolink: Tae,
      literalAutolinkEmail: $g,
      literalAutolinkHttp: $g,
      literalAutolinkWww: $g
    },
    exit: {
      literalAutolink: zae,
      literalAutolinkEmail: Aae,
      literalAutolinkHttp: Eae,
      literalAutolinkWww: $ae
    }
  };
}
function kae() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: Tg,
        notInConstruct: Eg
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: Tg,
        notInConstruct: Eg
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: Tg,
        notInConstruct: Eg
      }
    ]
  };
}
function Tae(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function $g(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function Eae(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function $ae(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function Aae(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function zae(e) {
  this.exit(e);
}
function Iae(e) {
  bae(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, Cae],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), Oae]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function Cae(e, t, n, i, r) {
  let s = "";
  if (!cj(r) || (/^w/i.test(t) && (n = t + n, t = "", s = "http://"), !Rae(n)))
    return !1;
  const l = Nae(n + i);
  if (!l[0]) return !1;
  const c = {
    type: "link",
    title: null,
    url: s + t + l[0],
    children: [{ type: "text", value: t + l[0] }]
  };
  return l[1] ? [c, { type: "text", value: l[1] }] : c;
}
function Oae(e, t, n, i) {
  return (
    // Not an expected previous character.
    !cj(i, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function Rae(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function Nae(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], i = n.indexOf(")");
  const r = qE(e, "(");
  let s = qE(e, ")");
  for (; i !== -1 && r > s; )
    e += n.slice(0, i + 1), n = n.slice(i + 1), i = n.indexOf(")"), s++;
  return [e, n];
}
function cj(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || Ka(n) || uh(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
dj.peek = Vae;
function Mae() {
  this.buffer();
}
function Dae(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function jae() {
  this.buffer();
}
function Pae(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function Uae(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Sr(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function Lae(e) {
  this.exit(e);
}
function Bae(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Sr(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function Zae(e) {
  this.exit(e);
}
function Vae() {
  return "[";
}
function dj(e, t, n, i) {
  const r = n.createTracker(i);
  let s = r.move("[^");
  const l = n.enter("footnoteReference"), c = n.enter("reference");
  return s += r.move(
    n.safe(n.associationId(e), { after: "]", before: s })
  ), c(), l(), s += r.move("]"), s;
}
function Fae() {
  return {
    enter: {
      gfmFootnoteCallString: Mae,
      gfmFootnoteCall: Dae,
      gfmFootnoteDefinitionLabelString: jae,
      gfmFootnoteDefinition: Pae
    },
    exit: {
      gfmFootnoteCallString: Uae,
      gfmFootnoteCall: Lae,
      gfmFootnoteDefinitionLabelString: Bae,
      gfmFootnoteDefinition: Zae
    }
  };
}
function Hae(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: dj },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(i, r, s, l) {
    const c = s.createTracker(l);
    let f = c.move("[^");
    const h = s.enter("footnoteDefinition"), p = s.enter("label");
    return f += c.move(
      s.safe(s.associationId(i), { before: f, after: "]" })
    ), p(), f += c.move("]:"), i.children && i.children.length > 0 && (c.shift(4), f += c.move(
      (t ? `
` : " ") + s.indentLines(
        s.containerFlow(i, c.current()),
        t ? fj : qae
      )
    )), h(), f;
  }
}
function qae(e, t, n) {
  return t === 0 ? e : fj(e, t, n);
}
function fj(e, t, n) {
  return (n ? "" : "    ") + e;
}
const Gae = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
hj.peek = Wae;
function Yae() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Xae },
    exit: { strikethrough: Kae }
  };
}
function Jae() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Gae
      }
    ],
    handlers: { delete: hj }
  };
}
function Xae(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function Kae(e) {
  this.exit(e);
}
function hj(e, t, n, i) {
  const r = n.createTracker(i), s = n.enter("strikethrough");
  let l = r.move("~~");
  return l += n.containerPhrasing(e, {
    ...r.current(),
    before: l,
    after: "~"
  }), l += r.move("~~"), s(), l;
}
function Wae() {
  return "~";
}
function Qae(e) {
  return e.length;
}
function ese(e, t) {
  const n = t || {}, i = (n.align || []).concat(), r = n.stringLength || Qae, s = [], l = [], c = [], f = [];
  let h = 0, p = -1;
  for (; ++p < e.length; ) {
    const w = [], k = [];
    let T = -1;
    for (e[p].length > h && (h = e[p].length); ++T < e[p].length; ) {
      const A = tse(e[p][T]);
      if (n.alignDelimiters !== !1) {
        const z = r(A);
        k[T] = z, (f[T] === void 0 || z > f[T]) && (f[T] = z);
      }
      w.push(A);
    }
    l[p] = w, c[p] = k;
  }
  let m = -1;
  if (typeof i == "object" && "length" in i)
    for (; ++m < h; )
      s[m] = GE(i[m]);
  else {
    const w = GE(i);
    for (; ++m < h; )
      s[m] = w;
  }
  m = -1;
  const y = [], b = [];
  for (; ++m < h; ) {
    const w = s[m];
    let k = "", T = "";
    w === 99 ? (k = ":", T = ":") : w === 108 ? k = ":" : w === 114 && (T = ":");
    let A = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      f[m] - k.length - T.length
    );
    const z = k + "-".repeat(A) + T;
    n.alignDelimiters !== !1 && (A = k.length + A + T.length, A > f[m] && (f[m] = A), b[m] = A), y[m] = z;
  }
  l.splice(1, 0, y), c.splice(1, 0, b), p = -1;
  const x = [];
  for (; ++p < l.length; ) {
    const w = l[p], k = c[p];
    m = -1;
    const T = [];
    for (; ++m < h; ) {
      const A = w[m] || "";
      let z = "", O = "";
      if (n.alignDelimiters !== !1) {
        const M = f[m] - (k[m] || 0), N = s[m];
        N === 114 ? z = " ".repeat(M) : N === 99 ? M % 2 ? (z = " ".repeat(M / 2 + 0.5), O = " ".repeat(M / 2 - 0.5)) : (z = " ".repeat(M / 2), O = z) : O = " ".repeat(M);
      }
      n.delimiterStart !== !1 && !m && T.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && A === "") && (n.delimiterStart !== !1 || m) && T.push(" "), n.alignDelimiters !== !1 && T.push(z), T.push(A), n.alignDelimiters !== !1 && T.push(O), n.padding !== !1 && T.push(" "), (n.delimiterEnd !== !1 || m !== h - 1) && T.push("|");
    }
    x.push(
      n.delimiterEnd === !1 ? T.join("").replace(/ +$/, "") : T.join("")
    );
  }
  return x.join(`
`);
}
function tse(e) {
  return e == null ? "" : String(e);
}
function GE(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function nse(e, t, n, i) {
  const r = n.enter("blockquote"), s = n.createTracker(i);
  s.move("> "), s.shift(2);
  const l = n.indentLines(
    n.containerFlow(e, s.current()),
    rse
  );
  return r(), l;
}
function rse(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function ise(e, t) {
  return YE(e, t.inConstruct, !0) && !YE(e, t.notInConstruct, !1);
}
function YE(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let i = -1;
  for (; ++i < t.length; )
    if (e.includes(t[i]))
      return !0;
  return !1;
}
function JE(e, t, n, i) {
  let r = -1;
  for (; ++r < n.unsafe.length; )
    if (n.unsafe[r].character === `
` && ise(n.stack, n.unsafe[r]))
      return /[ \t]/.test(i.before) ? "" : " ";
  return `\\
`;
}
function ase(e, t) {
  const n = String(e);
  let i = n.indexOf(t), r = i, s = 0, l = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; i !== -1; )
    i === r ? ++s > l && (l = s) : s = 1, r = i + t.length, i = n.indexOf(t, r);
  return l;
}
function sse(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function ose(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function lse(e, t, n, i) {
  const r = ose(n), s = e.value || "", l = r === "`" ? "GraveAccent" : "Tilde";
  if (sse(e, n)) {
    const m = n.enter("codeIndented"), y = n.indentLines(s, use);
    return m(), y;
  }
  const c = n.createTracker(i), f = r.repeat(Math.max(ase(s, r) + 1, 3)), h = n.enter("codeFenced");
  let p = c.move(f);
  if (e.lang) {
    const m = n.enter(`codeFencedLang${l}`);
    p += c.move(
      n.safe(e.lang, {
        before: p,
        after: " ",
        encode: ["`"],
        ...c.current()
      })
    ), m();
  }
  if (e.lang && e.meta) {
    const m = n.enter(`codeFencedMeta${l}`);
    p += c.move(" "), p += c.move(
      n.safe(e.meta, {
        before: p,
        after: `
`,
        encode: ["`"],
        ...c.current()
      })
    ), m();
  }
  return p += c.move(`
`), s && (p += c.move(s + `
`)), p += c.move(f), h(), p;
}
function use(e, t, n) {
  return (n ? "" : "    ") + e;
}
function ow(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function cse(e, t, n, i) {
  const r = ow(n), s = r === '"' ? "Quote" : "Apostrophe", l = n.enter("definition");
  let c = n.enter("label");
  const f = n.createTracker(i);
  let h = f.move("[");
  return h += f.move(
    n.safe(n.associationId(e), {
      before: h,
      after: "]",
      ...f.current()
    })
  ), h += f.move("]: "), c(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), h += f.move("<"), h += f.move(
    n.safe(e.url, { before: h, after: ">", ...f.current() })
  ), h += f.move(">")) : (c = n.enter("destinationRaw"), h += f.move(
    n.safe(e.url, {
      before: h,
      after: e.title ? " " : `
`,
      ...f.current()
    })
  )), c(), e.title && (c = n.enter(`title${s}`), h += f.move(" " + r), h += f.move(
    n.safe(e.title, {
      before: h,
      after: r,
      ...f.current()
    })
  ), h += f.move(r), c()), l(), h;
}
function dse(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function bu(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Tf(e, t, n) {
  const i = bo(e), r = bo(t);
  return i === void 0 ? r === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : r === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : i === 1 ? r === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : r === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : r === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : r === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
pj.peek = fse;
function pj(e, t, n, i) {
  const r = dse(n), s = n.enter("emphasis"), l = n.createTracker(i), c = l.move(r);
  let f = l.move(
    n.containerPhrasing(e, {
      after: r,
      before: c,
      ...l.current()
    })
  );
  const h = f.charCodeAt(0), p = Tf(
    i.before.charCodeAt(i.before.length - 1),
    h,
    r
  );
  p.inside && (f = bu(h) + f.slice(1));
  const m = f.charCodeAt(f.length - 1), y = Tf(i.after.charCodeAt(0), m, r);
  y.inside && (f = f.slice(0, -1) + bu(m));
  const b = l.move(r);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: y.outside,
    before: p.outside
  }, c + f + b;
}
function fse(e, t, n) {
  return n.options.emphasis || "*";
}
function hse(e, t) {
  let n = !1;
  return nw(e, function(i) {
    if ("value" in i && /\r?\n|\r/.test(i.value) || i.type === "break")
      return n = !0, Mv;
  }), !!((!e.depth || e.depth < 3) && Jx(e) && (t.options.setext || n));
}
function pse(e, t, n, i) {
  const r = Math.max(Math.min(6, e.depth || 1), 1), s = n.createTracker(i);
  if (hse(e, n)) {
    const p = n.enter("headingSetext"), m = n.enter("phrasing"), y = n.containerPhrasing(e, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return m(), p(), y + `
` + (r === 1 ? "=" : "-").repeat(
      // The whole size
      y.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(y.lastIndexOf("\r"), y.lastIndexOf(`
`)) + 1)
    );
  }
  const l = "#".repeat(r), c = n.enter("headingAtx"), f = n.enter("phrasing");
  s.move(l + " ");
  let h = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(h) && (h = bu(h.charCodeAt(0)) + h.slice(1)), h = h ? l + " " + h : l, n.options.closeAtx && (h += " " + l), f(), c(), h;
}
mj.peek = mse;
function mj(e) {
  return e.value || "";
}
function mse() {
  return "<";
}
gj.peek = gse;
function gj(e, t, n, i) {
  const r = ow(n), s = r === '"' ? "Quote" : "Apostrophe", l = n.enter("image");
  let c = n.enter("label");
  const f = n.createTracker(i);
  let h = f.move("![");
  return h += f.move(
    n.safe(e.alt, { before: h, after: "]", ...f.current() })
  ), h += f.move("]("), c(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), h += f.move("<"), h += f.move(
    n.safe(e.url, { before: h, after: ">", ...f.current() })
  ), h += f.move(">")) : (c = n.enter("destinationRaw"), h += f.move(
    n.safe(e.url, {
      before: h,
      after: e.title ? " " : ")",
      ...f.current()
    })
  )), c(), e.title && (c = n.enter(`title${s}`), h += f.move(" " + r), h += f.move(
    n.safe(e.title, {
      before: h,
      after: r,
      ...f.current()
    })
  ), h += f.move(r), c()), h += f.move(")"), l(), h;
}
function gse() {
  return "!";
}
vj.peek = vse;
function vj(e, t, n, i) {
  const r = e.referenceType, s = n.enter("imageReference");
  let l = n.enter("label");
  const c = n.createTracker(i);
  let f = c.move("![");
  const h = n.safe(e.alt, {
    before: f,
    after: "]",
    ...c.current()
  });
  f += c.move(h + "]["), l();
  const p = n.stack;
  n.stack = [], l = n.enter("reference");
  const m = n.safe(n.associationId(e), {
    before: f,
    after: "]",
    ...c.current()
  });
  return l(), n.stack = p, s(), r === "full" || !h || h !== m ? f += c.move(m + "]") : r === "shortcut" ? f = f.slice(0, -1) : f += c.move("]"), f;
}
function vse() {
  return "!";
}
yj.peek = yse;
function yj(e, t, n) {
  let i = e.value || "", r = "`", s = -1;
  for (; new RegExp("(^|[^`])" + r + "([^`]|$)").test(i); )
    r += "`";
  for (/[^ \r\n]/.test(i) && (/^[ \r\n]/.test(i) && /[ \r\n]$/.test(i) || /^`|`$/.test(i)) && (i = " " + i + " "); ++s < n.unsafe.length; ) {
    const l = n.unsafe[s], c = n.compilePattern(l);
    let f;
    if (l.atBreak)
      for (; f = c.exec(i); ) {
        let h = f.index;
        i.charCodeAt(h) === 10 && i.charCodeAt(h - 1) === 13 && h--, i = i.slice(0, h) + " " + i.slice(f.index + 1);
      }
  }
  return r + i + r;
}
function yse() {
  return "`";
}
function bj(e, t) {
  const n = Jx(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
xj.peek = bse;
function xj(e, t, n, i) {
  const r = ow(n), s = r === '"' ? "Quote" : "Apostrophe", l = n.createTracker(i);
  let c, f;
  if (bj(e, n)) {
    const p = n.stack;
    n.stack = [], c = n.enter("autolink");
    let m = l.move("<");
    return m += l.move(
      n.containerPhrasing(e, {
        before: m,
        after: ">",
        ...l.current()
      })
    ), m += l.move(">"), c(), n.stack = p, m;
  }
  c = n.enter("link"), f = n.enter("label");
  let h = l.move("[");
  return h += l.move(
    n.containerPhrasing(e, {
      before: h,
      after: "](",
      ...l.current()
    })
  ), h += l.move("]("), f(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (f = n.enter("destinationLiteral"), h += l.move("<"), h += l.move(
    n.safe(e.url, { before: h, after: ">", ...l.current() })
  ), h += l.move(">")) : (f = n.enter("destinationRaw"), h += l.move(
    n.safe(e.url, {
      before: h,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), f(), e.title && (f = n.enter(`title${s}`), h += l.move(" " + r), h += l.move(
    n.safe(e.title, {
      before: h,
      after: r,
      ...l.current()
    })
  ), h += l.move(r), f()), h += l.move(")"), c(), h;
}
function bse(e, t, n) {
  return bj(e, n) ? "<" : "[";
}
wj.peek = xse;
function wj(e, t, n, i) {
  const r = e.referenceType, s = n.enter("linkReference");
  let l = n.enter("label");
  const c = n.createTracker(i);
  let f = c.move("[");
  const h = n.containerPhrasing(e, {
    before: f,
    after: "]",
    ...c.current()
  });
  f += c.move(h + "]["), l();
  const p = n.stack;
  n.stack = [], l = n.enter("reference");
  const m = n.safe(n.associationId(e), {
    before: f,
    after: "]",
    ...c.current()
  });
  return l(), n.stack = p, s(), r === "full" || !h || h !== m ? f += c.move(m + "]") : r === "shortcut" ? f = f.slice(0, -1) : f += c.move("]"), f;
}
function xse() {
  return "[";
}
function lw(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function wse(e) {
  const t = lw(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function _se(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function _j(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function Sse(e, t, n, i) {
  const r = n.enter("list"), s = n.bulletCurrent;
  let l = e.ordered ? _se(n) : lw(n);
  const c = e.ordered ? l === "." ? ")" : "." : wse(n);
  let f = t && n.bulletLastUsed ? l === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const p = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (l === "*" || l === "-") && // Empty first list item:
      p && (!p.children || !p.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (f = !0), _j(n) === l && p
    ) {
      let m = -1;
      for (; ++m < e.children.length; ) {
        const y = e.children[m];
        if (y && y.type === "listItem" && y.children && y.children[0] && y.children[0].type === "thematicBreak") {
          f = !0;
          break;
        }
      }
    }
  }
  f && (l = c), n.bulletCurrent = l;
  const h = n.containerFlow(e, i);
  return n.bulletLastUsed = l, n.bulletCurrent = s, r(), h;
}
function kse(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function Tse(e, t, n, i) {
  const r = kse(n);
  let s = n.bulletCurrent || lw(n);
  t && t.type === "list" && t.ordered && (s = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + s);
  let l = s.length + 1;
  (r === "tab" || r === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (l = Math.ceil(l / 4) * 4);
  const c = n.createTracker(i);
  c.move(s + " ".repeat(l - s.length)), c.shift(l);
  const f = n.enter("listItem"), h = n.indentLines(
    n.containerFlow(e, c.current()),
    p
  );
  return f(), h;
  function p(m, y, b) {
    return y ? (b ? "" : " ".repeat(l)) + m : (b ? s : s + " ".repeat(l - s.length)) + m;
  }
}
function Ese(e, t, n, i) {
  const r = n.enter("paragraph"), s = n.enter("phrasing"), l = n.containerPhrasing(e, i);
  return s(), r(), l;
}
const $se = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  fh([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function Ase(e, t, n, i) {
  return (e.children.some(function(l) {
    return $se(l);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, i);
}
function zse(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
Sj.peek = Ise;
function Sj(e, t, n, i) {
  const r = zse(n), s = n.enter("strong"), l = n.createTracker(i), c = l.move(r + r);
  let f = l.move(
    n.containerPhrasing(e, {
      after: r,
      before: c,
      ...l.current()
    })
  );
  const h = f.charCodeAt(0), p = Tf(
    i.before.charCodeAt(i.before.length - 1),
    h,
    r
  );
  p.inside && (f = bu(h) + f.slice(1));
  const m = f.charCodeAt(f.length - 1), y = Tf(i.after.charCodeAt(0), m, r);
  y.inside && (f = f.slice(0, -1) + bu(m));
  const b = l.move(r + r);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: y.outside,
    before: p.outside
  }, c + f + b;
}
function Ise(e, t, n) {
  return n.options.strong || "*";
}
function Cse(e, t, n, i) {
  return n.safe(e.value, i);
}
function Ose(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function Rse(e, t, n) {
  const i = (_j(n) + (n.options.ruleSpaces ? " " : "")).repeat(Ose(n));
  return n.options.ruleSpaces ? i.slice(0, -1) : i;
}
const kj = {
  blockquote: nse,
  break: JE,
  code: lse,
  definition: cse,
  emphasis: pj,
  hardBreak: JE,
  heading: pse,
  html: mj,
  image: gj,
  imageReference: vj,
  inlineCode: yj,
  link: xj,
  linkReference: wj,
  list: Sse,
  listItem: Tse,
  paragraph: Ese,
  root: Ase,
  strong: Sj,
  text: Cse,
  thematicBreak: Rse
};
function Nse() {
  return {
    enter: {
      table: Mse,
      tableData: XE,
      tableHeader: XE,
      tableRow: jse
    },
    exit: {
      codeText: Pse,
      table: Dse,
      tableData: Ag,
      tableHeader: Ag,
      tableRow: Ag
    }
  };
}
function Mse(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function Dse(e) {
  this.exit(e), this.data.inTable = void 0;
}
function jse(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function Ag(e) {
  this.exit(e);
}
function XE(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function Pse(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, Use));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function Use(e, t) {
  return t === "|" ? t : e;
}
function Lse(e) {
  const t = e || {}, n = t.tableCellPadding, i = t.tablePipeAlign, r = t.stringLength, s = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: y,
      table: l,
      tableCell: f,
      tableRow: c
    }
  };
  function l(b, x, w, k) {
    return h(p(b, w, k), b.align);
  }
  function c(b, x, w, k) {
    const T = m(b, w, k), A = h([T]);
    return A.slice(0, A.indexOf(`
`));
  }
  function f(b, x, w, k) {
    const T = w.enter("tableCell"), A = w.enter("phrasing"), z = w.containerPhrasing(b, {
      ...k,
      before: s,
      after: s
    });
    return A(), T(), z;
  }
  function h(b, x) {
    return ese(b, {
      align: x,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: i,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: r
    });
  }
  function p(b, x, w) {
    const k = b.children;
    let T = -1;
    const A = [], z = x.enter("table");
    for (; ++T < k.length; )
      A[T] = m(k[T], x, w);
    return z(), A;
  }
  function m(b, x, w) {
    const k = b.children;
    let T = -1;
    const A = [], z = x.enter("tableRow");
    for (; ++T < k.length; )
      A[T] = f(k[T], b, x, w);
    return z(), A;
  }
  function y(b, x, w) {
    let k = kj.inlineCode(b, x, w);
    return w.stack.includes("tableCell") && (k = k.replace(/\|/g, "\\$&")), k;
  }
}
function Bse() {
  return {
    exit: {
      taskListCheckValueChecked: KE,
      taskListCheckValueUnchecked: KE,
      paragraph: Vse
    }
  };
}
function Zse() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: Fse }
  };
}
function KE(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function Vse(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const i = n.children[0];
    if (i && i.type === "text") {
      const r = t.children;
      let s = -1, l;
      for (; ++s < r.length; ) {
        const c = r[s];
        if (c.type === "paragraph") {
          l = c;
          break;
        }
      }
      l === n && (i.value = i.value.slice(1), i.value.length === 0 ? n.children.shift() : n.position && i.position && typeof i.position.start.offset == "number" && (i.position.start.column++, i.position.start.offset++, n.position.start = Object.assign({}, i.position.start)));
    }
  }
  this.exit(e);
}
function Fse(e, t, n, i) {
  const r = e.children[0], s = typeof e.checked == "boolean" && r && r.type === "paragraph", l = "[" + (e.checked ? "x" : " ") + "] ", c = n.createTracker(i);
  s && c.move(l);
  let f = kj.listItem(e, t, n, {
    ...i,
    ...c.current()
  });
  return s && (f = f.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, h)), f;
  function h(p) {
    return p + l;
  }
}
function Hse() {
  return [
    Sae(),
    Fae(),
    Yae(),
    Nse(),
    Bse()
  ];
}
function qse(e) {
  return {
    extensions: [
      kae(),
      Hae(e),
      Jae(),
      Lse(e),
      Zse()
    ]
  };
}
const Gse = {
  tokenize: Qse,
  partial: !0
}, Tj = {
  tokenize: eoe,
  partial: !0
}, Ej = {
  tokenize: toe,
  partial: !0
}, $j = {
  tokenize: noe,
  partial: !0
}, Yse = {
  tokenize: roe,
  partial: !0
}, Aj = {
  name: "wwwAutolink",
  tokenize: Kse,
  previous: Ij
}, zj = {
  name: "protocolAutolink",
  tokenize: Wse,
  previous: Cj
}, ki = {
  name: "emailAutolink",
  tokenize: Xse,
  previous: Oj
}, Xr = {};
function Jse() {
  return {
    text: Xr
  };
}
let Ma = 48;
for (; Ma < 123; )
  Xr[Ma] = ki, Ma++, Ma === 58 ? Ma = 65 : Ma === 91 && (Ma = 97);
Xr[43] = ki;
Xr[45] = ki;
Xr[46] = ki;
Xr[95] = ki;
Xr[72] = [ki, zj];
Xr[104] = [ki, zj];
Xr[87] = [ki, Aj];
Xr[119] = [ki, Aj];
function Xse(e, t, n) {
  const i = this;
  let r, s;
  return l;
  function l(m) {
    return !Uv(m) || !Oj.call(i, i.previous) || uw(i.events) ? n(m) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), c(m));
  }
  function c(m) {
    return Uv(m) ? (e.consume(m), c) : m === 64 ? (e.consume(m), f) : n(m);
  }
  function f(m) {
    return m === 46 ? e.check(Yse, p, h)(m) : m === 45 || m === 95 || on(m) ? (s = !0, e.consume(m), f) : p(m);
  }
  function h(m) {
    return e.consume(m), r = !0, f;
  }
  function p(m) {
    return s && r && pn(i.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(m)) : n(m);
  }
}
function Kse(e, t, n) {
  const i = this;
  return r;
  function r(l) {
    return l !== 87 && l !== 119 || !Ij.call(i, i.previous) || uw(i.events) ? n(l) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(Gse, e.attempt(Tj, e.attempt(Ej, s), n), n)(l));
  }
  function s(l) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(l);
  }
}
function Wse(e, t, n) {
  const i = this;
  let r = "", s = !1;
  return l;
  function l(m) {
    return (m === 72 || m === 104) && Cj.call(i, i.previous) && !uw(i.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), r += String.fromCodePoint(m), e.consume(m), c) : n(m);
  }
  function c(m) {
    if (pn(m) && r.length < 5)
      return r += String.fromCodePoint(m), e.consume(m), c;
    if (m === 58) {
      const y = r.toLowerCase();
      if (y === "http" || y === "https")
        return e.consume(m), f;
    }
    return n(m);
  }
  function f(m) {
    return m === 47 ? (e.consume(m), s ? h : (s = !0, f)) : n(m);
  }
  function h(m) {
    return m === null || _f(m) || ot(m) || Ka(m) || uh(m) ? n(m) : e.attempt(Tj, e.attempt(Ej, p), n)(m);
  }
  function p(m) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(m);
  }
}
function Qse(e, t, n) {
  let i = 0;
  return r;
  function r(l) {
    return (l === 87 || l === 119) && i < 3 ? (i++, e.consume(l), r) : l === 46 && i === 3 ? (e.consume(l), s) : n(l);
  }
  function s(l) {
    return l === null ? n(l) : t(l);
  }
}
function eoe(e, t, n) {
  let i, r, s;
  return l;
  function l(h) {
    return h === 46 || h === 95 ? e.check($j, f, c)(h) : h === null || ot(h) || Ka(h) || h !== 45 && uh(h) ? f(h) : (s = !0, e.consume(h), l);
  }
  function c(h) {
    return h === 95 ? i = !0 : (r = i, i = void 0), e.consume(h), l;
  }
  function f(h) {
    return r || i || !s ? n(h) : t(h);
  }
}
function toe(e, t) {
  let n = 0, i = 0;
  return r;
  function r(l) {
    return l === 40 ? (n++, e.consume(l), r) : l === 41 && i < n ? s(l) : l === 33 || l === 34 || l === 38 || l === 39 || l === 41 || l === 42 || l === 44 || l === 46 || l === 58 || l === 59 || l === 60 || l === 63 || l === 93 || l === 95 || l === 126 ? e.check($j, t, s)(l) : l === null || ot(l) || Ka(l) ? t(l) : (e.consume(l), r);
  }
  function s(l) {
    return l === 41 && i++, e.consume(l), r;
  }
}
function noe(e, t, n) {
  return i;
  function i(c) {
    return c === 33 || c === 34 || c === 39 || c === 41 || c === 42 || c === 44 || c === 46 || c === 58 || c === 59 || c === 63 || c === 95 || c === 126 ? (e.consume(c), i) : c === 38 ? (e.consume(c), s) : c === 93 ? (e.consume(c), r) : (
      // `<` is an end.
      c === 60 || // So is whitespace.
      c === null || ot(c) || Ka(c) ? t(c) : n(c)
    );
  }
  function r(c) {
    return c === null || c === 40 || c === 91 || ot(c) || Ka(c) ? t(c) : i(c);
  }
  function s(c) {
    return pn(c) ? l(c) : n(c);
  }
  function l(c) {
    return c === 59 ? (e.consume(c), i) : pn(c) ? (e.consume(c), l) : n(c);
  }
}
function roe(e, t, n) {
  return i;
  function i(s) {
    return e.consume(s), r;
  }
  function r(s) {
    return on(s) ? n(s) : t(s);
  }
}
function Ij(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || ot(e);
}
function Cj(e) {
  return !pn(e);
}
function Oj(e) {
  return !(e === 47 || Uv(e));
}
function Uv(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || on(e);
}
function uw(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const i = e[t][1];
    if ((i.type === "labelLink" || i.type === "labelImage") && !i._balanced) {
      n = !0;
      break;
    }
    if (i._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const ioe = {
  tokenize: foe,
  partial: !0
};
function aoe() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: uoe,
        continuation: {
          tokenize: coe
        },
        exit: doe
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: loe
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: soe,
        resolveTo: ooe
      }
    }
  };
}
function soe(e, t, n) {
  const i = this;
  let r = i.events.length;
  const s = i.parser.gfmFootnotes || (i.parser.gfmFootnotes = []);
  let l;
  for (; r--; ) {
    const f = i.events[r][1];
    if (f.type === "labelImage") {
      l = f;
      break;
    }
    if (f.type === "gfmFootnoteCall" || f.type === "labelLink" || f.type === "label" || f.type === "image" || f.type === "link")
      break;
  }
  return c;
  function c(f) {
    if (!l || !l._balanced)
      return n(f);
    const h = Sr(i.sliceSerialize({
      start: l.end,
      end: i.now()
    }));
    return h.codePointAt(0) !== 94 || !s.includes(h.slice(1)) ? n(f) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), t(f));
  }
}
function ooe(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const i = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, r = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  r.end.column++, r.end.offset++, r.end._bufferIndex++;
  const s = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, r.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, l = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, s.start),
    end: Object.assign({}, s.end)
  }, c = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", i, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", r, t],
    ["exit", r, t],
    // Everything in between.
    ["enter", s, t],
    ["enter", l, t],
    ["exit", l, t],
    ["exit", s, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", i, t]
  ];
  return e.splice(n, e.length - n + 1, ...c), e;
}
function loe(e, t, n) {
  const i = this, r = i.parser.gfmFootnotes || (i.parser.gfmFootnotes = []);
  let s = 0, l;
  return c;
  function c(m) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(m), e.exit("gfmFootnoteCallLabelMarker"), f;
  }
  function f(m) {
    return m !== 94 ? n(m) : (e.enter("gfmFootnoteCallMarker"), e.consume(m), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", h);
  }
  function h(m) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      m === 93 && !l || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      m === null || m === 91 || ot(m)
    )
      return n(m);
    if (m === 93) {
      e.exit("chunkString");
      const y = e.exit("gfmFootnoteCallString");
      return r.includes(Sr(i.sliceSerialize(y))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(m), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(m);
    }
    return ot(m) || (l = !0), s++, e.consume(m), m === 92 ? p : h;
  }
  function p(m) {
    return m === 91 || m === 92 || m === 93 ? (e.consume(m), s++, h) : h(m);
  }
}
function uoe(e, t, n) {
  const i = this, r = i.parser.gfmFootnotes || (i.parser.gfmFootnotes = []);
  let s, l = 0, c;
  return f;
  function f(x) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(x), e.exit("gfmFootnoteDefinitionLabelMarker"), h;
  }
  function h(x) {
    return x === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(x), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", p) : n(x);
  }
  function p(x) {
    if (
      // Too long.
      l > 999 || // Closing brace with nothing.
      x === 93 && !c || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      x === null || x === 91 || ot(x)
    )
      return n(x);
    if (x === 93) {
      e.exit("chunkString");
      const w = e.exit("gfmFootnoteDefinitionLabelString");
      return s = Sr(i.sliceSerialize(w)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(x), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), y;
    }
    return ot(x) || (c = !0), l++, e.consume(x), x === 92 ? m : p;
  }
  function m(x) {
    return x === 91 || x === 92 || x === 93 ? (e.consume(x), l++, p) : p(x);
  }
  function y(x) {
    return x === 58 ? (e.enter("definitionMarker"), e.consume(x), e.exit("definitionMarker"), r.includes(s) || r.push(s), Ge(e, b, "gfmFootnoteDefinitionWhitespace")) : n(x);
  }
  function b(x) {
    return t(x);
  }
}
function coe(e, t, n) {
  return e.check(Gu, t, e.attempt(ioe, t, n));
}
function doe(e) {
  e.exit("gfmFootnoteDefinition");
}
function foe(e, t, n) {
  const i = this;
  return Ge(e, r, "gfmFootnoteDefinitionIndent", 5);
  function r(s) {
    const l = i.events[i.events.length - 1];
    return l && l[1].type === "gfmFootnoteDefinitionIndent" && l[2].sliceSerialize(l[1], !0).length === 4 ? t(s) : n(s);
  }
}
function hoe(e) {
  let n = (e || {}).singleTilde;
  const i = {
    name: "strikethrough",
    tokenize: s,
    resolveAll: r
  };
  return n == null && (n = !0), {
    text: {
      126: i
    },
    insideSpan: {
      null: [i]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function r(l, c) {
    let f = -1;
    for (; ++f < l.length; )
      if (l[f][0] === "enter" && l[f][1].type === "strikethroughSequenceTemporary" && l[f][1]._close) {
        let h = f;
        for (; h--; )
          if (l[h][0] === "exit" && l[h][1].type === "strikethroughSequenceTemporary" && l[h][1]._open && // If the sizes are the same:
          l[f][1].end.offset - l[f][1].start.offset === l[h][1].end.offset - l[h][1].start.offset) {
            l[f][1].type = "strikethroughSequence", l[h][1].type = "strikethroughSequence";
            const p = {
              type: "strikethrough",
              start: Object.assign({}, l[h][1].start),
              end: Object.assign({}, l[f][1].end)
            }, m = {
              type: "strikethroughText",
              start: Object.assign({}, l[h][1].end),
              end: Object.assign({}, l[f][1].start)
            }, y = [["enter", p, c], ["enter", l[h][1], c], ["exit", l[h][1], c], ["enter", m, c]], b = c.parser.constructs.insideSpan.null;
            b && Hn(y, y.length, 0, ch(b, l.slice(h + 1, f), c)), Hn(y, y.length, 0, [["exit", m, c], ["enter", l[f][1], c], ["exit", l[f][1], c], ["exit", p, c]]), Hn(l, h - 1, f - h + 3, y), f = h + y.length - 2;
            break;
          }
      }
    for (f = -1; ++f < l.length; )
      l[f][1].type === "strikethroughSequenceTemporary" && (l[f][1].type = "data");
    return l;
  }
  function s(l, c, f) {
    const h = this.previous, p = this.events;
    let m = 0;
    return y;
    function y(x) {
      return h === 126 && p[p.length - 1][1].type !== "characterEscape" ? f(x) : (l.enter("strikethroughSequenceTemporary"), b(x));
    }
    function b(x) {
      const w = bo(h);
      if (x === 126)
        return m > 1 ? f(x) : (l.consume(x), m++, b);
      if (m < 2 && !n) return f(x);
      const k = l.exit("strikethroughSequenceTemporary"), T = bo(x);
      return k._open = !T || T === 2 && !!w, k._close = !w || w === 2 && !!T, c(x);
    }
  }
}
class poe {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, i) {
    moe(this, t, n, i);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(s, l) {
      return s[0] - l[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const i = [];
    for (; n > 0; )
      n -= 1, i.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    i.push(t.slice()), t.length = 0;
    let r = i.pop();
    for (; r; ) {
      for (const s of r)
        t.push(s);
      r = i.pop();
    }
    this.map.length = 0;
  }
}
function moe(e, t, n, i) {
  let r = 0;
  if (!(n === 0 && i.length === 0)) {
    for (; r < e.map.length; ) {
      if (e.map[r][0] === t) {
        e.map[r][1] += n, e.map[r][2].push(...i);
        return;
      }
      r += 1;
    }
    e.map.push([t, n, i]);
  }
}
function goe(e, t) {
  let n = !1;
  const i = [];
  for (; t < e.length; ) {
    const r = e[t];
    if (n) {
      if (r[0] === "enter")
        r[1].type === "tableContent" && i.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (r[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const s = i.length - 1;
          i[s] = i[s] === "left" ? "center" : "right";
        }
      } else if (r[1].type === "tableDelimiterRow")
        break;
    } else r[0] === "enter" && r[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return i;
}
function voe() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: yoe,
        resolveAll: boe
      }
    }
  };
}
function yoe(e, t, n) {
  const i = this;
  let r = 0, s = 0, l;
  return c;
  function c(D) {
    let ae = i.events.length - 1;
    for (; ae > -1; ) {
      const se = i.events[ae][1].type;
      if (se === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      se === "linePrefix") ae--;
      else break;
    }
    const ie = ae > -1 ? i.events[ae][1].type : null, le = ie === "tableHead" || ie === "tableRow" ? N : f;
    return le === N && i.parser.lazy[i.now().line] ? n(D) : le(D);
  }
  function f(D) {
    return e.enter("tableHead"), e.enter("tableRow"), h(D);
  }
  function h(D) {
    return D === 124 || (l = !0, s += 1), p(D);
  }
  function p(D) {
    return D === null ? n(D) : Se(D) ? s > 1 ? (s = 0, i.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(D), e.exit("lineEnding"), b) : n(D) : Fe(D) ? Ge(e, p, "whitespace")(D) : (s += 1, l && (l = !1, r += 1), D === 124 ? (e.enter("tableCellDivider"), e.consume(D), e.exit("tableCellDivider"), l = !0, p) : (e.enter("data"), m(D)));
  }
  function m(D) {
    return D === null || D === 124 || ot(D) ? (e.exit("data"), p(D)) : (e.consume(D), D === 92 ? y : m);
  }
  function y(D) {
    return D === 92 || D === 124 ? (e.consume(D), m) : m(D);
  }
  function b(D) {
    return i.interrupt = !1, i.parser.lazy[i.now().line] ? n(D) : (e.enter("tableDelimiterRow"), l = !1, Fe(D) ? Ge(e, x, "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(D) : x(D));
  }
  function x(D) {
    return D === 45 || D === 58 ? k(D) : D === 124 ? (l = !0, e.enter("tableCellDivider"), e.consume(D), e.exit("tableCellDivider"), w) : M(D);
  }
  function w(D) {
    return Fe(D) ? Ge(e, k, "whitespace")(D) : k(D);
  }
  function k(D) {
    return D === 58 ? (s += 1, l = !0, e.enter("tableDelimiterMarker"), e.consume(D), e.exit("tableDelimiterMarker"), T) : D === 45 ? (s += 1, T(D)) : D === null || Se(D) ? O(D) : M(D);
  }
  function T(D) {
    return D === 45 ? (e.enter("tableDelimiterFiller"), A(D)) : M(D);
  }
  function A(D) {
    return D === 45 ? (e.consume(D), A) : D === 58 ? (l = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(D), e.exit("tableDelimiterMarker"), z) : (e.exit("tableDelimiterFiller"), z(D));
  }
  function z(D) {
    return Fe(D) ? Ge(e, O, "whitespace")(D) : O(D);
  }
  function O(D) {
    return D === 124 ? x(D) : D === null || Se(D) ? !l || r !== s ? M(D) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(D)) : M(D);
  }
  function M(D) {
    return n(D);
  }
  function N(D) {
    return e.enter("tableRow"), U(D);
  }
  function U(D) {
    return D === 124 ? (e.enter("tableCellDivider"), e.consume(D), e.exit("tableCellDivider"), U) : D === null || Se(D) ? (e.exit("tableRow"), t(D)) : Fe(D) ? Ge(e, U, "whitespace")(D) : (e.enter("data"), Z(D));
  }
  function Z(D) {
    return D === null || D === 124 || ot(D) ? (e.exit("data"), U(D)) : (e.consume(D), D === 92 ? re : Z);
  }
  function re(D) {
    return D === 92 || D === 124 ? (e.consume(D), Z) : Z(D);
  }
}
function boe(e, t) {
  let n = -1, i = !0, r = 0, s = [0, 0, 0, 0], l = [0, 0, 0, 0], c = !1, f = 0, h, p, m;
  const y = new poe();
  for (; ++n < e.length; ) {
    const b = e[n], x = b[1];
    b[0] === "enter" ? x.type === "tableHead" ? (c = !1, f !== 0 && (WE(y, t, f, h, p), p = void 0, f = 0), h = {
      type: "table",
      start: Object.assign({}, x.start),
      // Note: correct end is set later.
      end: Object.assign({}, x.end)
    }, y.add(n, 0, [["enter", h, t]])) : x.type === "tableRow" || x.type === "tableDelimiterRow" ? (i = !0, m = void 0, s = [0, 0, 0, 0], l = [0, n + 1, 0, 0], c && (c = !1, p = {
      type: "tableBody",
      start: Object.assign({}, x.start),
      // Note: correct end is set later.
      end: Object.assign({}, x.end)
    }, y.add(n, 0, [["enter", p, t]])), r = x.type === "tableDelimiterRow" ? 2 : p ? 3 : 1) : r && (x.type === "data" || x.type === "tableDelimiterMarker" || x.type === "tableDelimiterFiller") ? (i = !1, l[2] === 0 && (s[1] !== 0 && (l[0] = l[1], m = Rd(y, t, s, r, void 0, m), s = [0, 0, 0, 0]), l[2] = n)) : x.type === "tableCellDivider" && (i ? i = !1 : (s[1] !== 0 && (l[0] = l[1], m = Rd(y, t, s, r, void 0, m)), s = l, l = [s[1], n, 0, 0])) : x.type === "tableHead" ? (c = !0, f = n) : x.type === "tableRow" || x.type === "tableDelimiterRow" ? (f = n, s[1] !== 0 ? (l[0] = l[1], m = Rd(y, t, s, r, n, m)) : l[1] !== 0 && (m = Rd(y, t, l, r, n, m)), r = 0) : r && (x.type === "data" || x.type === "tableDelimiterMarker" || x.type === "tableDelimiterFiller") && (l[3] = n);
  }
  for (f !== 0 && WE(y, t, f, h, p), y.consume(t.events), n = -1; ++n < t.events.length; ) {
    const b = t.events[n];
    b[0] === "enter" && b[1].type === "table" && (b[1]._align = goe(t.events, n));
  }
  return e;
}
function Rd(e, t, n, i, r, s) {
  const l = i === 1 ? "tableHeader" : i === 2 ? "tableDelimiter" : "tableData", c = "tableContent";
  n[0] !== 0 && (s.end = Object.assign({}, Js(t.events, n[0])), e.add(n[0], 0, [["exit", s, t]]));
  const f = Js(t.events, n[1]);
  if (s = {
    type: l,
    start: Object.assign({}, f),
    // Note: correct end is set later.
    end: Object.assign({}, f)
  }, e.add(n[1], 0, [["enter", s, t]]), n[2] !== 0) {
    const h = Js(t.events, n[2]), p = Js(t.events, n[3]), m = {
      type: c,
      start: Object.assign({}, h),
      end: Object.assign({}, p)
    };
    if (e.add(n[2], 0, [["enter", m, t]]), i !== 2) {
      const y = t.events[n[2]], b = t.events[n[3]];
      if (y[1].end = Object.assign({}, b[1].end), y[1].type = "chunkText", y[1].contentType = "text", n[3] > n[2] + 1) {
        const x = n[2] + 1, w = n[3] - n[2] - 1;
        e.add(x, w, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", m, t]]);
  }
  return r !== void 0 && (s.end = Object.assign({}, Js(t.events, r)), e.add(r, 0, [["exit", s, t]]), s = void 0), s;
}
function WE(e, t, n, i, r) {
  const s = [], l = Js(t.events, n);
  r && (r.end = Object.assign({}, l), s.push(["exit", r, t])), i.end = Object.assign({}, l), s.push(["exit", i, t]), e.add(n + 1, 0, s);
}
function Js(e, t) {
  const n = e[t], i = n[0] === "enter" ? "start" : "end";
  return n[1][i];
}
const xoe = {
  name: "tasklistCheck",
  tokenize: _oe
};
function woe() {
  return {
    text: {
      91: xoe
    }
  };
}
function _oe(e, t, n) {
  const i = this;
  return r;
  function r(f) {
    return (
      // Exit if theres stuff before.
      i.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !i._gfmTasklistFirstContentOfListItem ? n(f) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(f), e.exit("taskListCheckMarker"), s)
    );
  }
  function s(f) {
    return ot(f) ? (e.enter("taskListCheckValueUnchecked"), e.consume(f), e.exit("taskListCheckValueUnchecked"), l) : f === 88 || f === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(f), e.exit("taskListCheckValueChecked"), l) : n(f);
  }
  function l(f) {
    return f === 93 ? (e.enter("taskListCheckMarker"), e.consume(f), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), c) : n(f);
  }
  function c(f) {
    return Se(f) ? t(f) : Fe(f) ? e.check({
      tokenize: Soe
    }, t, n)(f) : n(f);
  }
}
function Soe(e, t, n) {
  return Ge(e, i, "whitespace");
  function i(r) {
    return r === null ? n(r) : t(r);
  }
}
function koe(e) {
  return LD([
    Jse(),
    aoe(),
    hoe(e),
    voe(),
    woe()
  ]);
}
const Toe = {};
function Eoe(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || Toe, i = t.data(), r = i.micromarkExtensions || (i.micromarkExtensions = []), s = i.fromMarkdownExtensions || (i.fromMarkdownExtensions = []), l = i.toMarkdownExtensions || (i.toMarkdownExtensions = []);
  r.push(koe(n)), s.push(Hse()), l.push(qse(n));
}
const $oe = () => /* @__PURE__ */ C.jsx(
  vae,
  {
    remarkPlugins: [Eoe],
    className: "assistant:aui-md",
    components: Ioe
  }
), Rj = $.memo($oe), Aoe = ({ language: e, code: t }) => {
  const { isCopied: n, copyToClipboard: i } = zoe(), r = () => {
    !t || n || i(t);
  };
  return /* @__PURE__ */ C.jsxs("div", { className: "assistant:mt-4 assistant:flex assistant:items-center assistant:justify-between assistant:gap-4 assistant:rounded-t-lg assistant:bg-zinc-900 assistant:px-4 assistant:py-2 assistant:text-sm assistant:font-semibold assistant:text-white", children: [
    /* @__PURE__ */ C.jsx("span", { className: "assistant:lowercase assistant:[&>span]:text-xs", children: e }),
    /* @__PURE__ */ C.jsxs(bi, { tooltip: "Copy", onClick: r, children: [
      !n && /* @__PURE__ */ C.jsx(EN, {}),
      n && /* @__PURE__ */ C.jsx(ox, {})
    ] })
  ] });
}, zoe = ({
  copiedDuration: e = 3e3
} = {}) => {
  const [t, n] = $.useState(!1);
  return { isCopied: t, copyToClipboard: (r) => {
    r && navigator.clipboard.writeText(r).then(() => {
      n(!0), setTimeout(() => n(!1), e);
    });
  } };
}, Ioe = tae({
  h1: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("h1", { className: wt("assistant:mb-8 assistant:scroll-m-20 assistant:text-4xl assistant:font-extrabold assistant:tracking-tight assistant:last:mb-0", e), ...t }),
  h2: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("h2", { className: wt("assistant:mb-4 assistant:mt-8 assistant:scroll-m-20 assistant:text-3xl assistant:font-semibold assistant:tracking-tight assistant:first:mt-0 assistant:last:mb-0", e), ...t }),
  h3: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("h3", { className: wt("assistant:mb-4 assistant:mt-6 assistant:scroll-m-20 assistant:text-2xl assistant:font-semibold assistant:tracking-tight assistant:first:mt-0 assistant:last:mb-0", e), ...t }),
  h4: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("h4", { className: wt("assistant:mb-4 assistant:mt-6 assistant:scroll-m-20 assistant:text-xl assistant:font-semibold assistant:tracking-tight assistant:first:mt-0 assistant:last:mb-0", e), ...t }),
  h5: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("h5", { className: wt("assistant:my-4 assistant:text-lg assistant:font-semibold assistant:first:mt-0 assistant:last:mb-0", e), ...t }),
  h6: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("h6", { className: wt("assistant:my-4 assistant:font-semibold assistant:first:mt-0 assistant:last:mb-0", e), ...t }),
  p: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("p", { className: wt("assistant:mb-5 assistant:mt-5 assistant:leading-7 assistant:first:mt-0 assistant:last:mb-0", e), ...t }),
  a: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("a", { className: wt("assistant:text-primary assistant:font-medium assistant:underline assistant:underline-offset-4", e), ...t }),
  blockquote: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("blockquote", { className: wt("assistant:border-l-2 assistant:pl-6 assistant:italic", e), ...t }),
  ul: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("ul", { className: wt("assistant:my-5 assistant:ml-6 assistant:list-disc assistant:[&>li]:mt-2", e), ...t }),
  ol: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("ol", { className: wt("assistant:my-5 assistant:ml-6 assistant:list-decimal assistant:[&>li]:mt-2", e), ...t }),
  hr: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("hr", { className: wt("assistant:my-5 assistant:border-b", e), ...t }),
  table: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("table", { className: wt("assistant:my-5 assistant:w-full assistant:border-separate assistant:border-spacing-0 assistant:overflow-y-auto", e), ...t }),
  th: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("th", { className: wt("assistant:bg-muted assistant:px-4 assistant:py-2 assistant:text-left assistant:font-bold assistant:first:rounded-tl-lg assistant:last:rounded-tr-lg assistant:[&[align=center]]:text-center assistant:[&[align=right]]:text-right", e), ...t }),
  td: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("td", { className: wt("assistant:border-b assistant:border-l assistant:px-4 assistant:py-2 assistant:text-left assistant:last:border-r assistant:[&[align=center]]:text-center assistant:[&[align=right]]:text-right", e), ...t }),
  tr: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("tr", { className: wt("assistant:m-0 assistant:border-b assistant:p-0 assistant:first:border-t assistant:[&:last-child>td:first-child]:rounded-bl-lg assistant:[&:last-child>td:last-child]:rounded-br-lg", e), ...t }),
  sup: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("sup", { className: wt("assistant:[&>a]:text-xs assistant:[&>a]:no-underline", e), ...t }),
  pre: ({ className: e, ...t }) => /* @__PURE__ */ C.jsx("pre", { className: wt("assistant:overflow-x-auto assistant:!rounded-t-none assistant:rounded-b-lg assistant:bg-black assistant:p-4 assistant:text-white", e), ...t }),
  code: function({ className: t, ...n }) {
    const i = oj();
    return /* @__PURE__ */ C.jsx(
      "code",
      {
        className: wt(!i && "assistant:bg-muted assistant:rounded assistant:border assistant:font-semibold", t),
        ...n
      }
    );
  },
  CodeHeader: Aoe
}), Coe = ({
  toolName: e,
  argsText: t,
  result: n
}) => {
  const [i, r] = $.useState(!0);
  return /* @__PURE__ */ C.jsxs("div", { className: "assistant:mb-4 assistant:flex assistant:w-full assistant:flex-col assistant:gap-3 assistant:rounded-lg assistant:border assistant:py-3", children: [
    /* @__PURE__ */ C.jsxs("div", { className: "assistant:flex assistant:items-center assistant:gap-2 assistant:px-4", children: [
      /* @__PURE__ */ C.jsx(ox, { className: "assistant:size-4" }),
      /* @__PURE__ */ C.jsxs("p", { className: "assistant:flex-grow", children: [
        "Used tool: ",
        /* @__PURE__ */ C.jsx("b", { children: e })
      ] }),
      /* @__PURE__ */ C.jsx(Xa, { onClick: () => r(!i), children: i ? /* @__PURE__ */ C.jsx(LY, {}) : /* @__PURE__ */ C.jsx(NY, {}) })
    ] }),
    !i && /* @__PURE__ */ C.jsxs("div", { className: "assistant:flex assistant:flex-col assistant:gap-2 assistant:border-t assistant:pt-2", children: [
      /* @__PURE__ */ C.jsx("div", { className: "assistant:px-4", children: /* @__PURE__ */ C.jsx("pre", { className: "assistant:whitespace-pre-wrap", children: t }) }),
      n !== void 0 && /* @__PURE__ */ C.jsxs("div", { className: "assistant:border-t assistant:border-dashed assistant:px-4 assistant:pt-2", children: [
        /* @__PURE__ */ C.jsx("p", { className: "assistant:font-semibold", children: "Result:" }),
        /* @__PURE__ */ C.jsx("pre", { className: "assistant:whitespace-pre-wrap", children: typeof n == "string" ? n : JSON.stringify(n, null, 2) })
      ] })
    ] })
  ] });
}, Ooe = () => /* @__PURE__ */ C.jsxs(
  jA,
  {
    className: "assistant:bg-background assistant:flex assistant:h-full assistant:flex-col",
    style: {
      "--thread-max-width": "48rem",
      "--thread-padding-x": "1rem"
    },
    children: [
      /* @__PURE__ */ C.jsxs(UA, { className: "assistant:relative assistant:flex assistant:min-w-0 assistant:flex-1 assistant:flex-col assistant:gap-6 assistant:overflow-y-scroll", children: [
        /* @__PURE__ */ C.jsx(Noe, {}),
        /* @__PURE__ */ C.jsx(
          OZ,
          {
            components: {
              UserMessage: Boe,
              EditComposer: Voe,
              AssistantMessage: Uoe
            }
          }
        ),
        /* @__PURE__ */ C.jsx(Wd, { empty: !1, children: /* @__PURE__ */ C.jsx(yo.div, { className: "assistant:min-h-6 assistant:min-w-6 assistant:shrink-0" }) })
      ] }),
      /* @__PURE__ */ C.jsx(Doe, {})
    ]
  }
), Roe = () => /* @__PURE__ */ C.jsx(NZ, { asChild: !0, children: /* @__PURE__ */ C.jsx(
  bi,
  {
    tooltip: "Scroll to bottom",
    variant: "outline",
    className: "assistant:dark:bg-background assistant:dark:hover:bg-accent assistant:absolute assistant:-top-12 assistant:z-10 assistant:self-center assistant:rounded-full assistant:p-4 assistant:disabled:invisible",
    children: /* @__PURE__ */ C.jsx(zY, {})
  }
) }), Noe = () => /* @__PURE__ */ C.jsx(dy, { children: /* @__PURE__ */ C.jsx("div", { className: "assistant:mx-auto assistant:flex assistant:w-full assistant:max-w-[var(--thread-max-width)] assistant:flex-grow assistant:flex-col assistant:px-[var(--thread-padding-x)]", children: /* @__PURE__ */ C.jsx("div", { className: "assistant:flex assistant:w-full assistant:flex-grow assistant:flex-col assistant:items-center assistant:justify-center", children: /* @__PURE__ */ C.jsxs("div", { className: "assistant:flex assistant:size-full assistant:flex-col assistant:justify-center assistant:px-8 assistant:md:mt-20", children: [
  /* @__PURE__ */ C.jsx(
    yo.div,
    {
      initial: { opacity: 0, y: 10 },
      animate: { opacity: 1, y: 0 },
      exit: { opacity: 0, y: 10 },
      transition: { delay: 0.5 },
      className: "assistant:text-2xl assistant:font-semibold",
      children: "Hello there!"
    }
  ),
  /* @__PURE__ */ C.jsx(
    yo.div,
    {
      initial: { opacity: 0, y: 10 },
      animate: { opacity: 1, y: 0 },
      exit: { opacity: 0, y: 10 },
      transition: { delay: 0.6 },
      className: "assistant:text-muted-foreground/65 assistant:text-2xl",
      children: "How can I help you today?"
    }
  )
] }) }) }) }), Moe = () => /* @__PURE__ */ C.jsx("div", { className: "assistant:grid assistant:w-full assistant:gap-2 assistant:sm:grid-cols-2", children: [
  {
    title: "What are the advantages",
    label: "of using Assistant Cloud?",
    action: "What are the advantages of using Assistant Cloud?"
  },
  {
    title: "Write code to",
    label: "demonstrate topological sorting",
    action: "Write code to demonstrate topological sorting"
  },
  {
    title: "Help me write an essay",
    label: "about AI chat applications",
    action: "Help me write an essay about AI chat applications"
  },
  {
    title: "What is the weather",
    label: "in San Francisco?",
    action: "What is the weather in San Francisco?"
  }
].map((e, t) => /* @__PURE__ */ C.jsx(
  yo.div,
  {
    initial: { opacity: 0, y: 20 },
    animate: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: 20 },
    transition: { delay: 0.05 * t },
    className: "assistant:[&:nth-child(n+3)]:hidden assistant:sm:[&:nth-child(n+3)]:block",
    children: /* @__PURE__ */ C.jsx(
      DZ,
      {
        prompt: e.action,
        method: "replace",
        autoSend: !0,
        asChild: !0,
        children: /* @__PURE__ */ C.jsxs(
          Xa,
          {
            variant: "ghost",
            className: "assistant:dark:hover:bg-accent/60 assistant:h-auto assistant:w-full assistant:flex-1 assistant:flex-wrap assistant:items-start assistant:justify-start assistant:gap-1 assistant:rounded-xl assistant:border assistant:px-4 assistant:py-3.5 assistant:text-left assistant:text-sm assistant:sm:flex-col",
            "aria-label": e.action,
            children: [
              /* @__PURE__ */ C.jsx("span", { className: "assistant:font-medium", children: e.title }),
              /* @__PURE__ */ C.jsx("p", { className: "assistant:text-muted-foreground", children: e.label })
            ]
          }
        )
      }
    )
  },
  `suggested-action-${e.title}-${t}`
)) }), Doe = () => /* @__PURE__ */ C.jsxs("div", { className: "assistant:bg-background assistant:relative assistant:mx-auto assistant:flex assistant:w-full assistant:max-w-[var(--thread-max-width)] assistant:flex-col assistant:gap-4 assistant:px-[var(--thread-padding-x)] assistant:pb-4 assistant:md:pb-6", children: [
  /* @__PURE__ */ C.jsx(Roe, {}),
  /* @__PURE__ */ C.jsx(dy, { children: /* @__PURE__ */ C.jsx(Moe, {}) }),
  /* @__PURE__ */ C.jsxs(ly, { className: "assistant:relative assistant:flex assistant:w-full assistant:flex-col assistant:rounded-2xl assistant:focus-within:ring-2 assistant:focus-within:ring-black assistant:focus-within:ring-offset-2 assistant:dark:focus-within:ring-white", children: [
    /* @__PURE__ */ C.jsx(
      cy,
      {
        placeholder: "Send a message...",
        className: "assistant:bg-muted assistant:border-border assistant:dark:border-muted-foreground/15 assistant:focus:outline-primary assistant:placeholder:text-muted-foreground assistant:max-h-[calc(50dvh)] assistant:min-h-16 assistant:w-full assistant:resize-none assistant:rounded-t-2xl assistant:border-x assistant:border-t assistant:px-4 assistant:pb-3 assistant:pt-2 assistant:text-base assistant:outline-none",
        rows: 1,
        autoFocus: !0,
        "aria-label": "Message input"
      }
    ),
    /* @__PURE__ */ C.jsx(joe, {})
  ] })
] }), joe = () => /* @__PURE__ */ C.jsxs("div", { className: "assistant:bg-muted assistant:border-border assistant:dark:border-muted-foreground/15 assistant:relative assistant:flex assistant:items-center assistant:justify-between assistant:rounded-b-2xl assistant:border-x assistant:border-b assistant:p-2", children: [
  /* @__PURE__ */ C.jsx(
    bi,
    {
      tooltip: "Attach file",
      variant: "ghost",
      className: "assistant:hover:bg-foreground/15 assistant:dark:hover:bg-background/50 assistant:scale-115 assistant:p-3.5",
      onClick: () => {
        console.log("Attachment clicked - not implemented");
      },
      children: /* @__PURE__ */ C.jsx(HY, {})
    }
  ),
  /* @__PURE__ */ C.jsx(Wd, { running: !1, children: /* @__PURE__ */ C.jsx(OA, { asChild: !0, children: /* @__PURE__ */ C.jsx(
    Xa,
    {
      type: "submit",
      variant: "default",
      className: "assistant:dark:border-muted-foreground/90 assistant:border-muted-foreground/60 assistant:hover:bg-primary/75 assistant:size-8 assistant:rounded-full assistant:border",
      "aria-label": "Send message",
      children: /* @__PURE__ */ C.jsx(CY, { className: "assistant:size-5" })
    }
  ) }) }),
  /* @__PURE__ */ C.jsx(Wd, { running: !0, children: /* @__PURE__ */ C.jsx(NA, { asChild: !0, children: /* @__PURE__ */ C.jsx(
    Xa,
    {
      type: "button",
      variant: "default",
      className: "assistant:dark:border-muted-foreground/90 assistant:border-muted-foreground/60 assistant:hover:bg-primary/75 assistant:size-8 assistant:rounded-full assistant:border",
      "aria-label": "Stop generating",
      children: /* @__PURE__ */ C.jsx(JY, { className: "assistant:size-3.5 assistant:fill-white assistant:dark:size-4 assistant:dark:fill-black" })
    }
  ) }) })
] }), Poe = () => /* @__PURE__ */ C.jsx(zA, { children: /* @__PURE__ */ C.jsx(MA, { className: "assistant:border-destructive assistant:bg-destructive/10 assistant:dark:bg-destructive/5 assistant:text-destructive assistant:mt-2 assistant:rounded-md assistant:border assistant:p-3 assistant:text-sm assistant:dark:text-red-200", children: /* @__PURE__ */ C.jsx(DA, { className: "assistant:line-clamp-2" }) }) }), Uoe = () => /* @__PURE__ */ C.jsx(sy, { asChild: !0, children: /* @__PURE__ */ C.jsxs(
  yo.div,
  {
    className: "assistant:relative assistant:mx-auto assistant:grid assistant:w-full assistant:max-w-[var(--thread-max-width)] assistant:grid-cols-[auto_auto_1fr] assistant:grid-rows-[auto_1fr] assistant:px-[var(--thread-padding-x)] assistant:py-4",
    initial: { y: 5, opacity: 0 },
    animate: { y: 0, opacity: 1 },
    "data-role": "assistant",
    children: [
      /* @__PURE__ */ C.jsx("div", { className: "assistant:ring-border assistant:bg-background assistant:col-start-1 assistant:row-start-1 assistant:flex assistant:size-8 assistant:shrink-0 assistant:items-center assistant:justify-center assistant:rounded-full assistant:ring-1", children: /* @__PURE__ */ C.jsx(Foe, { size: 14 }) }),
      /* @__PURE__ */ C.jsxs("div", { className: "assistant:text-foreground assistant:col-span-2 assistant:col-start-2 assistant:row-start-1 assistant:ml-4 assistant:break-words assistant:leading-7", children: [
        /* @__PURE__ */ C.jsx(
          oy,
          {
            components: {
              Text: Rj,
              tools: { Fallback: Coe }
            }
          }
        ),
        /* @__PURE__ */ C.jsx(Poe, {})
      ] }),
      /* @__PURE__ */ C.jsx(Loe, {}),
      /* @__PURE__ */ C.jsx(Nj, { className: "assistant:col-start-2 assistant:row-start-2 assistant:-ml-2 assistant:mr-2" })
    ]
  }
) }), Loe = () => /* @__PURE__ */ C.jsxs(
  Jv,
  {
    hideWhenRunning: !0,
    autohide: "not-last",
    autohideFloat: "single-branch",
    className: "assistant:text-muted-foreground assistant:data-floating:bg-background assistant:data-floating:absolute assistant:data-floating:mt-2 assistant:data-floating:rounded-md assistant:data-floating:border assistant:data-floating:p-1 assistant:data-floating:shadow-sm assistant:col-start-3 assistant:row-start-2 assistant:ml-3 assistant:mt-3 assistant:flex assistant:gap-1",
    children: [
      /* @__PURE__ */ C.jsx(Y$, { asChild: !0, children: /* @__PURE__ */ C.jsxs(bi, { tooltip: "Copy", children: [
        /* @__PURE__ */ C.jsx(Kd, { copied: !0, children: /* @__PURE__ */ C.jsx(ox, {}) }),
        /* @__PURE__ */ C.jsx(Kd, { copied: !1, children: /* @__PURE__ */ C.jsx(EN, {}) })
      ] }) }),
      /* @__PURE__ */ C.jsx(HL, { asChild: !0, children: /* @__PURE__ */ C.jsx(bi, { tooltip: "Refresh", children: /* @__PURE__ */ C.jsx(GY, {}) }) })
    ]
  }
), Boe = () => /* @__PURE__ */ C.jsx(sy, { asChild: !0, children: /* @__PURE__ */ C.jsxs(
  yo.div,
  {
    className: "assistant:mx-auto assistant:grid assistant:w-full assistant:max-w-[var(--thread-max-width)] assistant:auto-rows-auto assistant:grid-cols-[minmax(72px,1fr)_auto] assistant:gap-y-1 assistant:px-[var(--thread-padding-x)] assistant:py-4 assistant:[&:where(>*)]:col-start-2",
    initial: { y: 5, opacity: 0 },
    animate: { y: 0, opacity: 1 },
    "data-role": "user",
    children: [
      /* @__PURE__ */ C.jsx(Zoe, {}),
      /* @__PURE__ */ C.jsx("div", { className: "assistant:bg-muted assistant:text-foreground assistant:col-start-2 assistant:break-words assistant:rounded-3xl assistant:px-5 assistant:py-2.5", children: /* @__PURE__ */ C.jsx(oy, { components: { Text: Rj } }) }),
      /* @__PURE__ */ C.jsx(Nj, { className: "assistant:col-span-full assistant:col-start-1 assistant:row-start-3 assistant:-mr-1 assistant:justify-end" })
    ]
  }
) }), Zoe = () => /* @__PURE__ */ C.jsx(
  Jv,
  {
    hideWhenRunning: !0,
    autohide: "not-last",
    className: "assistant:col-start-1 assistant:mr-3 assistant:mt-2.5 assistant:flex assistant:flex-col assistant:items-end",
    children: /* @__PURE__ */ C.jsx(GL, { asChild: !0, children: /* @__PURE__ */ C.jsx(bi, { tooltip: "Edit", children: /* @__PURE__ */ C.jsx(VY, {}) }) })
  }
), Voe = () => /* @__PURE__ */ C.jsx("div", { className: "assistant:mx-auto assistant:flex assistant:w-full assistant:max-w-[var(--thread-max-width)] assistant:flex-col assistant:gap-4 assistant:px-[var(--thread-padding-x)]", children: /* @__PURE__ */ C.jsxs(ly, { className: "assistant:bg-muted assistant:max-w-7/8 assistant:ml-auto assistant:flex assistant:w-full assistant:flex-col assistant:rounded-xl", children: [
  /* @__PURE__ */ C.jsx(
    cy,
    {
      className: "assistant:text-foreground assistant:flex assistant:min-h-[60px] assistant:w-full assistant:resize-none assistant:bg-transparent assistant:p-4 assistant:outline-none",
      autoFocus: !0
    }
  ),
  /* @__PURE__ */ C.jsxs("div", { className: "assistant:mx-3 assistant:mb-3 assistant:flex assistant:items-center assistant:justify-center assistant:gap-2 assistant:self-end", children: [
    /* @__PURE__ */ C.jsx(NA, { asChild: !0, children: /* @__PURE__ */ C.jsx(Xa, { variant: "ghost", size: "sm", "aria-label": "Cancel edit", children: "Cancel" }) }),
    /* @__PURE__ */ C.jsx(OA, { asChild: !0, children: /* @__PURE__ */ C.jsx(Xa, { size: "sm", "aria-label": "Update message", children: "Update" }) })
  ] })
] }) }), Nj = ({
  className: e,
  ...t
}) => /* @__PURE__ */ C.jsxs(
  IA,
  {
    hideWhenSingleBranch: !0,
    className: wt("assistant:text-muted-foreground assistant:inline-flex assistant:items-center assistant:text-xs", e),
    ...t,
    children: [
      /* @__PURE__ */ C.jsx(U3, { asChild: !0, children: /* @__PURE__ */ C.jsx(bi, { tooltip: "Previous", children: /* @__PURE__ */ C.jsx(DY, {}) }) }),
      /* @__PURE__ */ C.jsxs("span", { className: "assistant:font-medium", children: [
        /* @__PURE__ */ C.jsx(kA, {}),
        " / ",
        /* @__PURE__ */ C.jsx(SA, {})
      ] }),
      /* @__PURE__ */ C.jsx(j3, { asChild: !0, children: /* @__PURE__ */ C.jsx(bi, { tooltip: "Next", children: /* @__PURE__ */ C.jsx(PY, {}) }) })
    ]
  }
), Foe = ({ size: e = 14 }) => /* @__PURE__ */ C.jsx(
  "svg",
  {
    width: e,
    height: e,
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ C.jsx(
      "path",
      {
        d: "M8 0L9.79611 6.20389L16 8L9.79611 9.79611L8 16L6.20389 9.79611L0 8L6.20389 6.20389L8 0Z",
        fill: "currentColor"
      }
    )
  }
), Hoe = () => {
  const e = _Y();
  return /* @__PURE__ */ C.jsx(KU, { runtime: e, children: /* @__PURE__ */ C.jsx(Ooe, {}) });
}, qoe = '/*! tailwindcss v4.1.12 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-tracking:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-animation-delay:0s;--tw-animation-direction:normal;--tw-animation-duration:initial;--tw-animation-fill-mode:none;--tw-animation-iteration-count:1;--tw-enter-blur:0;--tw-enter-opacity:1;--tw-enter-rotate:0;--tw-enter-scale:1;--tw-enter-translate-x:0;--tw-enter-translate-y:0;--tw-exit-blur:0;--tw-exit-opacity:1;--tw-exit-rotate:0;--tw-exit-scale:1;--tw-exit-translate-x:0;--tw-exit-translate-y:0}}}@layer theme{:root,:host{--assistant-font-sans:var(--font-geist-sans);--assistant-font-mono:var(--font-geist-mono);--assistant-color-red-200:oklch(88.5% .062 18.334);--assistant-color-zinc-900:oklch(21% .006 285.885);--assistant-color-black:#000;--assistant-color-white:#fff;--assistant-spacing:.25rem;--assistant-text-xs:.75rem;--assistant-text-xs--line-height:calc(1/.75);--assistant-text-sm:.875rem;--assistant-text-sm--line-height:calc(1.25/.875);--assistant-text-base:1rem;--assistant-text-base--line-height: 1.5 ;--assistant-text-lg:1.125rem;--assistant-text-lg--line-height:calc(1.75/1.125);--assistant-text-xl:1.25rem;--assistant-text-xl--line-height:calc(1.75/1.25);--assistant-text-2xl:1.5rem;--assistant-text-2xl--line-height:calc(2/1.5);--assistant-text-3xl:1.875rem;--assistant-text-3xl--line-height: 1.2 ;--assistant-text-4xl:2.25rem;--assistant-text-4xl--line-height:calc(2.5/2.25);--assistant-font-weight-medium:500;--assistant-font-weight-semibold:600;--assistant-font-weight-bold:700;--assistant-font-weight-extrabold:800;--assistant-tracking-tight:-.025em;--assistant-radius-md:calc(var(--radius) - 2px);--assistant-radius-lg:var(--radius);--assistant-radius-xl:calc(var(--radius) + 4px);--assistant-radius-2xl:1rem;--assistant-radius-3xl:1.5rem;--assistant-default-transition-duration:.15s;--assistant-default-transition-timing-function:cubic-bezier(.4,0,.2,1);--assistant-default-font-family:var(--font-geist-sans);--assistant-default-mono-font-family:var(--font-geist-mono);--assistant-color-background:var(--background);--assistant-color-foreground:var(--foreground);--assistant-color-ring:var(--ring);--assistant-color-input:var(--input);--assistant-color-border:var(--border);--assistant-color-destructive:var(--destructive);--assistant-color-accent-foreground:var(--accent-foreground);--assistant-color-accent:var(--accent);--assistant-color-muted-foreground:var(--muted-foreground);--assistant-color-muted:var(--muted);--assistant-color-secondary-foreground:var(--secondary-foreground);--assistant-color-secondary:var(--secondary);--assistant-color-primary-foreground:var(--primary-foreground);--assistant-color-primary:var(--primary)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--assistant-default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--assistant-default-font-feature-settings,normal);font-variation-settings:var(--assistant-default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--assistant-default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--assistant-default-mono-font-feature-settings,normal);font-variation-settings:var(--assistant-default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}*{border-color:var(--border);outline-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){*{outline-color:color-mix(in oklab,var(--ring)50%,transparent)}}body{background-color:var(--background);color:var(--foreground)}}@layer components;@layer utilities{.assistant\\:sr-only{clip:rect(0,0,0,0);white-space:nowrap;border-width:0;width:1px;height:1px;margin:-1px;padding:0;position:absolute;overflow:hidden}.assistant\\:absolute{position:absolute}.assistant\\:relative{position:relative}.assistant\\:-top-12{top:calc(var(--assistant-spacing)*-12)}.assistant\\:z-10{z-index:10}.assistant\\:z-50{z-index:50}.assistant\\:col-span-2{grid-column:span 2/span 2}.assistant\\:col-span-full{grid-column:1/-1}.assistant\\:col-start-1{grid-column-start:1}.assistant\\:col-start-2{grid-column-start:2}.assistant\\:col-start-3{grid-column-start:3}.assistant\\:row-start-1{grid-row-start:1}.assistant\\:row-start-2{grid-row-start:2}.assistant\\:row-start-3{grid-row-start:3}.assistant\\:m-0{margin:calc(var(--assistant-spacing)*0)}.assistant\\:mx-3{margin-inline:calc(var(--assistant-spacing)*3)}.assistant\\:mx-auto{margin-inline:auto}.assistant\\:my-4{margin-block:calc(var(--assistant-spacing)*4)}.assistant\\:my-5{margin-block:calc(var(--assistant-spacing)*5)}.assistant\\:mt-2{margin-top:calc(var(--assistant-spacing)*2)}.assistant\\:mt-2\\.5{margin-top:calc(var(--assistant-spacing)*2.5)}.assistant\\:mt-3{margin-top:calc(var(--assistant-spacing)*3)}.assistant\\:mt-4{margin-top:calc(var(--assistant-spacing)*4)}.assistant\\:mt-5{margin-top:calc(var(--assistant-spacing)*5)}.assistant\\:mt-6{margin-top:calc(var(--assistant-spacing)*6)}.assistant\\:mt-8{margin-top:calc(var(--assistant-spacing)*8)}.assistant\\:-mr-1{margin-right:calc(var(--assistant-spacing)*-1)}.assistant\\:mr-1{margin-right:calc(var(--assistant-spacing)*1)}.assistant\\:mr-2{margin-right:calc(var(--assistant-spacing)*2)}.assistant\\:mr-3{margin-right:calc(var(--assistant-spacing)*3)}.assistant\\:mb-3{margin-bottom:calc(var(--assistant-spacing)*3)}.assistant\\:mb-4{margin-bottom:calc(var(--assistant-spacing)*4)}.assistant\\:mb-5{margin-bottom:calc(var(--assistant-spacing)*5)}.assistant\\:mb-8{margin-bottom:calc(var(--assistant-spacing)*8)}.assistant\\:-ml-2{margin-left:calc(var(--assistant-spacing)*-2)}.assistant\\:ml-3{margin-left:calc(var(--assistant-spacing)*3)}.assistant\\:ml-4{margin-left:calc(var(--assistant-spacing)*4)}.assistant\\:ml-6{margin-left:calc(var(--assistant-spacing)*6)}.assistant\\:ml-auto{margin-left:auto}.assistant\\:line-clamp-2{-webkit-line-clamp:2;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}.assistant\\:flex{display:flex}.assistant\\:grid{display:grid}.assistant\\:inline-flex{display:inline-flex}.assistant\\:size-2\\.5{width:calc(var(--assistant-spacing)*2.5);height:calc(var(--assistant-spacing)*2.5)}.assistant\\:size-3\\.5{width:calc(var(--assistant-spacing)*3.5);height:calc(var(--assistant-spacing)*3.5)}.assistant\\:size-4{width:calc(var(--assistant-spacing)*4);height:calc(var(--assistant-spacing)*4)}.assistant\\:size-5{width:calc(var(--assistant-spacing)*5);height:calc(var(--assistant-spacing)*5)}.assistant\\:size-6{width:calc(var(--assistant-spacing)*6);height:calc(var(--assistant-spacing)*6)}.assistant\\:size-8{width:calc(var(--assistant-spacing)*8);height:calc(var(--assistant-spacing)*8)}.assistant\\:size-9{width:calc(var(--assistant-spacing)*9);height:calc(var(--assistant-spacing)*9)}.assistant\\:size-full{width:100%;height:100%}.assistant\\:h-8{height:calc(var(--assistant-spacing)*8)}.assistant\\:h-9{height:calc(var(--assistant-spacing)*9)}.assistant\\:h-10{height:calc(var(--assistant-spacing)*10)}.assistant\\:h-auto{height:auto}.assistant\\:h-full{height:100%}.assistant\\:max-h-\\[calc\\(50dvh\\)\\]{max-height:50dvh}.assistant\\:min-h-6{min-height:calc(var(--assistant-spacing)*6)}.assistant\\:min-h-16{min-height:calc(var(--assistant-spacing)*16)}.assistant\\:min-h-\\[60px\\]{min-height:60px}.assistant\\:w-fit{width:fit-content}.assistant\\:w-full{width:100%}.assistant\\:max-w-7\\/8{max-width:87.5%}.assistant\\:max-w-\\[var\\(--thread-max-width\\)\\]{max-width:var(--thread-max-width)}.assistant\\:min-w-0{min-width:calc(var(--assistant-spacing)*0)}.assistant\\:min-w-6{min-width:calc(var(--assistant-spacing)*6)}.assistant\\:flex-1{flex:1}.assistant\\:shrink-0{flex-shrink:0}.assistant\\:flex-grow{flex-grow:1}.assistant\\:border-separate{border-collapse:separate}.assistant\\:border-spacing-0{--tw-border-spacing-x:calc(var(--assistant-spacing)*0);--tw-border-spacing-y:calc(var(--assistant-spacing)*0);border-spacing:var(--tw-border-spacing-x)var(--tw-border-spacing-y)}.assistant\\:origin-\\(--radix-tooltip-content-transform-origin\\){transform-origin:var(--radix-tooltip-content-transform-origin)}.assistant\\:translate-y-\\[calc\\(-50\\%_-_2px\\)\\]{--tw-translate-y: calc(-50% - 2px) ;translate:var(--tw-translate-x)var(--tw-translate-y)}.assistant\\:scale-115{--tw-scale-x:115%;--tw-scale-y:115%;--tw-scale-z:115%;scale:var(--tw-scale-x)var(--tw-scale-y)}.assistant\\:rotate-45{rotate:45deg}.assistant\\:animate-in{animation:enter var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.assistant\\:resize-none{resize:none}.assistant\\:scroll-m-20{scroll-margin:calc(var(--assistant-spacing)*20)}.assistant\\:list-decimal{list-style-type:decimal}.assistant\\:list-disc{list-style-type:disc}.assistant\\:auto-rows-auto{grid-auto-rows:auto}.assistant\\:grid-cols-\\[auto_auto_1fr\\]{grid-template-columns:auto auto 1fr}.assistant\\:grid-cols-\\[minmax\\(72px\\,1fr\\)_auto\\]{grid-template-columns:minmax(72px,1fr) auto}.assistant\\:grid-rows-\\[auto_1fr\\]{grid-template-rows:auto 1fr}.assistant\\:flex-col{flex-direction:column}.assistant\\:flex-wrap{flex-wrap:wrap}.assistant\\:items-center{align-items:center}.assistant\\:items-end{align-items:flex-end}.assistant\\:items-start{align-items:flex-start}.assistant\\:items-stretch{align-items:stretch}.assistant\\:justify-between{justify-content:space-between}.assistant\\:justify-center{justify-content:center}.assistant\\:justify-end{justify-content:flex-end}.assistant\\:justify-start{justify-content:flex-start}.assistant\\:gap-1{gap:calc(var(--assistant-spacing)*1)}.assistant\\:gap-1\\.5{gap:calc(var(--assistant-spacing)*1.5)}.assistant\\:gap-2{gap:calc(var(--assistant-spacing)*2)}.assistant\\:gap-3{gap:calc(var(--assistant-spacing)*3)}.assistant\\:gap-4{gap:calc(var(--assistant-spacing)*4)}.assistant\\:gap-6{gap:calc(var(--assistant-spacing)*6)}.assistant\\:gap-y-1{row-gap:calc(var(--assistant-spacing)*1)}.assistant\\:self-center{align-self:center}.assistant\\:self-end{align-self:flex-end}.assistant\\:overflow-x-auto{overflow-x:auto}.assistant\\:overflow-y-auto{overflow-y:auto}.assistant\\:overflow-y-scroll{overflow-y:scroll}.assistant\\:rounded{border-radius:.25rem}.assistant\\:rounded-2xl{border-radius:var(--assistant-radius-2xl)}.assistant\\:rounded-3xl{border-radius:var(--assistant-radius-3xl)}.assistant\\:rounded-\\[2px\\]{border-radius:2px}.assistant\\:rounded-full{border-radius:3.40282e38px}.assistant\\:rounded-lg{border-radius:var(--radius)}.assistant\\:rounded-md{border-radius:calc(var(--radius) - 2px)}.assistant\\:rounded-xl{border-radius:calc(var(--radius) + 4px)}.assistant\\:\\!rounded-t-none{border-top-left-radius:0!important;border-top-right-radius:0!important}.assistant\\:rounded-t-2xl{border-top-left-radius:var(--assistant-radius-2xl);border-top-right-radius:var(--assistant-radius-2xl)}.assistant\\:rounded-t-lg{border-top-left-radius:var(--radius);border-top-right-radius:var(--radius)}.assistant\\:rounded-b-2xl{border-bottom-right-radius:var(--assistant-radius-2xl);border-bottom-left-radius:var(--assistant-radius-2xl)}.assistant\\:rounded-b-lg{border-bottom-right-radius:var(--radius);border-bottom-left-radius:var(--radius)}.assistant\\:border{border-style:var(--tw-border-style);border-width:1px}.assistant\\:border-x{border-inline-style:var(--tw-border-style);border-inline-width:1px}.assistant\\:border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.assistant\\:border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.assistant\\:border-l{border-left-style:var(--tw-border-style);border-left-width:1px}.assistant\\:border-l-2{border-left-style:var(--tw-border-style);border-left-width:2px}.assistant\\:border-dashed{--tw-border-style:dashed;border-style:dashed}.assistant\\:border-border{border-color:var(--border)}.assistant\\:border-destructive{border-color:var(--destructive)}.assistant\\:border-muted-foreground\\/60{border-color:var(--muted-foreground)}@supports (color:color-mix(in lab,red,red)){.assistant\\:border-muted-foreground\\/60{border-color:color-mix(in oklab,var(--muted-foreground)60%,transparent)}}.assistant\\:bg-background{background-color:var(--background)}.assistant\\:bg-black{background-color:var(--assistant-color-black)}.assistant\\:bg-destructive,.assistant\\:bg-destructive\\/10{background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.assistant\\:bg-destructive\\/10{background-color:color-mix(in oklab,var(--destructive)10%,transparent)}}.assistant\\:bg-muted{background-color:var(--muted)}.assistant\\:bg-primary{background-color:var(--primary)}.assistant\\:bg-secondary{background-color:var(--secondary)}.assistant\\:bg-transparent{background-color:#0000}.assistant\\:bg-zinc-900{background-color:var(--assistant-color-zinc-900)}.assistant\\:fill-primary{fill:var(--primary)}.assistant\\:fill-white{fill:var(--assistant-color-white)}.assistant\\:p-0{padding:calc(var(--assistant-spacing)*0)}.assistant\\:p-1{padding:calc(var(--assistant-spacing)*1)}.assistant\\:p-2{padding:calc(var(--assistant-spacing)*2)}.assistant\\:p-3{padding:calc(var(--assistant-spacing)*3)}.assistant\\:p-3\\.5{padding:calc(var(--assistant-spacing)*3.5)}.assistant\\:p-4{padding:calc(var(--assistant-spacing)*4)}.assistant\\:px-2\\.5{padding-inline:calc(var(--assistant-spacing)*2.5)}.assistant\\:px-3{padding-inline:calc(var(--assistant-spacing)*3)}.assistant\\:px-4{padding-inline:calc(var(--assistant-spacing)*4)}.assistant\\:px-5{padding-inline:calc(var(--assistant-spacing)*5)}.assistant\\:px-6{padding-inline:calc(var(--assistant-spacing)*6)}.assistant\\:px-8{padding-inline:calc(var(--assistant-spacing)*8)}.assistant\\:px-\\[var\\(--thread-padding-x\\)\\]{padding-inline:var(--thread-padding-x)}.assistant\\:py-1\\.5{padding-block:calc(var(--assistant-spacing)*1.5)}.assistant\\:py-2{padding-block:calc(var(--assistant-spacing)*2)}.assistant\\:py-2\\.5{padding-block:calc(var(--assistant-spacing)*2.5)}.assistant\\:py-3{padding-block:calc(var(--assistant-spacing)*3)}.assistant\\:py-3\\.5{padding-block:calc(var(--assistant-spacing)*3.5)}.assistant\\:py-4{padding-block:calc(var(--assistant-spacing)*4)}.assistant\\:pt-2{padding-top:calc(var(--assistant-spacing)*2)}.assistant\\:pb-3{padding-bottom:calc(var(--assistant-spacing)*3)}.assistant\\:pb-4{padding-bottom:calc(var(--assistant-spacing)*4)}.assistant\\:pl-6{padding-left:calc(var(--assistant-spacing)*6)}.assistant\\:text-left{text-align:left}.assistant\\:text-start{text-align:start}.assistant\\:text-2xl{font-size:var(--assistant-text-2xl);line-height:var(--tw-leading,var(--assistant-text-2xl--line-height))}.assistant\\:text-3xl{font-size:var(--assistant-text-3xl);line-height:var(--tw-leading,var(--assistant-text-3xl--line-height))}.assistant\\:text-4xl{font-size:var(--assistant-text-4xl);line-height:var(--tw-leading,var(--assistant-text-4xl--line-height))}.assistant\\:text-base{font-size:var(--assistant-text-base);line-height:var(--tw-leading,var(--assistant-text-base--line-height))}.assistant\\:text-lg{font-size:var(--assistant-text-lg);line-height:var(--tw-leading,var(--assistant-text-lg--line-height))}.assistant\\:text-sm{font-size:var(--assistant-text-sm);line-height:var(--tw-leading,var(--assistant-text-sm--line-height))}.assistant\\:text-xl{font-size:var(--assistant-text-xl);line-height:var(--tw-leading,var(--assistant-text-xl--line-height))}.assistant\\:text-xs{font-size:var(--assistant-text-xs);line-height:var(--tw-leading,var(--assistant-text-xs--line-height))}.assistant\\:leading-7{--tw-leading:calc(var(--assistant-spacing)*7);line-height:calc(var(--assistant-spacing)*7)}.assistant\\:font-bold{--tw-font-weight:var(--assistant-font-weight-bold);font-weight:var(--assistant-font-weight-bold)}.assistant\\:font-extrabold{--tw-font-weight:var(--assistant-font-weight-extrabold);font-weight:var(--assistant-font-weight-extrabold)}.assistant\\:font-medium{--tw-font-weight:var(--assistant-font-weight-medium);font-weight:var(--assistant-font-weight-medium)}.assistant\\:font-semibold{--tw-font-weight:var(--assistant-font-weight-semibold);font-weight:var(--assistant-font-weight-semibold)}.assistant\\:tracking-tight{--tw-tracking:var(--assistant-tracking-tight);letter-spacing:var(--assistant-tracking-tight)}.assistant\\:text-balance{text-wrap:balance}.assistant\\:break-words{overflow-wrap:break-word}.assistant\\:whitespace-nowrap{white-space:nowrap}.assistant\\:whitespace-pre-wrap{white-space:pre-wrap}.assistant\\:text-destructive{color:var(--destructive)}.assistant\\:text-foreground{color:var(--foreground)}.assistant\\:text-muted-foreground,.assistant\\:text-muted-foreground\\/65{color:var(--muted-foreground)}@supports (color:color-mix(in lab,red,red)){.assistant\\:text-muted-foreground\\/65{color:color-mix(in oklab,var(--muted-foreground)65%,transparent)}}.assistant\\:text-primary{color:var(--primary)}.assistant\\:text-primary-foreground{color:var(--primary-foreground)}.assistant\\:text-secondary-foreground{color:var(--secondary-foreground)}.assistant\\:text-white{color:var(--assistant-color-white)}.assistant\\:lowercase{text-transform:lowercase}.assistant\\:italic{font-style:italic}.assistant\\:underline{text-decoration-line:underline}.assistant\\:underline-offset-4{text-underline-offset:4px}.assistant\\:shadow-xs{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.assistant\\:ring-1{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.assistant\\:ring-border{--tw-ring-color:var(--border)}.assistant\\:transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--assistant-default-transition-timing-function));transition-duration:var(--tw-duration,var(--assistant-default-transition-duration))}.assistant\\:fade-in-0{--tw-enter-opacity:0}.assistant\\:outline-none{--tw-outline-style:none;outline-style:none}.assistant\\:zoom-in-95{--tw-enter-scale:.95}.assistant\\:placeholder\\:text-muted-foreground::placeholder{color:var(--muted-foreground)}.assistant\\:first\\:mt-0:first-child{margin-top:calc(var(--assistant-spacing)*0)}.assistant\\:first\\:rounded-tl-lg:first-child{border-top-left-radius:var(--radius)}.assistant\\:first\\:border-t:first-child{border-top-style:var(--tw-border-style);border-top-width:1px}.assistant\\:last\\:mb-0:last-child{margin-bottom:calc(var(--assistant-spacing)*0)}.assistant\\:last\\:rounded-tr-lg:last-child{border-top-right-radius:var(--radius)}.assistant\\:last\\:border-r:last-child{border-right-style:var(--tw-border-style);border-right-width:1px}.assistant\\:focus-within\\:ring-2:focus-within{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.assistant\\:focus-within\\:ring-black:focus-within{--tw-ring-color:var(--assistant-color-black)}.assistant\\:focus-within\\:ring-offset-2:focus-within{--tw-ring-offset-width:2px;--tw-ring-offset-shadow:var(--tw-ring-inset,)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color)}@media (hover:hover){.assistant\\:hover\\:bg-accent:hover{background-color:var(--accent)}.assistant\\:hover\\:bg-destructive\\/90:hover{background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.assistant\\:hover\\:bg-destructive\\/90:hover{background-color:color-mix(in oklab,var(--destructive)90%,transparent)}}.assistant\\:hover\\:bg-foreground\\/15:hover{background-color:var(--foreground)}@supports (color:color-mix(in lab,red,red)){.assistant\\:hover\\:bg-foreground\\/15:hover{background-color:color-mix(in oklab,var(--foreground)15%,transparent)}}.assistant\\:hover\\:bg-muted:hover{background-color:var(--muted)}.assistant\\:hover\\:bg-primary\\/75:hover{background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.assistant\\:hover\\:bg-primary\\/75:hover{background-color:color-mix(in oklab,var(--primary)75%,transparent)}}.assistant\\:hover\\:bg-primary\\/90:hover{background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.assistant\\:hover\\:bg-primary\\/90:hover{background-color:color-mix(in oklab,var(--primary)90%,transparent)}}.assistant\\:hover\\:bg-secondary\\/80:hover{background-color:var(--secondary)}@supports (color:color-mix(in lab,red,red)){.assistant\\:hover\\:bg-secondary\\/80:hover{background-color:color-mix(in oklab,var(--secondary)80%,transparent)}}.assistant\\:hover\\:text-accent-foreground:hover{color:var(--accent-foreground)}.assistant\\:hover\\:text-foreground\\/60:hover{color:var(--foreground)}@supports (color:color-mix(in lab,red,red)){.assistant\\:hover\\:text-foreground\\/60:hover{color:color-mix(in oklab,var(--foreground)60%,transparent)}}.assistant\\:hover\\:underline:hover{text-decoration-line:underline}}.assistant\\:focus\\:outline-primary:focus{outline-color:var(--primary)}.assistant\\:focus-visible\\:border-ring:focus-visible{border-color:var(--ring)}.assistant\\:focus-visible\\:bg-muted:focus-visible{background-color:var(--muted)}.assistant\\:focus-visible\\:ring-2:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.assistant\\:focus-visible\\:ring-\\[3px\\]:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(3px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.assistant\\:focus-visible\\:ring-destructive\\/20:focus-visible{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.assistant\\:focus-visible\\:ring-destructive\\/20:focus-visible{--tw-ring-color:color-mix(in oklab,var(--destructive)20%,transparent)}}.assistant\\:focus-visible\\:ring-ring:focus-visible,.assistant\\:focus-visible\\:ring-ring\\/50:focus-visible{--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.assistant\\:focus-visible\\:ring-ring\\/50:focus-visible{--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.assistant\\:focus-visible\\:outline-none:focus-visible{--tw-outline-style:none;outline-style:none}.assistant\\:disabled\\:pointer-events-none:disabled{pointer-events:none}.assistant\\:disabled\\:invisible:disabled{visibility:hidden}.assistant\\:disabled\\:opacity-50:disabled{opacity:.5}.assistant\\:has-\\[\\>svg\\]\\:px-2\\.5:has(>svg){padding-inline:calc(var(--assistant-spacing)*2.5)}.assistant\\:has-\\[\\>svg\\]\\:px-3:has(>svg){padding-inline:calc(var(--assistant-spacing)*3)}.assistant\\:has-\\[\\>svg\\]\\:px-4:has(>svg){padding-inline:calc(var(--assistant-spacing)*4)}.assistant\\:aria-invalid\\:border-destructive[aria-invalid=true]{border-color:var(--destructive)}.assistant\\:aria-invalid\\:ring-destructive\\/20[aria-invalid=true]{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.assistant\\:aria-invalid\\:ring-destructive\\/20[aria-invalid=true]{--tw-ring-color:color-mix(in oklab,var(--destructive)20%,transparent)}}.assistant\\:data-active\\:bg-muted[data-active]{background-color:var(--muted)}.assistant\\:data-floating\\:absolute[data-floating]{position:absolute}.assistant\\:data-floating\\:mt-2[data-floating]{margin-top:calc(var(--assistant-spacing)*2)}.assistant\\:data-floating\\:rounded-md[data-floating]{border-radius:calc(var(--radius) - 2px)}.assistant\\:data-floating\\:border[data-floating]{border-style:var(--tw-border-style);border-width:1px}.assistant\\:data-floating\\:bg-background[data-floating]{background-color:var(--background)}.assistant\\:data-floating\\:p-1[data-floating]{padding:calc(var(--assistant-spacing)*1)}.assistant\\:data-floating\\:shadow-sm[data-floating]{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.assistant\\:data-\\[side\\=bottom\\]\\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y:calc(2*var(--spacing)*-1)}.assistant\\:data-\\[side\\=left\\]\\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x:calc(2*var(--spacing))}.assistant\\:data-\\[side\\=right\\]\\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x:calc(2*var(--spacing)*-1)}.assistant\\:data-\\[side\\=top\\]\\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y:calc(2*var(--spacing))}.assistant\\:data-\\[state\\=closed\\]\\:animate-out[data-state=closed]{animation:exit var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.assistant\\:data-\\[state\\=closed\\]\\:fade-out-0[data-state=closed]{--tw-exit-opacity:0}.assistant\\:data-\\[state\\=closed\\]\\:zoom-out-95[data-state=closed]{--tw-exit-scale:.95}@media (min-width:40rem){.assistant\\:sm\\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.assistant\\:sm\\:flex-col{flex-direction:column}}@media (min-width:48rem){.assistant\\:md\\:mt-20{margin-top:calc(var(--assistant-spacing)*20)}.assistant\\:md\\:pb-6{padding-bottom:calc(var(--assistant-spacing)*6)}}.assistant\\:\\[\\&_svg\\]\\:pointer-events-none svg{pointer-events:none}.assistant\\:\\[\\&_svg\\]\\:shrink-0 svg{flex-shrink:0}.assistant\\:\\[\\&_svg\\:not\\(\\[class\\*\\=size-\\]\\)\\]\\:size-4 svg:not([class*=size-]){width:calc(var(--assistant-spacing)*4);height:calc(var(--assistant-spacing)*4)}.assistant\\:\\[\\&\\:last-child\\>td\\:first-child\\]\\:rounded-bl-lg:last-child>td:first-child{border-bottom-left-radius:var(--radius)}.assistant\\:\\[\\&\\:last-child\\>td\\:last-child\\]\\:rounded-br-lg:last-child>td:last-child{border-bottom-right-radius:var(--radius)}.assistant\\:\\[\\&\\:nth-child\\(n\\+3\\)\\]\\:hidden:nth-child(n+3){display:none}@media (min-width:40rem){.assistant\\:sm\\:\\[\\&\\:nth-child\\(n\\+3\\)\\]\\:block:nth-child(n+3){display:block}}.assistant\\:\\[\\&\\:where\\(\\>\\*\\)\\]\\:col-start-2:where(){grid-column-start:2}.assistant\\:\\[\\&\\>a\\]\\:text-xs>a{font-size:var(--assistant-text-xs);line-height:var(--tw-leading,var(--assistant-text-xs--line-height))}.assistant\\:\\[\\&\\>a\\]\\:no-underline>a{text-decoration-line:none}.assistant\\:\\[\\&\\>li\\]\\:mt-2>li{margin-top:calc(var(--assistant-spacing)*2)}.assistant\\:\\[\\&\\>span\\]\\:text-xs>span{font-size:var(--assistant-text-xs);line-height:var(--tw-leading,var(--assistant-text-xs--line-height))}.assistant\\:\\[\\&\\[align\\=center\\]\\]\\:text-center[align=center]{text-align:center}.assistant\\:\\[\\&\\[align\\=right\\]\\]\\:text-right[align=right]{text-align:right}}@property --tw-animation-delay{syntax:"*";inherits:false;initial-value:0s}@property --tw-animation-direction{syntax:"*";inherits:false;initial-value:normal}@property --tw-animation-duration{syntax:"*";inherits:false}@property --tw-animation-fill-mode{syntax:"*";inherits:false;initial-value:none}@property --tw-animation-iteration-count{syntax:"*";inherits:false;initial-value:1}@property --tw-enter-blur{syntax:"*";inherits:false;initial-value:0}@property --tw-enter-opacity{syntax:"*";inherits:false;initial-value:1}@property --tw-enter-rotate{syntax:"*";inherits:false;initial-value:0}@property --tw-enter-scale{syntax:"*";inherits:false;initial-value:1}@property --tw-enter-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-enter-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-blur{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-opacity{syntax:"*";inherits:false;initial-value:1}@property --tw-exit-rotate{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-scale{syntax:"*";inherits:false;initial-value:1}@property --tw-exit-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-translate-y{syntax:"*";inherits:false;initial-value:0}:host{--radius:.625rem;--background:oklch(100% 0 0);--foreground:oklch(14.5% 0 0);--card:oklch(100% 0 0);--card-foreground:oklch(14.5% 0 0);--popover:oklch(100% 0 0);--popover-foreground:oklch(14.5% 0 0);--primary:oklch(20.5% 0 0);--primary-foreground:oklch(98.5% 0 0);--secondary:oklch(97% 0 0);--secondary-foreground:oklch(20.5% 0 0);--muted:oklch(97% 0 0);--muted-foreground:oklch(55.6% 0 0);--accent:oklch(97% 0 0);--accent-foreground:oklch(20.5% 0 0);--destructive:oklch(57.7% .245 27.325);--border:oklch(92.2% 0 0);--input:oklch(92.2% 0 0);--ring:oklch(70.8% 0 0);--chart-1:oklch(64.6% .222 41.116);--chart-2:oklch(60% .118 184.704);--chart-3:oklch(39.8% .07 227.392);--chart-4:oklch(82.8% .189 84.429);--chart-5:oklch(76.9% .188 70.08);--sidebar:oklch(98.5% 0 0);--sidebar-foreground:oklch(14.5% 0 0);--sidebar-primary:oklch(20.5% 0 0);--sidebar-primary-foreground:oklch(98.5% 0 0);--sidebar-accent:oklch(97% 0 0);--sidebar-accent-foreground:oklch(20.5% 0 0);--sidebar-border:oklch(92.2% 0 0);--sidebar-ring:oklch(70.8% 0 0)}:host(.dark){--background:oklch(14.5% 0 0);--foreground:oklch(98.5% 0 0);--card:oklch(20.5% 0 0);--card-foreground:oklch(98.5% 0 0);--popover:oklch(20.5% 0 0);--popover-foreground:oklch(98.5% 0 0);--primary:oklch(92.2% 0 0);--primary-foreground:oklch(20.5% 0 0);--secondary:oklch(26.9% 0 0);--secondary-foreground:oklch(98.5% 0 0);--muted:oklch(26.9% 0 0);--muted-foreground:oklch(70.8% 0 0);--accent:oklch(26.9% 0 0);--accent-foreground:oklch(98.5% 0 0);--destructive:oklch(70.4% .191 22.216);--border:oklch(100% 0 0/.1);--input:oklch(100% 0 0/.15);--ring:oklch(55.6% 0 0);--chart-1:oklch(48.8% .243 264.376);--chart-2:oklch(69.6% .17 162.48);--chart-3:oklch(76.9% .188 70.08);--chart-4:oklch(62.7% .265 303.9);--chart-5:oklch(64.5% .246 16.439);--sidebar:oklch(20.5% 0 0);--sidebar-foreground:oklch(98.5% 0 0);--sidebar-primary:oklch(48.8% .243 264.376);--sidebar-primary-foreground:oklch(98.5% 0 0);--sidebar-accent:oklch(26.9% 0 0);--sidebar-accent-foreground:oklch(98.5% 0 0);--sidebar-border:oklch(100% 0 0/.1);--sidebar-ring:oklch(55.6% 0 0)}@property --tw-border-spacing-x{syntax:"<length>";inherits:false;initial-value:0}@property --tw-border-spacing-y{syntax:"<length>";inherits:false;initial-value:0}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}@property --tw-scale-x{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-y{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-z{syntax:"*";inherits:false;initial-value:1}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-tracking{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@keyframes enter{0%{opacity:var(--tw-enter-opacity,1);transform:translate3d(var(--tw-enter-translate-x,0),var(--tw-enter-translate-y,0),0)scale3d(var(--tw-enter-scale,1),var(--tw-enter-scale,1),var(--tw-enter-scale,1))rotate(var(--tw-enter-rotate,0));filter:blur(var(--tw-enter-blur,0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity,1);transform:translate3d(var(--tw-exit-translate-x,0),var(--tw-exit-translate-y,0),0)scale3d(var(--tw-exit-scale,1),var(--tw-exit-scale,1),var(--tw-exit-scale,1))rotate(var(--tw-exit-rotate,0));filter:blur(var(--tw-exit-blur,0))}}', Goe = d6(Hoe, Lr, t6, {
  shadow: "open"
});
let ro = null;
try {
  ro = new CSSStyleSheet();
} catch {
  ro = null;
}
class Yoe extends Goe {
  async connectedCallback() {
    super.connectedCallback?.();
    const t = this.shadowRoot;
    if (!t) return;
    const n = qoe;
    if ("adoptedStyleSheets" in t && ro) {
      await ro.replace(n);
      const i = (t.adoptedStyleSheets || []).filter((r) => r !== ro);
      t.adoptedStyleSheets = [...i, ro];
    } else {
      let i = t.querySelector("style[data-widget]");
      i || (i = document.createElement("style"), i.setAttribute("data-widget", ""), t.prepend(i)), i.textContent = n;
    }
  }
}
customElements.get("my-widget") || customElements.define("my-widget", Yoe);
function rle(e = "#widget", t) {
  const n = typeof e == "string" ? document.querySelector(e) : e;
  if (!n) throw new Error("Mount target not found");
  const i = document.createElement("my-widget");
  return t && Object.assign(i, t), n.replaceChildren(i), i;
}
export {
  rle as mountMyWidget
};
//# sourceMappingURL=widget.es.js.map
